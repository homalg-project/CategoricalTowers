# SPDX-License-Identifier: GPL-2.0-or-later
# ToolsForCategoricalTowers: Tools for CategoricalTowers
#
# Implementations
#
# THIS FILE IS AUTOMATICALLY GENERATED, SEE CAP_project/CAP/gap/MethodRecordTools.gi

## BiasedRelativeWeakFiberProduct
InstallMethod( AddBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "BiasedRelativeWeakFiberProduct", category, func, -1 );
    
end );

InstallMethod( AddBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "BiasedRelativeWeakFiberProduct", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## Colimit
InstallMethod( AddColimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "Colimit", category, func, -1 );
    
end );

InstallMethod( AddColimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "Colimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## EmbeddingOfSumOfImagesOfAllMorphisms
InstallMethod( AddEmbeddingOfSumOfImagesOfAllMorphisms,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "EmbeddingOfSumOfImagesOfAllMorphisms", category, func, -1 );
    
end );

InstallMethod( AddEmbeddingOfSumOfImagesOfAllMorphisms,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "EmbeddingOfSumOfImagesOfAllMorphisms", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## InjectionOfCofactorOfColimit
InstallMethod( AddInjectionOfCofactorOfColimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "InjectionOfCofactorOfColimit", category, func, -1 );
    
end );

InstallMethod( AddInjectionOfCofactorOfColimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "InjectionOfCofactorOfColimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## InjectionOfCofactorOfColimitWithGivenColimit
InstallMethod( AddInjectionOfCofactorOfColimitWithGivenColimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "InjectionOfCofactorOfColimitWithGivenColimit", category, func, -1 );
    
end );

InstallMethod( AddInjectionOfCofactorOfColimitWithGivenColimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "InjectionOfCofactorOfColimitWithGivenColimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

AddDerivationToCAP( InjectionOfCofactorOfColimitWithGivenColimit,
                    "InjectionOfCofactorOfColimitWithGivenColimit by calling InjectionOfCofactorOfColimit with the WithGiven argument(s) dropped",
                    [
                        [ InjectionOfCofactorOfColimit, 1 ],
                    ],
  function( cat, objects, decorated_morphisms, k, P )
    
    return InjectionOfCofactorOfColimit( cat, objects, decorated_morphisms, k );
        
end : is_with_given_derivation := true );

AddDerivationToCAP( InjectionOfCofactorOfColimit,
                    "InjectionOfCofactorOfColimit by calling InjectionOfCofactorOfColimitWithGivenColimit with the WithGiven object(s)",
                    [
                        [ InjectionOfCofactorOfColimitWithGivenColimit, 1 ],
                        [ Colimit, 1 ],
                    ],
  function( cat, objects, decorated_morphisms, k )
    
    return InjectionOfCofactorOfColimitWithGivenColimit( cat, objects, decorated_morphisms, k, Colimit( cat, objects, decorated_morphisms ) );
    
end : is_with_given_derivation := true );

## IsWeakInitial
InstallMethod( AddIsWeakInitial,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "IsWeakInitial", category, func, -1 );
    
end );

InstallMethod( AddIsWeakInitial,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "IsWeakInitial", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## IsWeakTerminal
InstallMethod( AddIsWeakTerminal,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "IsWeakTerminal", category, func, -1 );
    
end );

InstallMethod( AddIsWeakTerminal,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "IsWeakTerminal", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## Limit
InstallMethod( AddLimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "Limit", category, func, -1 );
    
end );

InstallMethod( AddLimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "Limit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## MorphismBetweenCoproducts
InstallMethod( AddMorphismBetweenCoproducts,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "MorphismBetweenCoproducts", category, func, -1 );
    
end );

InstallMethod( AddMorphismBetweenCoproducts,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "MorphismBetweenCoproducts", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## MorphismBetweenCoproductsWithGivenCoproducts
InstallMethod( AddMorphismBetweenCoproductsWithGivenCoproducts,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "MorphismBetweenCoproductsWithGivenCoproducts", category, func, -1 );
    
end );

InstallMethod( AddMorphismBetweenCoproductsWithGivenCoproducts,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "MorphismBetweenCoproductsWithGivenCoproducts", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

AddDerivationToCAP( MorphismBetweenCoproductsWithGivenCoproducts,
                    "MorphismBetweenCoproductsWithGivenCoproducts by calling MorphismBetweenCoproducts with the WithGiven argument(s) dropped",
                    [
                        [ MorphismBetweenCoproducts, 1 ],
                    ],
  function( cat, S, source_diagram, pair, range_diagram, T )
    
    return MorphismBetweenCoproducts( cat, source_diagram, pair, range_diagram );
        
end : is_with_given_derivation := true );

AddDerivationToCAP( MorphismBetweenCoproducts,
                    "MorphismBetweenCoproducts by calling MorphismBetweenCoproductsWithGivenCoproducts with the WithGiven object(s)",
                    [
                        [ MorphismBetweenCoproductsWithGivenCoproducts, 1 ],
                        [ Coproduct, 2 ],
                    ],
  function( cat, source_diagram, pair, range_diagram )
    
    return MorphismBetweenCoproductsWithGivenCoproducts( cat, Coproduct( cat, source_diagram ), source_diagram, pair, range_diagram, Coproduct( cat, range_diagram ) );
    
end : is_with_given_derivation := true );

## MorphismBetweenDirectProducts
InstallMethod( AddMorphismBetweenDirectProducts,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "MorphismBetweenDirectProducts", category, func, -1 );
    
end );

InstallMethod( AddMorphismBetweenDirectProducts,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "MorphismBetweenDirectProducts", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## MorphismBetweenDirectProductsWithGivenDirectProducts
InstallMethod( AddMorphismBetweenDirectProductsWithGivenDirectProducts,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "MorphismBetweenDirectProductsWithGivenDirectProducts", category, func, -1 );
    
end );

InstallMethod( AddMorphismBetweenDirectProductsWithGivenDirectProducts,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "MorphismBetweenDirectProductsWithGivenDirectProducts", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

AddDerivationToCAP( MorphismBetweenDirectProductsWithGivenDirectProducts,
                    "MorphismBetweenDirectProductsWithGivenDirectProducts by calling MorphismBetweenDirectProducts with the WithGiven argument(s) dropped",
                    [
                        [ MorphismBetweenDirectProducts, 1 ],
                    ],
  function( cat, S, source_diagram, pair, range_diagram, T )
    
    return MorphismBetweenDirectProducts( cat, source_diagram, pair, range_diagram );
        
end : is_with_given_derivation := true );

AddDerivationToCAP( MorphismBetweenDirectProducts,
                    "MorphismBetweenDirectProducts by calling MorphismBetweenDirectProductsWithGivenDirectProducts with the WithGiven object(s)",
                    [
                        [ MorphismBetweenDirectProductsWithGivenDirectProducts, 1 ],
                        [ DirectProduct, 2 ],
                    ],
  function( cat, source_diagram, pair, range_diagram )
    
    return MorphismBetweenDirectProductsWithGivenDirectProducts( cat, DirectProduct( cat, source_diagram ), source_diagram, pair, range_diagram, DirectProduct( cat, range_diagram ) );
    
end : is_with_given_derivation := true );

## MorphismOntoSumOfImagesOfAllMorphisms
InstallMethod( AddMorphismOntoSumOfImagesOfAllMorphisms,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "MorphismOntoSumOfImagesOfAllMorphisms", category, func, -1 );
    
end );

InstallMethod( AddMorphismOntoSumOfImagesOfAllMorphisms,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "MorphismOntoSumOfImagesOfAllMorphisms", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## ProjectionInFactorOfLimit
InstallMethod( AddProjectionInFactorOfLimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "ProjectionInFactorOfLimit", category, func, -1 );
    
end );

InstallMethod( AddProjectionInFactorOfLimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "ProjectionInFactorOfLimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## ProjectionInFactorOfLimitWithGivenLimit
InstallMethod( AddProjectionInFactorOfLimitWithGivenLimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "ProjectionInFactorOfLimitWithGivenLimit", category, func, -1 );
    
end );

InstallMethod( AddProjectionInFactorOfLimitWithGivenLimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "ProjectionInFactorOfLimitWithGivenLimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

AddDerivationToCAP( ProjectionInFactorOfLimitWithGivenLimit,
                    "ProjectionInFactorOfLimitWithGivenLimit by calling ProjectionInFactorOfLimit with the WithGiven argument(s) dropped",
                    [
                        [ ProjectionInFactorOfLimit, 1 ],
                    ],
  function( cat, objects, decorated_morphisms, k, P )
    
    return ProjectionInFactorOfLimit( cat, objects, decorated_morphisms, k );
        
end : is_with_given_derivation := true );

AddDerivationToCAP( ProjectionInFactorOfLimit,
                    "ProjectionInFactorOfLimit by calling ProjectionInFactorOfLimitWithGivenLimit with the WithGiven object(s)",
                    [
                        [ ProjectionInFactorOfLimitWithGivenLimit, 1 ],
                        [ Limit, 1 ],
                    ],
  function( cat, objects, decorated_morphisms, k )
    
    return ProjectionInFactorOfLimitWithGivenLimit( cat, objects, decorated_morphisms, k, Limit( cat, objects, decorated_morphisms ) );
    
end : is_with_given_derivation := true );

## ProjectionOfBiasedRelativeWeakFiberProduct
InstallMethod( AddProjectionOfBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "ProjectionOfBiasedRelativeWeakFiberProduct", category, func, -1 );
    
end );

InstallMethod( AddProjectionOfBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "ProjectionOfBiasedRelativeWeakFiberProduct", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## ProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct
InstallMethod( AddProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "ProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct", category, func, -1 );
    
end );

InstallMethod( AddProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "ProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

AddDerivationToCAP( ProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct,
                    "ProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct by calling ProjectionOfBiasedRelativeWeakFiberProduct with the WithGiven argument(s) dropped",
                    [
                        [ ProjectionOfBiasedRelativeWeakFiberProduct, 1 ],
                    ],
  function( cat, a, b, c, P )
    
    return ProjectionOfBiasedRelativeWeakFiberProduct( cat, a, b, c );
        
end : is_with_given_derivation := true );

AddDerivationToCAP( ProjectionOfBiasedRelativeWeakFiberProduct,
                    "ProjectionOfBiasedRelativeWeakFiberProduct by calling ProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct with the WithGiven object(s)",
                    [
                        [ ProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct, 1 ],
                        [ BiasedRelativeWeakFiberProduct, 1 ],
                    ],
  function( cat, a, b, c )
    
    return ProjectionOfBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct( cat, a, b, c, BiasedRelativeWeakFiberProduct( cat, a, b, c ) );
    
end : is_with_given_derivation := true );

## RelativeLift
InstallMethod( AddRelativeLift,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "RelativeLift", category, func, -1 );
    
end );

InstallMethod( AddRelativeLift,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "RelativeLift", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## SumOfImagesOfAllMorphisms
InstallMethod( AddSumOfImagesOfAllMorphisms,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "SumOfImagesOfAllMorphisms", category, func, -1 );
    
end );

InstallMethod( AddSumOfImagesOfAllMorphisms,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "SumOfImagesOfAllMorphisms", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## UniversalMorphismFromColimit
InstallMethod( AddUniversalMorphismFromColimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "UniversalMorphismFromColimit", category, func, -1 );
    
end );

InstallMethod( AddUniversalMorphismFromColimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "UniversalMorphismFromColimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## UniversalMorphismFromColimitWithGivenColimit
InstallMethod( AddUniversalMorphismFromColimitWithGivenColimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "UniversalMorphismFromColimitWithGivenColimit", category, func, -1 );
    
end );

InstallMethod( AddUniversalMorphismFromColimitWithGivenColimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "UniversalMorphismFromColimitWithGivenColimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

AddDerivationToCAP( UniversalMorphismFromColimitWithGivenColimit,
                    "UniversalMorphismFromColimitWithGivenColimit by calling UniversalMorphismFromColimit with the WithGiven argument(s) dropped",
                    [
                        [ UniversalMorphismFromColimit, 1 ],
                    ],
  function( cat, objects, decorated_morphisms, T, tau, P )
    
    return UniversalMorphismFromColimit( cat, objects, decorated_morphisms, T, tau );
        
end : is_with_given_derivation := true );

AddDerivationToCAP( UniversalMorphismFromColimit,
                    "UniversalMorphismFromColimit by calling UniversalMorphismFromColimitWithGivenColimit with the WithGiven object(s)",
                    [
                        [ UniversalMorphismFromColimitWithGivenColimit, 1 ],
                        [ Colimit, 1 ],
                    ],
  function( cat, objects, decorated_morphisms, T, tau )
    
    return UniversalMorphismFromColimitWithGivenColimit( cat, objects, decorated_morphisms, T, tau, Colimit( cat, objects, decorated_morphisms ) );
    
end : is_with_given_derivation := true );

## UniversalMorphismIntoBiasedRelativeWeakFiberProduct
InstallMethod( AddUniversalMorphismIntoBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "UniversalMorphismIntoBiasedRelativeWeakFiberProduct", category, func, -1 );
    
end );

InstallMethod( AddUniversalMorphismIntoBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "UniversalMorphismIntoBiasedRelativeWeakFiberProduct", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## UniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct
InstallMethod( AddUniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "UniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct", category, func, -1 );
    
end );

InstallMethod( AddUniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "UniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

AddDerivationToCAP( UniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct,
                    "UniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct by calling UniversalMorphismIntoBiasedRelativeWeakFiberProduct with the WithGiven argument(s) dropped",
                    [
                        [ UniversalMorphismIntoBiasedRelativeWeakFiberProduct, 1 ],
                    ],
  function( cat, a, b, c, t, P )
    
    return UniversalMorphismIntoBiasedRelativeWeakFiberProduct( cat, a, b, c, t );
        
end : is_with_given_derivation := true );

AddDerivationToCAP( UniversalMorphismIntoBiasedRelativeWeakFiberProduct,
                    "UniversalMorphismIntoBiasedRelativeWeakFiberProduct by calling UniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct with the WithGiven object(s)",
                    [
                        [ UniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct, 1 ],
                        [ BiasedRelativeWeakFiberProduct, 1 ],
                    ],
  function( cat, a, b, c, t )
    
    return UniversalMorphismIntoBiasedRelativeWeakFiberProductWithGivenBiasedRelativeWeakFiberProduct( cat, a, b, c, t, BiasedRelativeWeakFiberProduct( cat, a, b, c ) );
    
end : is_with_given_derivation := true );

## UniversalMorphismIntoLimit
InstallMethod( AddUniversalMorphismIntoLimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "UniversalMorphismIntoLimit", category, func, -1 );
    
end );

InstallMethod( AddUniversalMorphismIntoLimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "UniversalMorphismIntoLimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

## UniversalMorphismIntoLimitWithGivenLimit
InstallMethod( AddUniversalMorphismIntoLimitWithGivenLimit,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    
    AddCapOperation( "UniversalMorphismIntoLimitWithGivenLimit", category, func, -1 );
    
end );

InstallMethod( AddUniversalMorphismIntoLimitWithGivenLimit,
               [ IsCapCategory, IsFunction, IsInt ],
               
    FunctionWithNamedArguments(
        [
            [ "IsPrecompiledDerivation", false ],
        ],
        function( CAP_NAMED_ARGUMENTS, category, func, weight )
            
            AddCapOperation( "UniversalMorphismIntoLimitWithGivenLimit", category, func, weight : IsPrecompiledDerivation := CAP_NAMED_ARGUMENTS.IsPrecompiledDerivation );
            
        end
    )
);

AddDerivationToCAP( UniversalMorphismIntoLimitWithGivenLimit,
                    "UniversalMorphismIntoLimitWithGivenLimit by calling UniversalMorphismIntoLimit with the WithGiven argument(s) dropped",
                    [
                        [ UniversalMorphismIntoLimit, 1 ],
                    ],
  function( cat, objects, decorated_morphisms, T, tau, P )
    
    return UniversalMorphismIntoLimit( cat, objects, decorated_morphisms, T, tau );
        
end : is_with_given_derivation := true );

AddDerivationToCAP( UniversalMorphismIntoLimit,
                    "UniversalMorphismIntoLimit by calling UniversalMorphismIntoLimitWithGivenLimit with the WithGiven object(s)",
                    [
                        [ UniversalMorphismIntoLimitWithGivenLimit, 1 ],
                        [ Limit, 1 ],
                    ],
  function( cat, objects, decorated_morphisms, T, tau )
    
    return UniversalMorphismIntoLimitWithGivenLimit( cat, objects, decorated_morphisms, T, tau, Limit( cat, objects, decorated_morphisms ) );
    
end : is_with_given_derivation := true );
