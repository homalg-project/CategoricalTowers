<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (FunctorCategories) - Chapter 2: Category of presheaves of a finitely presented (linear) category</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2.html">[MathJax off]</a></p>
<p><a id="X81D4C147794C661B" name="X81D4C147794C661B"></a></p>
<div class="ChapSects"><a href="chap2_mj.html#X81D4C147794C661B">2 <span class="Heading">Category of presheaves of a finitely presented (linear) category</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X86EC0F0A78ECBC10">2.1 <span class="Heading">Constructors</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8003D06979028BD0">2.1-1 PreSheaves</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7CEFF80E839359CB">2.1-2 CreatePreSheaf</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X81EDE6777FFE1488">2.1-3 CreatePreSheafMorphismByValues</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X780C212A8684F905">2.1-4 CoYonedaLemmaOnObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X786DDC3D78506E67">2.1-5 CoYonedaLemmaOnMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X827E29C38644BCD4">2.1-6 CoequalizerDataOfPreSheafUsingCoYonedaLemma</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7A9FB31B868D9E48">2.1-7 CoYonedaLemmaCoequalizerPair</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X821AA7AA7948F633">2.1-8 EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheavesData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X86EB451085D39300">2.1-9 EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheaves</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X82BC46C67AF3613D">2.1-10 MorphismFromRepresentableByYonedaLemma</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7AB199C37DF2BA45">2.1-11 MorphismFromCoproductOfRepresentables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X858DFF4983366041">2.1-12 MaximalMorphismFromRepresentable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X844C043E793E6DD8">2.1-13 CoveringListOfRepresentables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7B1C3BB978530117">2.1-14 CoveringListOfRepresentablesUsingSplits</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X82A244D382AA198D">2.1-15 EpimorphismFromSomeProjectiveObjectUsingSplits</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X82B7BCB47FEEC49E">2.1-16 SectionAndComplementByCoveringListOfRepresentables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8795EC0A83B293C9">2.1-17 SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7A2EE5E87845AD28">2.1-18 RetractionByCoveringListOfRepresentables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X78B0D62B804C7151">2.1-19 RetractionFromCoYonedaProjectiveObjectOntoOptimizedCoYonedaProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7F72398C8000D65E">2.1-20 OptimizedCoYonedaLemmaOnObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7803E9CE7BD7C6F2">2.1-21 OptimizedCoYonedaLemmaOnMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X787F312781932751">2.1-22 CoequalizerDataOfPreSheafUsingOptimizedCoYonedaLemma</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8562DCE087EFE17B">2.1-23 AssociatedCoequalizerPairInPreSheaves</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X825F87D58071970E">2.1-24 AssociatedCoequalizerPairInPreSheaves</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X794727C8841471FE">2.1-25 OptimizedCoYonedaLemmaCoequalizerPair</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D3C5AC7809B7140">2.1-26 ApplyPreSheafToObjectInFiniteStrictCoproductCompletion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X78D9A464872F2B44">2.1-27 ApplyPreSheafToMorphismInFiniteStrictCoproductCompletion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7838509887AE558D">2.1-28 CategoryOfInternalCategories</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7C701DBF7BAE649A">2.2 <span class="Heading">Attributes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X853357DD7DA1350B">2.2-1 ValuesOnAllObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X865F04DE869EB218">2.2-2 UnderlyingCapTwoCategoryCell</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8441A5F38325BDF0">2.2-3 YonedaEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D850F4D7AECF129">2.2-4 YonedaEmbeddingOfSourceCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8186B25287502757">2.2-5 ImageOfYonedaEmbeddingOfSource</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7FC3EAA5875031CA">2.2-6 SimpleObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X80048E1182551690">2.2-7 NerveTruncatedInDegree2</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X87B457D77A0B8836">2.2-8 SievesOfPathsToTruth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8261C63782F8429B">2.2-9 FiniteStrictCoproductCompletionOfSourceCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8416902A79A168D5">2.2-10 FiniteColimitCompletionWithStrictCoproductsOfSourceCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7AF9281086551EFD">2.2-11 CategoryOfColimitQuiversOfSourceCategory</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7DE8E16C7C2D387B">2.3 <span class="Heading">Operations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7C89E11C7CE7731E">2.3-1 ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X81634D6E7DCD5F98">2.3-2 ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X838382A379533D06">2.3-3 ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToGeneratingMorphismOrIdentity</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X818BD23678113F05">2.3-4 ApplyMorphismInPreSheafCategoryOfFpEnrichedCategoryToObject</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7D03633A7D98026B">2.4 <span class="Heading"><strong class="pkg">GAP</strong> Categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D6A79907FA8C87F">2.4-1 IsPreSheafCategoryOfFpEnrichedCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7A0304637E934E63">2.4-2 IsCellInPreSheafCategoryOfFpEnrichedCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X869C3AEE85A01110">2.4-3 IsObjectInPreSheafCategoryOfFpEnrichedCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X81AF24BF84DADFA5">2.4-4 IsMorphismInPreSheafCategoryOfFpEnrichedCategory</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7D9044767BEB1523">2.5 <span class="Heading">Global variables</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7A489A5D79DA9E5C">2.6 <span class="Heading">Examples</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X84E9E37085A85D7B">2.6-1 <span class="Heading">The subobject classifier</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D24566D80D64552">2.6-2 <span class="Heading">PreSheaves of non-f.p. categories (experimental)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X811C52E07B3BE2A4">2.6-3 <span class="Heading">The colimit completion of a cyclic monoid</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7EF1F1847C6C6973">2.6-4 <span class="Heading">The linearization of the colimit completion of a cyclic monoid</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X813922347AE64B28">2.6-5 <span class="Heading">The Weierstrass normal form</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X83AF88FC800DB182">2.6-6 <span class="Heading">Optimized co-Yoneda lemma for posets</span></a>
</span>
</div></div>
</div>

<h3>2 <span class="Heading">Category of presheaves of a finitely presented (linear) category</span></h3>

<p><a id="X86EC0F0A78ECBC10" name="X86EC0F0A78ECBC10"></a></p>

<h4>2.1 <span class="Heading">Constructors</span></h4>

<p><a id="X8003D06979028BD0" name="X8003D06979028BD0"></a></p>

<h5>2.1-1 PreSheaves</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreSheaves</code>( <var class="Arg">B</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X7CEFF80E839359CB" name="X7CEFF80E839359CB"></a></p>

<h5>2.1-2 CreatePreSheaf</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreatePreSheaf</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreatePreSheaf</code>( <var class="Arg">B</var>, <var class="Arg">rec_images_of_objects</var>, <var class="Arg">rec_images_of_morphisms</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreatePreSheaf</code>( <var class="Arg">B</var>, <var class="Arg">images_of_objects</var>, <var class="Arg">images_of_morphisms</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a presheaf</p>

<p>Turn the functor <code class="code"><var class="Arg">F</var>:<var class="Arg">B</var>^op</code> <span class="SimpleMath">\(\to\)</span> <code class="code">D</code> into an object in the category of functors <code class="code"><var class="Arg">PSh</var> := PreSheaves( <var class="Arg">B</var>, D )</code>. An alternative input is the source category <var class="Arg">B</var> and two defining records <var class="Arg">rec_images_of_objects</var> and <var class="Arg">rec_images_of_morphisms</var> of <var class="Arg">F</var>. Another alternative input is the source category <var class="Arg">B</var> and two defining lists <var class="Arg">images_of_objects</var> and <var class="Arg">images_of_morphisms</var> of <var class="Arg">F</var>. The order of their entries must correspond to that of the vertices and arrows of the underlying quiver.</p>

<p>For the convenience of the user the following input is also valid: If <var class="Arg">images_of_objects</var> is a list of nonnegative integers, <var class="Arg">images_of_morphisms</var> is a list of matrices, and <span class="SimpleMath">\(k:=\)</span> <code class="code">CommutativeRingOfLinearCategory</code>( B ) is a field then the two lists are interpreted as objects and morphisms in a matrix category or a category of rows over <span class="SimpleMath">\(k\)</span>, respectively.</p>

<p><a id="X81EDE6777FFE1488" name="X81EDE6777FFE1488"></a></p>

<h5>2.1-3 CreatePreSheafMorphismByValues</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreatePreSheafMorphismByValues</code>( <var class="Arg">arg1</var>, <var class="Arg">arg2</var>, <var class="Arg">arg3</var>, <var class="Arg">arg4</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreatePreSheafMorphism</code>( <var class="Arg">eta</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreatePreSheafMorphism</code>( <var class="Arg">U</var>, <var class="Arg">e</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreatePreSheafMorphism</code>( <var class="Arg">U</var>, <var class="Arg">e</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreatePreSheafMorphismByFunction</code>( <var class="Arg">arg1</var>, <var class="Arg">arg2</var>, <var class="Arg">arg3</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism in a <strong class="pkg">CAP</strong> category</p>

<p>Turn the natrual transformation <var class="Arg">eta</var>:<span class="SimpleMath">\(F \to G\)</span> into a morphism <code class="code"><var class="Arg">U</var> := AsObjectInFunctorCategory( F )</code> <span class="SimpleMath">\(\to\)</span> <code class="code"><var class="Arg">V</var> := AsObjectInFunctorCategory( G )</code> in the category of functors <code class="code"><var class="Arg">Hom</var> := Hom( B, D )</code>, where <code class="code">B := Source( F ) = Source( G )</code> and <code class="code">C := Target( F ) = Target( G )</code>.</p>

<p>An alternative input is the triple (<var class="Arg">U</var>, <var class="Arg">e</var>, <var class="Arg">V</var>), where <var class="Arg">e</var> is a defining record of <var class="Arg">eta</var>.</p>

<p>Another alternative input is the triple (<var class="Arg">U</var>, <var class="Arg">e</var>, <var class="Arg">V</var>), where <var class="Arg">e</var> is a defining list of <var class="Arg">eta</var>.</p>

<p><a id="X780C212A8684F905" name="X780C212A8684F905"></a></p>

<h5>2.1-4 CoYonedaLemmaOnObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoYonedaLemmaOnObjects</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X786DDC3D78506E67" name="X786DDC3D78506E67"></a></p>

<h5>2.1-5 CoYonedaLemmaOnMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoYonedaLemmaOnMorphisms</code>( <var class="Arg">phi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X827E29C38644BCD4" name="X827E29C38644BCD4"></a></p>

<h5>2.1-6 CoequalizerDataOfPreSheafUsingCoYonedaLemma</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoequalizerDataOfPreSheafUsingCoYonedaLemma</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7A9FB31B868D9E48" name="X7A9FB31B868D9E48"></a></p>

<h5>2.1-7 CoYonedaLemmaCoequalizerPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoYonedaLemmaCoequalizerPair</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X821AA7AA7948F633" name="X821AA7AA7948F633"></a></p>

<h5>2.1-8 EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheavesData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheavesData</code>( <var class="Arg">PSh</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X86EB451085D39300" name="X86EB451085D39300"></a></p>

<h5>2.1-9 EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheaves</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheaves</code>( <var class="Arg">PSh</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X82BC46C67AF3613D" name="X82BC46C67AF3613D"></a></p>

<h5>2.1-10 MorphismFromRepresentableByYonedaLemma</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismFromRepresentableByYonedaLemma</code>( <var class="Arg">PSh</var>, <var class="Arg">objB</var>, <var class="Arg">morC</var>, <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X7AB199C37DF2BA45" name="X7AB199C37DF2BA45"></a></p>

<h5>2.1-11 MorphismFromCoproductOfRepresentables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismFromCoproductOfRepresentables</code>( <var class="Arg">PSh</var>, <var class="Arg">list</var>, <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X858DFF4983366041" name="X858DFF4983366041"></a></p>

<h5>2.1-12 MaximalMorphismFromRepresentable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaximalMorphismFromRepresentable</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X844C043E793E6DD8" name="X844C043E793E6DD8"></a></p>

<h5>2.1-13 CoveringListOfRepresentables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoveringListOfRepresentables</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7B1C3BB978530117" name="X7B1C3BB978530117"></a></p>

<h5>2.1-14 CoveringListOfRepresentablesUsingSplits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoveringListOfRepresentablesUsingSplits</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X82A244D382AA198D" name="X82A244D382AA198D"></a></p>

<h5>2.1-15 EpimorphismFromSomeProjectiveObjectUsingSplits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismFromSomeProjectiveObjectUsingSplits</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X82B7BCB47FEEC49E" name="X82B7BCB47FEEC49E"></a></p>

<h5>2.1-16 SectionAndComplementByCoveringListOfRepresentables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SectionAndComplementByCoveringListOfRepresentables</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X8795EC0A83B293C9" name="X8795EC0A83B293C9"></a></p>

<h5>2.1-17 SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7A2EE5E87845AD28" name="X7A2EE5E87845AD28"></a></p>

<h5>2.1-18 RetractionByCoveringListOfRepresentables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RetractionByCoveringListOfRepresentables</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X78B0D62B804C7151" name="X78B0D62B804C7151"></a></p>

<h5>2.1-19 RetractionFromCoYonedaProjectiveObjectOntoOptimizedCoYonedaProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RetractionFromCoYonedaProjectiveObjectOntoOptimizedCoYonedaProjectiveObject</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7F72398C8000D65E" name="X7F72398C8000D65E"></a></p>

<h5>2.1-20 OptimizedCoYonedaLemmaOnObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OptimizedCoYonedaLemmaOnObjects</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7803E9CE7BD7C6F2" name="X7803E9CE7BD7C6F2"></a></p>

<h5>2.1-21 OptimizedCoYonedaLemmaOnMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OptimizedCoYonedaLemmaOnMorphisms</code>( <var class="Arg">phi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X787F312781932751" name="X787F312781932751"></a></p>

<h5>2.1-22 CoequalizerDataOfPreSheafUsingOptimizedCoYonedaLemma</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoequalizerDataOfPreSheafUsingOptimizedCoYonedaLemma</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X8562DCE087EFE17B" name="X8562DCE087EFE17B"></a></p>

<h5>2.1-23 AssociatedCoequalizerPairInPreSheaves</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssociatedCoequalizerPairInPreSheaves</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X825F87D58071970E" name="X825F87D58071970E"></a></p>

<h5>2.1-24 AssociatedCoequalizerPairInPreSheaves</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssociatedCoequalizerPairInPreSheaves</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X794727C8841471FE" name="X794727C8841471FE"></a></p>

<h5>2.1-25 OptimizedCoYonedaLemmaCoequalizerPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OptimizedCoYonedaLemmaCoequalizerPair</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7D3C5AC7809B7140" name="X7D3C5AC7809B7140"></a></p>

<h5>2.1-26 ApplyPreSheafToObjectInFiniteStrictCoproductCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyPreSheafToObjectInFiniteStrictCoproductCompletion</code>( <var class="Arg">PSh</var>, <var class="Arg">presheaf</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X78D9A464872F2B44" name="X78D9A464872F2B44"></a></p>

<h5>2.1-27 ApplyPreSheafToMorphismInFiniteStrictCoproductCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyPreSheafToMorphismInFiniteStrictCoproductCompletion</code>( <var class="Arg">PSh</var>, <var class="Arg">presheaf</var>, <var class="Arg">mor</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X7838509887AE558D" name="X7838509887AE558D"></a></p>

<h5>2.1-28 CategoryOfInternalCategories</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CategoryOfInternalCategories</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Construct the category of categories internal to the monoidal or cartesian category <var class="Arg">C</var>. The output the full subcategory of the subcategory of functors from the <code class="code">SimplicialCategoryTruncatedInDegree</code>(2) into <var class="Arg">C</var> for which each such functor is the nerve truncated in degree <span class="SimpleMath">\(2\)</span> of a category internal to <var class="Arg">C</var>.</p>

<p><a id="X7C701DBF7BAE649A" name="X7C701DBF7BAE649A"></a></p>

<h4>2.2 <span class="Heading">Attributes</span></h4>

<p><a id="X853357DD7DA1350B" name="X853357DD7DA1350B"></a></p>

<h5>2.2-1 ValuesOnAllObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ValuesOnAllObjects</code>( <var class="Arg">eta</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Returns the values of the presheaf morphism <var class="Arg">eta</var> on all objects of the source category of presheaf category <var class="Arg">PSh</var>.</p>

<p>The 2-cell underlying the functor object <var class="Arg">F_or_eta</var>.</p>

<p><a id="X865F04DE869EB218" name="X865F04DE869EB218"></a></p>

<h5>2.2-2 UnderlyingCapTwoCategoryCell</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingCapTwoCategoryCell</code>( <var class="Arg">F_or_eta</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor or natural transformation</p>

<p><a id="X8441A5F38325BDF0" name="X8441A5F38325BDF0"></a></p>

<h5>2.2-3 YonedaEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YonedaEmbedding</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p><a id="X7D850F4D7AECF129" name="X7D850F4D7AECF129"></a></p>

<h5>2.2-4 YonedaEmbeddingOfSourceCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YonedaEmbeddingOfSourceCategory</code>( <var class="Arg">PSh</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p><a id="X8186B25287502757" name="X8186B25287502757"></a></p>

<h5>2.2-5 ImageOfYonedaEmbeddingOfSource</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageOfYonedaEmbeddingOfSource</code>( <var class="Arg">PSh</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>Returns the full subcategory of <var class="Arg">PSh</var> generated by the values of the Yoneda embedding on the objects of <code class="code">Source</code>(<var class="Arg">PSh</var>).</p>

<p><a id="X7FC3EAA5875031CA" name="X7FC3EAA5875031CA"></a></p>

<h5>2.2-6 SimpleObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleObjects</code>( <var class="Arg">PSh</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of objects</p>

<p>The input is a category of presheaves <var class="Arg">PSh</var> of an admissible <span class="SimpleMath">\(k\)</span>-algebroid for some field <span class="SimpleMath">\(k\)</span>. The output is the list of simple objects in <var class="Arg">PSh</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( RightQuiver( "q(1,2,3)[a:1-&gt;2,b:2-&gt;3]" ) );</span>
FreeCategory( RightQuiver( "q(3)[a:1-&gt;2,b:2-&gt;3]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QF := Q[F];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(3)[a:1-&gt;2,b:2-&gt;3]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A3 := QF / [ QF.ab ];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(3)[a:1-&gt;2,b:2-&gt;3]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( A3 );</span>
PreSheaves( Algebroid( Q, FreeCategory( RightQuiver( "q(3)[a:1-&gt;2,b:2-&gt;3]" ) ) )
/ relations, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleObjects( PSh );</span>
[ &lt;(1)-&gt;1, (2)-&gt;0, (3)-&gt;0; (a)-&gt;0x1, (b)-&gt;0x0&gt;,
  &lt;(1)-&gt;0, (2)-&gt;1, (3)-&gt;0; (a)-&gt;1x0, (b)-&gt;0x1&gt;,
  &lt;(1)-&gt;0, (2)-&gt;0, (3)-&gt;1; (a)-&gt;0x0, (b)-&gt;1x0&gt; ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]" );</span>
q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,
y:4-&gt;4]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kF := k[F];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,
c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := kF / [ kF.x^3, kF.y^2 ];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,
c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( A );</span>
PreSheaves( Algebroid( Q, FreeCategory( RightQuiver( "q(4)[x:1-&gt;1,
a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]" ) ) ) / relations, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PSh.4;</span>
&lt;(1)-&gt;12, (2)-&gt;2, (3)-&gt;2, (4)-&gt;2; (x)-&gt;12x12, (a)-&gt;2x12, (b)-&gt;2x2,
(c)-&gt;2x12, (d)-&gt;2x2, (y)-&gt;2x2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( P );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( P );</span>
Image of &lt;(1)&gt;:
A row module over Q of rank 12

Image of &lt;(2)&gt;:
A row module over Q of rank 2

Image of &lt;(3)&gt;:
A row module over Q of rank 2

Image of &lt;(4)&gt;:
A row module over Q of rank 2

Image of (1)-[{ 1*(x) }]-&gt;(1):
Source:
A row module over Q of rank 12

Matrix:
[ [  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 12

A morphism in Rows( Q )

Image of (1)-[{ 1*(a) }]-&gt;(2):
Source:
A row module over Q of rank 2

Matrix:
[ [  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 12

A morphism in Rows( Q )

Image of (2)-[{ 1*(b) }]-&gt;(4):
Source:
A row module over Q of rank 2

Matrix:
[ [  1,  0 ],
  [  0,  1 ] ]

Range:
A row module over Q of rank 2

A morphism in Rows( Q )

Image of (1)-[{ 1*(c) }]-&gt;(3):
Source:
A row module over Q of rank 2

Matrix:
[ [  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 12

A morphism in Rows( Q )

Image of (3)-[{ 1*(d) }]-&gt;(4):
Source:
A row module over Q of rank 2

Matrix:
[ [  1,  0 ],
  [  0,  1 ] ]

Range:
A row module over Q of rank 2

A morphism in Rows( Q )

Image of (4)-[{ 1*(y) }]-&gt;(4):
Source:
A row module over Q of rank 2

Matrix:
[ [  0,  1 ],
  [  0,  0 ] ]

Range:
A row module over Q of rank 2

A morphism in Rows( Q )

An object in PreSheaves( Algebroid( Q, FreeCategory( RightQuiver( "q(4)[x:1-&gt;1,
a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]" ) ) ) / relations, Rows( Q ) ) given by
the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( MonomorphismIntoSomeInjectiveObject( P ) );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]" );</span>
q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,y:4-&gt;4]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kF := k[F];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(4)[x:1-&gt;1,a:1-&gt;2,b:2-&gt;4,c:1-&gt;3,d:3-&gt;4,
y:4-&gt;4]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := AlgebroidFromDataTables( kF / [ kF.x^3, kF.y^2 ] );</span>
Q-algebroid( {1,2,3,4}[x:1-≻1,a:1-≻2,b:2-≻4,c:1-≻3,d:3-≻4,y:4-≻4] ) defined by 4 objects
and 6 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetIsAdmissibleAlgebroid( A, true );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( A );</span>
PreSheaves( Q-algebroid( {1,2,3,4}[x:1-≻1,a:1-≻2,b:2-≻4,c:1-≻3,d:3-≻4,y:4-≻4] ) defined
by 4 objects and 6 generating morphisms, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PSh.4;</span>
&lt;(1)-&gt;12, (2)-&gt;2, (3)-&gt;2, (4)-&gt;2; (x)-&gt;12x12, (a)-&gt;2x12, (b)-&gt;2x2,
(c)-&gt;2x12, (d)-&gt;2x2, (y)-&gt;2x2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( P );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( P );</span>
Image of &lt;(1)&gt;:
A row module over Q of rank 12

Image of &lt;(2)&gt;:
A row module over Q of rank 2

Image of &lt;(3)&gt;:
A row module over Q of rank 2

Image of &lt;(4)&gt;:
A row module over Q of rank 2

Image of &lt;1*x:(1) -≻ (1)&gt;:
Source:
A row module over Q of rank 12

Matrix:
[ [  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 12

A morphism in Rows( Q )

Image of &lt;1*a:(1) -≻ (2)&gt;:
Source:
A row module over Q of rank 2

Matrix:
[ [  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 12

A morphism in Rows( Q )

Image of &lt;1*b:(2) -≻ (4)&gt;:
Source:
A row module over Q of rank 2

Matrix:
[ [  1,  0 ],
  [  0,  1 ] ]

Range:
A row module over Q of rank 2

A morphism in Rows( Q )

Image of &lt;1*c:(1) -≻ (3)&gt;:
Source:
A row module over Q of rank 2

Matrix:
[ [  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 12

A morphism in Rows( Q )

Image of &lt;1*d:(3) -≻ (4)&gt;:
Source:
A row module over Q of rank 2

Matrix:
[ [  1,  0 ],
  [  0,  1 ] ]

Range:
A row module over Q of rank 2

A morphism in Rows( Q )

Image of &lt;1*y:(4) -≻ (4)&gt;:
Source:
A row module over Q of rank 2

Matrix:
[ [  0,  1 ],
  [  0,  0 ] ]

Range:
A row module over Q of rank 2

A morphism in Rows( Q )

An object in PreSheaves( Q-algebroid( {1,2,3,4}[x:1-≻1,a:1-≻2,b:2-≻4,c:1-≻3,d:3-≻4,
y:4-≻4] ) defined by 4 objects and 6 generating morphisms, Rows( Q ) ) given by
the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( MonomorphismIntoSomeInjectiveObject( P ) );</span>
true
</pre></div>

<p><a id="X80048E1182551690" name="X80048E1182551690"></a></p>

<h5>2.2-7 NerveTruncatedInDegree2</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NerveTruncatedInDegree2</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a presheaf</p>

<p>The input is a category <var class="Arg">B</var> with finitely many objects equipped with a homomorphism structure with values in a finite complete and finite cocomplete category <var class="Arg">H</var>. The output is the nerve of <var class="Arg">B</var> truncated in degree <span class="SimpleMath">\(2\)</span>, as an object in the category of presheaves on <code class="code">SimplicialCategoryTruncatedInDegree</code>(<span class="SimpleMath">\(2\)</span>) with values in <var class="Arg">H</var>.</p>

<p>We compute the nerve of the full subcategory of the simplicial category <span class="SimpleMath">\(\Delta\)</span> on the objects <span class="SimpleMath">\([0], [1], [2]\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta2 := SimplicialCategoryTruncatedInDegree( 2 );</span>
PathCategory( FinQuiver(
  "Delta(C0,C1,C2)[id:C1-≻C0,s:C0-≻C1,t:C0-≻C1,
                   is:C2-≻C1,it:C2-≻C1,
                   ps:C1-≻C2,pt:C1-≻C2,mu:C1-≻C2]" ) )
/ [ s⋅id = id(C0), t⋅id = id(C0), ps⋅is = id(C1), ... ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DefiningRelations( Delta2 );</span>
[ [ s⋅id:(C0) -≻ (C0), id(C0):(C0) -≻ (C0) ],
  [ t⋅id:(C0) -≻ (C0), id(C0):(C0) -≻ (C0) ],
  [ ps⋅is:(C1) -≻ (C1), id(C1):(C1) -≻ (C1) ],
  [ pt⋅it:(C1) -≻ (C1), id(C1):(C1) -≻ (C1) ],
  [ is⋅id:(C2) -≻ (C0), it⋅id:(C2) -≻ (C0) ],
  [ pt⋅is:(C1) -≻ (C1), id⋅t:(C1) -≻ (C1) ],
  [ ps⋅it:(C1) -≻ (C1), id⋅s:(C1) -≻ (C1) ],
  [ s⋅pt:(C0) -≻ (C2), t⋅ps:(C0) -≻ (C2) ],
  [ s⋅mu:(C0) -≻ (C2), s⋅ps:(C0) -≻ (C2) ],
  [ t⋅mu:(C0) -≻ (C2), t⋅pt:(C0) -≻ (C2) ],
  [ mu⋅is:(C1) -≻ (C1), id(C1):(C1) -≻ (C1) ],
  [ mu⋅it:(C1) -≻ (C1), id(C1):(C1) -≻ (C1) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( Delta2 );</span>
31
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := NerveTruncatedInDegree2( Delta2 );</span>
&lt;An object in PreSheaves( PathCategory( FinQuiver(
  "Delta(C0,C1,C2)[id:C1-≻C0,s:C0-≻C1,t:C0-≻C1,
                   is:C2-≻C1,it:C2-≻C1,
                   ps:C1-≻C2,pt:C1-≻C2,mu:C1-≻C2]" ) )
/ [ s⋅id = id(C0), t⋅id = id(C0), ps⋅is = id(C1), ... ],
 SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( N );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C0;</span>
|3|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C0 );</span>
{ 0, 1, 2 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C1;</span>
|31|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C1 );</span>
{ 0,..., 30 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C2;</span>
|393|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C2 );</span>
{ 0,..., 392 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.id;</span>
|3| → |31|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.id );</span>
{ 0, 1, 2 } ⱶ[ 0, 5, 21 ]→ { 0,..., 30 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IntCat := CategoryOfInternalCategories(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  RangeCategoryOfHomomorphismStructure( Delta2 ) );</span>
FullSubcategoryByObjectMembershipFunction(
PreSheaves( PathCategory( FinQuiver(
  "Delta(C0,C1,C2)[id:C1-≻C0,s:C0-≻C1,t:C0-≻C1,
                   is:C2-≻C1,it:C2-≻C1,
                   ps:C1-≻C2,pt:C1-≻C2,mu:C1-≻C2]" ) )
/ [ s⋅id = id(C0), t⋅id = id(C0), ps⋅is = id(C1), ... ],
SkeletalFinSets ), ObjectMembershipFunction )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( N / IntCat );</span>
true
</pre></div>

<p>We compute the nerve of the full subcategory of the simplicial category <span class="SimpleMath">\(\Delta\)</span> on the objects <span class="SimpleMath">\([0], [1], [2]\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta2 := CategoryFromNerveData( SimplicialCategoryTruncatedInDegree( 2 ) );</span>
PathCategory( FinQuiver(
  "Delta(C0,C1,C2)[id:C1-≻C0,s:C0-≻C1,t:C0-≻C1,
                   is:C2-≻C1,it:C2-≻C1,
                   ps:C1-≻C2,pt:C1-≻C2,mu:C1-≻C2]" ) )
/ [ s⋅id = id(C0), t⋅id = id(C0), ps⋅is = id(C1), ... ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := NerveTruncatedInDegree2( Delta2 );</span>
&lt;An object in PreSheaves( PathCategory( FinQuiver(
  "Delta(C0,C1,C2)[id:C1-≻C0,s:C0-≻C1,t:C0-≻C1,
                   is:C2-≻C1,it:C2-≻C1,
                   ps:C1-≻C2,pt:C1-≻C2,mu:C1-≻C2]" ) )
/ [ s⋅id = id(C0), t⋅id = id(C0), ps⋅is = id(C1), ... ],
 SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( N );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C0;</span>
|3|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C0 );</span>
{ 0, 1, 2 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C1;</span>
|31|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C1 );</span>
{ 0,..., 30 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C2;</span>
|393|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C2 );</span>
{ 0,..., 392 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.id;</span>
|3| → |31|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.id );</span>
{ 0, 1, 2 } ⱶ[ 0, 5, 21 ]→ { 0,..., 30 }
</pre></div>

<p>We compute the nerve of the full subcategory of the simplicial category <span class="SimpleMath">\(\Delta\)</span> on the objects <span class="SimpleMath">\([0], [1]\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta1 := UnderlyingCategory( FinReflexiveQuivers );</span>
PathCategory( FinQuiver( "Delta(C0,C1)[id:C1-≻C0,s:C0-≻C1,t:C0-≻C1]" ) )
/ [ s⋅id = id(C0), t⋅id = id(C0) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := NerveTruncatedInDegree2( Delta1 );</span>
&lt;An object in PreSheaves( PathCategory( FinQuiver(
  "Delta(C0,C1,C2)[id:C1-≻C0,s:C0-≻C1,t:C0-≻C1,
                   is:C2-≻C1,it:C2-≻C1,
                   ps:C1-≻C2,pt:C1-≻C2,mu:C1-≻C2]" ) )
/ [ s⋅id = id(C0), t⋅id = id(C0), ps⋅is = id(C1), ... ],
 SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( N );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C0;</span>
|2|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C0 );</span>
{ 0, 1 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C1;</span>
|7|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C1 );</span>
{ 0,..., 6 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.C2;</span>
|26|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.C2 );</span>
{ 0,..., 25 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.id;</span>
|2| → |7|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.id );</span>
{ 0, 1 } ⱶ[ 0, 4 ]→ { 0,..., 6 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.is );</span>
{ 0,..., 6 } ⱶ[ 0, 1, 11, 12, 17, 18, 19 ]→ { 0,..., 25 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N.it );</span>
{ 0,..., 6 } ⱶ[ 0, 4, 7, 8, 17, 20, 23 ]→ { 0,..., 25 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta2 := Source( N );</span>
PathCategory( FinQuiver(
  "Delta(C0,C1,C2)[id:C1-≻C0,s:C0-≻C1,t:C0-≻C1,
                   is:C2-≻C1,it:C2-≻C1,
                   ps:C1-≻C2,pt:C1-≻C2,mu:C1-≻C2]" ) )
/ [ s⋅id = id(C0), t⋅id = id(C0), ps⋅is = id(C1), ... ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N( Delta2.it ) = N.it;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := [ Delta2.it, Delta2.id, Delta2.t ];</span>
[ (C2)-[(it)]-&gt;(C1), (C1)-[(id)]-&gt;(C0), (C0)-[(t)]-&gt;(C1) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor := PreComposeList( L );</span>
(C2)-[(it*pt*is)]-&gt;(C1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionOfMorphismInCategory( mor );</span>
[ (C2)-[(it)]-&gt;(C1), (C1)-[(pt)]-&gt;(C2), (C2)-[(is)]-&gt;(C1) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NL := N( mor );</span>
|7| → |26|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( NL );</span>
{ 0,..., 6 } ⱶ[ 0, 0, 17, 17, 17, 17, 17 ]→ { 0,..., 25 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LN := PostComposeList( List( L, N ) );</span>
|7| → |26|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( LN );</span>
{ 0,..., 6 } ⱶ[ 0, 0, 17, 17, 17, 17, 17 ]→ { 0,..., 25 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NL = LN;</span>
true
</pre></div>

<p><a id="X87B457D77A0B8836" name="X87B457D77A0B8836"></a></p>

<h5>2.2-8 SievesOfPathsToTruth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SievesOfPathsToTruth</code>( <var class="Arg">iota</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a monomorphisms in a Hom-category of functors</p>

<p>The input is a monomorphism <var class="Arg">iota</var>:<span class="SimpleMath">\(Q \to P\)</span> in the category of presheaves with values in <code class="code">RangeCategoryOfHomomorphismStructure</code>(<span class="SimpleMath">\(C\)</span>) on the finitely presented category <span class="SimpleMath">\(C:=\)</span>(<code class="code">Source</code>(<span class="SimpleMath">\(P\)</span>)) with finite <span class="SimpleMath">\(\mathrm{Hom}\)</span>-sets. The output is the morphism from <span class="SimpleMath">\(P\)</span> to the <code class="code">SieveFunctor</code>(<span class="SimpleMath">\(C\)</span>) mapping for each <span class="SimpleMath">\(c \in C\)</span> the element <span class="SimpleMath">\(x \in P(c)\)</span> to its <q>paths to truth</q> <span class="SimpleMath">\(f: a \to c\)</span> translating <span class="SimpleMath">\(x\)</span> into <span class="SimpleMath">\(f(x) \in Q(a) \subseteq P(a)\)</span>.</p>

<p><a id="X8261C63782F8429B" name="X8261C63782F8429B"></a></p>

<h5>2.2-9 FiniteStrictCoproductCompletionOfSourceCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FiniteStrictCoproductCompletionOfSourceCategory</code>( <var class="Arg">PSh</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>Given the presheaf category <var class="Arg">PSh</var>=<code class="code">PreSheaves</code>( <span class="SimpleMath">\(C\)</span>, <span class="SimpleMath">\(V\)</span> ), return the "sub"category <code class="code">EnrichmentSpecificFiniteStrictCoproductCompletion</code>( <span class="SimpleMath">\(C\)</span> ).</p>

<p><a id="X8416902A79A168D5" name="X8416902A79A168D5"></a></p>

<h5>2.2-10 FiniteColimitCompletionWithStrictCoproductsOfSourceCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FiniteColimitCompletionWithStrictCoproductsOfSourceCategory</code>( <var class="Arg">PSh</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>Given the presheaf category <var class="Arg">PSh</var>=<code class="code">PreSheaves</code>( <span class="SimpleMath">\(C\)</span>, <span class="SimpleMath">\(V\)</span> ), return the ambient category <code class="code">CoequalizerCompletion</code>( <code class="code">FiniteStrictCoproductCompletionOfSourceCategory</code>( <var class="Arg">PSh</var> ) ).</p>

<p><a id="X7AF9281086551EFD" name="X7AF9281086551EFD"></a></p>

<h5>2.2-11 CategoryOfColimitQuiversOfSourceCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CategoryOfColimitQuiversOfSourceCategory</code>( <var class="Arg">PSh</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>Given the presheaf category <var class="Arg">PSh</var>=<code class="code">PreSheaves</code>( <span class="SimpleMath">\(C\)</span>, <span class="SimpleMath">\(V\)</span> ) return the ambient category <code class="code">CategoryOfColimitQuivers</code>( <span class="SimpleMath">\(C\)</span> ), provided <span class="SimpleMath">\(C\)</span> is enriched over <code class="code">SkeletalFinSets</code> or over <code class="code">IntervalCategory</code>.</p>

<p><a id="X7DE8E16C7C2D387B" name="X7DE8E16C7C2D387B"></a></p>

<h4>2.3 <span class="Heading">Operations</span></h4>

<p><a id="X7C89E11C7CE7731E" name="X7C89E11C7CE7731E"></a></p>

<h5>2.3-1 ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToObject</code>( <var class="Arg">F</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> object</p>

<p>Apply the presheaf <var class="Arg">F</var> to the object <var class="Arg">obj</var>. The shorthand is <var class="Arg">F</var>(<var class="Arg">obj</var>).</p>

<p><a id="X81634D6E7DCD5F98" name="X81634D6E7DCD5F98"></a></p>

<h5>2.3-2 ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToMorphism</code>( <var class="Arg">F</var>, <var class="Arg">mor</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> morphism</p>

<p>Apply the presheaf <var class="Arg">F</var> to the morphism <var class="Arg">mor</var>. The shorthand is <var class="Arg">F</var>(<var class="Arg">mor</var>).</p>

<p><a id="X838382A379533D06" name="X838382A379533D06"></a></p>

<h5>2.3-3 ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToGeneratingMorphismOrIdentity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToGeneratingMorphismOrIdentity</code>( <var class="Arg">F</var>, <var class="Arg">mor</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> morphism</p>

<p>Apply the presheaf <var class="Arg">F</var> to the morphism <var class="Arg">mor</var> which is either a generating morphism or an identity morphism.</p>

<p><a id="X818BD23678113F05" name="X818BD23678113F05"></a></p>

<h5>2.3-4 ApplyMorphismInPreSheafCategoryOfFpEnrichedCategoryToObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyMorphismInPreSheafCategoryOfFpEnrichedCategoryToObject</code>( <var class="Arg">eta</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> morphism</p>

<p>Apply the presheaf morphism <var class="Arg">eta</var> to the object <var class="Arg">obj</var>. The shorthand is <var class="Arg">eta</var>(<var class="Arg">o</var>).</p>

<p><a id="X7D03633A7D98026B" name="X7D03633A7D98026B"></a></p>

<h4>2.4 <span class="Heading"><strong class="pkg">GAP</strong> Categories</span></h4>

<p><a id="X7D6A79907FA8C87F" name="X7D6A79907FA8C87F"></a></p>

<h5>2.4-1 IsPreSheafCategoryOfFpEnrichedCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPreSheafCategoryOfFpEnrichedCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of a presheaf category of a finitely presented enriched category.</p>

<p><a id="X7A0304637E934E63" name="X7A0304637E934E63"></a></p>

<h5>2.4-2 IsCellInPreSheafCategoryOfFpEnrichedCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCellInPreSheafCategoryOfFpEnrichedCategory</code>( <var class="Arg">cell</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of cells in a presheaf category of a finitely presented enriched category.</p>

<p><a id="X869C3AEE85A01110" name="X869C3AEE85A01110"></a></p>

<h5>2.4-3 IsObjectInPreSheafCategoryOfFpEnrichedCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsObjectInPreSheafCategoryOfFpEnrichedCategory</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of objects in a presheaf category of a finitely presented enriched category.</p>

<p><a id="X81AF24BF84DADFA5" name="X81AF24BF84DADFA5"></a></p>

<h5>2.4-4 IsMorphismInPreSheafCategoryOfFpEnrichedCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMorphismInPreSheafCategoryOfFpEnrichedCategory</code>( <var class="Arg">mor</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of morphisms in a presheaf category of a finitely presented enriched category.</p>

<p><a id="X7D9044767BEB1523" name="X7D9044767BEB1523"></a></p>

<h4>2.5 <span class="Heading">Global variables</span></h4>

<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>

<h4>2.6 <span class="Heading">Examples</span></h4>

<p><a id="X84E9E37085A85D7B" name="X84E9E37085A85D7B"></a></p>

<h5>2.6-1 <span class="Heading">The subobject classifier</span></h5>

<p>The subobject classifier of the <code class="code">PreSheaves</code><span class="SimpleMath">\((C, H)\)</span>, where <span class="SimpleMath">\(H\)</span>:=<code class="code">RangeCategoryOfHomomorphismStructure</code>(<span class="SimpleMath">\(C\)</span>) is the functor of sieves, mapping each object <span class="SimpleMath">\(c \in C^\mathrm{op}\)</span> to the set of subobjects of the representable functor <span class="SimpleMath">\(\mathrm{Hom}_C(-,c)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[a:1-&gt;1]" );</span>
q(1)[a:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fq := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M0 := Fq / [ [ Fq.a^3, Fq.1 ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PShM0 := PreSheaves( M0 );</span>
PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = 1 ], SkeletalFinSets )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Omega0 := SubobjectClassifier( PShM0 );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = 1 ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Omega0 );</span>
Image of &lt;(1)&gt;:
{ 0, 1 }

Image of (1)-[(a)]-&gt;(1):
{ 0, 1 } ⱶ[ 0, 1 ]→ { 0, 1 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = 1 ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( Omega0 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReflexive( Omega0 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := Exponential( Omega0, Omega0 );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = 1 ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( e );</span>
Image of &lt;(1)&gt;:
{ 0,..., 3 }

Image of (1)-[(a)]-&gt;(1):
{ 0,..., 3 } ⱶ[ 0, 1, 2, 3 ]→ { 0,..., 3 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = 1 ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ev0 := CartesianLeftEvaluationMorphism( Omega0, Omega0 );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = 1 ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ev0 );</span>
Image of &lt;(1)&gt;:
{ 0,..., 7 } ⱶ[ 0, 1, 0, 1, 0, 0, 1, 1 ]→ { 0, 1 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = 1 ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M1 := Fq / [ [ Fq.a^3, Fq.a ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PShM1 := PreSheaves( M1 );</span>
PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a ], SkeletalFinSets )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Omega1 := SubobjectClassifier( PShM1 );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = a ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Omega1 );</span>
Image of &lt;(1)&gt;:
{ 0, 1, 2 }

Image of (1)-[(a)]-&gt;(1):
{ 0, 1, 2 } ⱶ[ 0, 2, 2 ]→ { 0, 1, 2 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( Omega1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReflexive( Omega1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M2 := Fq / [ [ Fq.a^3, Fq.a^2 ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PShM2 := PreSheaves( M2 );</span>
PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Omega2 := SubobjectClassifier( PShM2 );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = a*a ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Omega2 );</span>
Image of &lt;(1)&gt;:
{ 0,..., 3 }

Image of (1)-[(a)]-&gt;(1):
{ 0,..., 3 } ⱶ[ 0, 2, 3, 3 ]→ { 0,..., 3 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( Omega2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReflexive( Omega2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">true2 := TruthMorphismOfTrue( PShM2 );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = a*a ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( true2 );</span>
Image of &lt;(1)&gt;:
{ 0 } ⱶ[ 3 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">false2 := TruthMorphismOfFalse( PShM2 );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = a*a ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( false2 );</span>
Image of &lt;(1)&gt;:
{ 0 } ⱶ[ 0 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota := CreatePreSheafMorphism( EmbeddingOfSieveFunctor( M2 ) );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = a*a ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( iota );</span>
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 0, 4, 6, 7 ]→ { 0,..., 7 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Target( iota );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
 / [ a*a*a = a*a ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Target( iota ) );</span>
Image of &lt;(1)&gt;:
{ 0,..., 7 }

Image of (1)-[(a)]-&gt;(1):
{ 0,..., 7 } ⱶ[ 0, 0, 1, 1, 6, 6, 7, 7 ]→ { 0,..., 7 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2 := SubobjectOfClassifyingMorphism( true2 );</span>
&lt;A monomorphism in PreSheaves( FreeCategory(
 RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t2 );</span>
Image of &lt;(1)&gt;:
{ 0 } ⱶ[ 0 ]→ { 0 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2 := SubobjectOfClassifyingMorphism( false2 );</span>
&lt;A monomorphism in PreSheaves( FreeCategory(
 RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( f2 );</span>
Image of &lt;(1)&gt;:
∅ ⱶ[  ]→ { 0 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := HomStructure( Omega2, Omega2 );</span>
|8|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( H );</span>
{ 0,..., 7 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T2 := DistinguishedObjectOfHomomorphismStructure( PShM2 );</span>
|1|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := List( H, i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               Omega2, Omega2, MapOfFinSets( T2, [ i ], H ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( L );</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( L, Display );</span>
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 0, 0, 0, 0 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets ) given by the above data
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 3, 0, 0, 0 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets ) given by the above data
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 0, 1, 2, 3 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets ) given by the above data
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 3, 1, 2, 3 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets ) given by the above data
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 0, 2, 3, 3 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets ) given by the above data
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 3, 2, 3, 3 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets ) given by the above data
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 0, 3, 3, 3 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets ) given by the above data
Image of &lt;(1)&gt;:
{ 0,..., 3 } ⱶ[ 3, 3, 3, 3 ]→ { 0,..., 3 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
/ [ a*a*a = a*a ], SkeletalFinSets )
given by the above data
</pre></div>

<p><a id="X7D24566D80D64552" name="X7D24566D80D64552"></a></p>

<h5>2.6-2 <span class="Heading">PreSheaves of non-f.p. categories (experimental)</span></h5>

<p><a id="X811C52E07B3BE2A4" name="X811C52E07B3BE2A4"></a></p>

<h5>2.6-3 <span class="Heading">The colimit completion of a cyclic monoid</span></h5>

<p>Stream-vortex-system: Study the colimit completion of a cyclic monoid</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(o)[x:o-&gt;o]" );</span>
q(o)[x:o-&gt;o]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := F / [ [ F.x^(3+4), F.x^3 ] ];</span>
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CategoryFromDataTables( C );</span>
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := C.x;</span>
(o)-[(x)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( C );</span>
PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fo := FinSet( 8 );</span>
|8|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Fo );</span>
{ 0,..., 7 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fx := [ 5, 0, 3, 1, 1, 4, 3, 2 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fx := MapOfFinSets( Fo, Fx, Fo );</span>
|8| → |8|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G :=  CreatePreSheafByValues( PSh, Pair( [ Fo ], [ Fx ] ) );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( G );</span>
Image of &lt;(o)&gt;:
{ 0,..., 7 }

Image of (o)-[(x)]-&gt;(o):
{ 0,..., 7 } ⱶ[ 5, 0, 3, 1, 1, 4, 3, 2 ]→ { 0,..., 7 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismFromSomeProjectiveObject( G );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">im := ImageObject( pi );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( im );</span>
Image of &lt;(o)&gt;:
{ 0,..., 7 }

Image of (o)-[(x)]-&gt;(o):
{ 0,..., 7 } ⱶ[ 5, 0, 3, 1, 1, 4, 3, 2 ]→ { 0,..., 7 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">im = G;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coim := CoimageObject( pi );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( coim );</span>
Image of &lt;(o)&gt;:
{ 0,..., 7 }

Image of (o)-[(x)]-&gt;(o):
{ 0,..., 7 } ⱶ[ 1, 2, 3, 4, 5, 6, 3, 2 ]→ { 0,..., 7 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coim = im;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := MorphismFromCoimageToImage( pi );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( iso );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( iso );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( iso );</span>
Image of &lt;(o)&gt;:
{ 0,..., 7 } ⱶ[ 7, 2, 3, 1, 0, 5, 4, 6 ]→ { 0,..., 7 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv := InverseOfMorphismFromCoimageToImage( pi );</span>
&lt;An isomorphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( inv );</span>
Image of &lt;(o)&gt;:
{ 0,..., 7 } ⱶ[ 4, 3, 1, 2, 6, 5, 7, 0 ]→ { 0,..., 7 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( PreCompose( iso, inv ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( PreCompose( inv, iso ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coYoG := CoYonedaLemmaOnObjects( G );</span>
&lt;An object in FiniteColimitCompletionWithStrictCoproducts(
 FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sec := SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject( G );</span>
&lt;A split monomorphism in FiniteStrictCoproductCompletion(
 FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( sec );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( sec );</span>
{ 0, 1 } ⱶ[ 7, 6 ]→ { 0,..., 7 }

[ (o)-[(o)]-&gt;(o), (o)-[(o)]-&gt;(o) ]

A morphism in FiniteStrictCoproductCompletion(
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ] ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismFromSomeProjectiveObject( G );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ast := AstrictionToCoimage( pi );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( ast );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ast );</span>
Image of &lt;(o)&gt;:
{ 0,..., 7 } ⱶ[ 7, 2, 3, 1, 0, 5, 4, 6 ]→ { 0,..., 7 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ], SkeletalFinSets ) given by the above data
</pre></div>

<p>Stream-vortex-system: Study the colimit completion of a cyclic monoid</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(o)[x:o-&gt;o]" );</span>
q(o)[x:o-&gt;o]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := F / [ [ F.x^(4+12), F.x^4 ] ];</span>
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := C.x;</span>
(o)-[(x)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( C );</span>
PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fo := FinSet( 18 );</span>
|18|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Fo );</span>
{ 0,..., 17 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fx := [ 5, 0, 1, 2, 3, 4, 0, 2, 5, 6, 6, 7, 7, 8, 8, 9, 9, 16 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fx := MapOfFinSets( Fo, Fx, Fo );</span>
|18| → |18|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G :=  CreatePreSheafByValues( PSh, Pair( [ Fo ], [ Fx ] ) );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( G );</span>
Image of &lt;(o)&gt;:
{ 0,..., 17 }

Image of (o)-[(x)]-&gt;(o):
{ 0,..., 17 } ⱶ[ 5, 0, 1, 2, 3, 4, 0, 2, 5,
                 6, 6, 7, 7, 8, 8, 9, 9, 16 ]→ { 0,..., 17 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismFromSomeProjectiveObject( G );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">im := ImageObject( pi );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">im = G;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coim := CoimageObject( pi );</span>
&lt;An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( coim );</span>
Image of &lt;(o)&gt;:
{ 0,..., 17 }

Image of (o)-[(x)]-&gt;(o):
{ 0,..., 17 } ⱶ[ 1, 2, 3, 4, 5, 6, 7, 8, 9,
                 4, 2, 3, 13, 8, 13, 16, 5, 16 ]→ { 0,..., 17 }

An object in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coim = im;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := MorphismFromCoimageToImage( pi );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( iso );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( iso );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( iso );</span>
Image of &lt;(o)&gt;:
{ 0,..., 17 } ⱶ[ 17, 16, 9, 6, 0, 5, 4, 3, 2,
                 1, 15, 10, 11, 7, 12, 13, 8, 14 ]→ { 0,..., 17 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv := InverseOfMorphismFromCoimageToImage( pi );</span>
&lt;An isomorphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( inv );</span>
Image of &lt;(o)&gt;:
{ 0,..., 17 } ⱶ[ 4, 9, 8, 7, 6, 5, 3, 13, 16,
                 2, 11, 12, 14, 15, 17, 10, 1, 0 ]→ { 0,..., 17 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( PreCompose( iso, inv ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( PreCompose( inv, iso ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coYoG := CoYonedaLemmaOnObjects( G );</span>
&lt;An object in FiniteColimitCompletionWithStrictCoproducts(
 FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sec := SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject( G );</span>
&lt;A split monomorphism in FiniteStrictCoproductCompletion(
 FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( sec );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( sec );</span>
{ 0,..., 6 } ⱶ[ 17, 15, 10, 11, 12, 13, 14 ]→ { 0,..., 17 }

[ (o)-[(o)]-&gt;(o), (o)-[(o)]-&gt;(o), (o)-[(o)]-&gt;(o), (o)-[(o)]-&gt;(o),
  (o)-[(o)]-&gt;(o), (o)-[(o)]-&gt;(o), (o)-[(o)]-&gt;(o) ]

A morphism in FiniteStrictCoproductCompletion(
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ] ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismFromSomeProjectiveObject( G );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ast := AstrictionToCoimage( pi );</span>
&lt;A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
 / [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( ast );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ast );</span>
Image of &lt;(o)&gt;:
{ 0,..., 17 } ⱶ[ 17, 16, 9, 6, 0, 5, 4, 3, 2,
                 1, 15, 10, 11, 7, 12, 13, 8, 14 ]→ { 0,..., 17 }

A morphism in PreSheaves( FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x = x*x*x*x ], SkeletalFinSets )
given by the above data
</pre></div>

<p><a id="X7EF1F1847C6C6973" name="X7EF1F1847C6C6973"></a></p>

<h5>2.6-4 <span class="Heading">The linearization of the colimit completion of a cyclic monoid</span></h5>

<p>Stream-vortex-system: Study the linearization of the colimit completion of a cyclic monoid</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(o)[x:o-&gt;o]" );</span>
q(o)[x:o-&gt;o]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := F / [ [ F.x^(3+4), F.x^3 ] ];</span>
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
/ [ x*x*x*x*x*x*x = x*x*x ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC := Q[C];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC := AlgebroidFromDataTables( QC );</span>
Q-algebroid( {o}[x:o-≻o] ) defined by 1 object and 1 generating morphism
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := QC.x;</span>
&lt;1*x:(o) -≻ (o)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( QC );</span>
PreSheaves( Q-algebroid( {o}[x:o-≻o] )
defined by 1 object and 1 generating morphism, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Target( PSh );</span>
Rows( Q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fo := 8 / H;</span>
&lt;A row module over Q of rank 8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fx := [ 5, 0, 3, 1, 1, 4, 3, 2 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fx := IdentityMat( 8 ){1 + Fx};;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fx := HomalgMatrix( Fx, 8, 8, Q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fx := MorphismConstructor( Fo, Fx, Fo );</span>
&lt;A morphism in Rows( Q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Fx );</span>
Source:
A row module over Q of rank 8

Matrix:
[ [  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  1,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  1,  0,  0,  0,  0,  0,  0 ],
  [  0,  1,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 8

A morphism in Rows( Q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G :=  CreatePreSheafByValues( PSh, Pair( [ Fo ], [ Fx ] ) );</span>
&lt;(o)-&gt;8; (x)-&gt;8x8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cy := ProjectionOntoCoequalizer( CoYonedaLemmaCoequalizerPair( G )[2] );</span>
&lt;(o)-&gt;56x8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismFromSomeProjectiveObject( G );</span>
&lt;(o)-&gt;14x8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoimageObject( cy ) = CoimageObject( pi );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CoimageObject( cy ) );</span>
Image of &lt;(o)&gt;:
A row module over Q of rank 8

Image of &lt;1*x:(o) -≻ (o)&gt;:
Source:
A row module over Q of rank 8

Matrix:
[ [  0,  1,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  1,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0 ] ]

Range:
A row module over Q of rank 8

A morphism in Rows( Q )

An object in PreSheaves( Q-algebroid( {o}[x:o-≻o] )
defined by 1 object and 1 generating morphism, Rows( Q ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CoimageObject( pi ) );</span>
Image of &lt;(o)&gt;:
A row module over Q of rank 8

Image of &lt;1*x:(o) -≻ (o)&gt;:
Source:
A row module over Q of rank 8

Matrix:
[ [  0,  1,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 8

A morphism in Rows( Q )

An object in PreSheaves( Q-algebroid( {o}[x:o-≻o] )
defined by 1 object and 1 generating morphism, Rows( Q ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EpimorphismFromSomeProjectiveObjectUsingSplits( G );</span>
&lt;(o)-&gt;14x8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nf := CoimageObject( ps );</span>
&lt;(o)-&gt;8; (x)-&gt;8x8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nf = CoimageObject( cy );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( nf );</span>
Image of &lt;(o)&gt;:
A row module over Q of rank 8

Image of &lt;1*x:(o) -≻ (o)&gt;:
Source:
A row module over Q of rank 8

Matrix:
[ [  0,  1,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  0 ] ]

Range:
A row module over Q of rank 8

A morphism in Rows( Q )

An object in PreSheaves( Q-algebroid( {o}[x:o-≻o] )
defined by 1 object and 1 generating morphism, Rows( Q ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">section := SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject( G );</span>
&lt;A morphism in AdditiveClosure( Q-algebroid( {o}[x:o-≻o] )
 defined by 1 object and 1 generating morphism )
 defined by a 2 x 8 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( section );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( section );</span>
A 2 x 8 matrix with entries in Q-algebroid( {o}[x:o-≻o] )
defined by 1 object and 1 generating morphism

[1,1]: &lt;0:(o) -≻ (o)&gt;
[1,2]: &lt;0:(o) -≻ (o)&gt;
[1,3]: &lt;0:(o) -≻ (o)&gt;
[1,4]: &lt;0:(o) -≻ (o)&gt;
[1,5]: &lt;0:(o) -≻ (o)&gt;
[1,6]: &lt;0:(o) -≻ (o)&gt;
[1,7]: &lt;0:(o) -≻ (o)&gt;
[1,8]: &lt;1*id(o):(o) -≻ (o)&gt;
[2,1]: &lt;0:(o) -≻ (o)&gt;
[2,2]: &lt;0:(o) -≻ (o)&gt;
[2,3]: &lt;0:(o) -≻ (o)&gt;
[2,4]: &lt;0:(o) -≻ (o)&gt;
[2,5]: &lt;0:(o) -≻ (o)&gt;
[2,6]: &lt;0:(o) -≻ (o)&gt;
[2,7]: &lt;1*id(o):(o) -≻ (o)&gt;
[2,8]: &lt;0:(o) -≻ (o)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Emb := EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheaves( PSh );</span>
The embedding functor of the finite coproduct completion into f.p. presheaves
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ip := PreCompose( Emb( section ), cy );</span>
&lt;(o)-&gt;14x8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualAsFactorobjects( pi, ip );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi = ip;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoimageObject( ip ) = CoimageObject( pi );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">retraction := RetractionFromCoYonedaProjectiveObjectOntoOptimizedCoYonedaProjectiveObject( G );</span>
&lt;A morphism in AdditiveClosure( Q-algebroid( {o}[x:o-≻o] )
 defined by 1 object and 1 generating morphism )
 defined by a 8 x 2 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( retraction );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( retraction );</span>
A 8 x 2 matrix with entries in Q-algebroid( {o}[x:o-≻o] )
defined by 1 object and 1 generating morphism

[1,1]: &lt;0:(o) -≻ (o)&gt;
[1,2]: &lt;1*x^3:(o) -≻ (o)&gt;
[2,1]: &lt;0:(o) -≻ (o)&gt;
[2,2]: &lt;1*x^2:(o) -≻ (o)&gt;
[3,1]: &lt;1*x:(o) -≻ (o)&gt;
[3,2]: &lt;0:(o) -≻ (o)&gt;
[4,1]: &lt;0:(o) -≻ (o)&gt;
[4,2]: &lt;1*x:(o) -≻ (o)&gt;
[5,1]: &lt;0:(o) -≻ (o)&gt;
[5,2]: &lt;1*x^5:(o) -≻ (o)&gt;
[6,1]: &lt;0:(o) -≻ (o)&gt;
[6,2]: &lt;1*x^4:(o) -≻ (o)&gt;
[7,1]: &lt;0:(o) -≻ (o)&gt;
[7,2]: &lt;1*id(o):(o) -≻ (o)&gt;
[8,1]: &lt;1*id(o):(o) -≻ (o)&gt;
[8,2]: &lt;0:(o) -≻ (o)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( PreCompose( section, retraction ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co := ProjectionOntoCoequalizer( OptimizedCoYonedaLemmaCoequalizerPair( G )[2] );</span>
&lt;(o)-&gt;14x8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualAsFactorobjects( pi, co );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi = co;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoimageObject( pi ) = CoimageObject( co );</span>
true
</pre></div>

<p><a id="X813922347AE64B28" name="X813922347AE64B28"></a></p>

<h5>2.6-5 <span class="Heading">The Weierstrass normal form</span></h5>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", "&gt;= 2023.10-06", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Q["x"];</span>
Q[x]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Indeterminates( R )[1];</span>
x
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := x^2-x-1;</span>
x^2-x-1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := Degree( p );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cmat3 := HomalgMatrix( CompanionMat( p^3 ), 3 * d, 3 * d, Q );</span>
&lt;A 6 x 6 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cmat2 := HomalgMatrix( CompanionMat( p^2 ), 2 * d, 2 * d, Q );</span>
&lt;A 4 x 4 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cmat1 := HomalgMatrix( CompanionMat( p^1 ), 1 * d, 1 * d, Q );</span>
&lt;A 2 x 2 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( cmat3 );</span>
[ [   0,   0,   0,   0,   0,   1 ],
  [   1,   0,   0,   0,   0,   3 ],
  [   0,   1,   0,   0,   0,   0 ],
  [   0,   0,   1,   0,   0,  -5 ],
  [   0,   0,   0,   1,   0,   0 ],
  [   0,   0,   0,   0,   1,   3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cmat := Q * DiagMat( [ cmat1, cmat1, cmat3 ] );</span>
&lt;An unevaluated 10 x 10 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := NrRows( cmat );</span>
10
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv := HomalgMatrix( RandomUnimodularMat( n ), n, n, Q );</span>
&lt;A 10 x 10 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := LeftInverse( inv ) * cmat * inv;</span>
&lt;An unevaluated 10 x 10 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ [     0,     0,     3,     0,    -1,     3,    -8,     6,     0,    -3 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [    39,    15,   -25,     2,     0,    -9,    10,   -15,     2,     1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [    21,     5,    -5,     3,    -1,     2,   -16,     5,     0,    -7 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [    30,    10,    -4,     3,    -5,    10,   -44,    22,    -2,   -18 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [    40,     0,   -66,     9,    27,   -70,   170,  -140,     9,    62 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [  -204,     0,    82,   -57,   -36,    50,    29,   100,     5,    13 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [   -52,   -15,    18,    -6,     2,    -1,    30,    -5,     0,    14 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [   105,     0,   -51,    29,    22,   -36,    14,   -72,    -1,     4 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [     6,     1,   -11,     1,     3,    -9,    19,   -18,     0,     7 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [   152,    45,   -52,    17,    -7,     5,   -93,    19,     0,   -43 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := HomalgMatrix( mat, 10, 10 , Q );</span>
&lt;A 10 x 10 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(o)[x:o-&gt;o]" );</span>
q(o)[x:o-&gt;o]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QF := Q[F];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := QF / [ QF.xxxxxx - 3 * QF.xxxxx + 5 * QF.xxx - 3 * QF.x - IdentityMorphism( QF.o ) ];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o := A.o;</span>
&lt;(o)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := A.x;</span>
(o)-[{ 1*(x) }]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( A.x );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( A.x );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( A.x );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qmat := RangeCategoryOfHomomorphismStructure( A );</span>
Rows( Q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := n / Qmat;</span>
&lt;A row module over Q of rank 10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := mat / Qmat;</span>
&lt;A morphism in Rows( Q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( A );</span>
PreSheaves( Algebra( Q, FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) ) )
/ relations, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := CreatePreSheafByValues( PSh, Pair( [ U ], [ phi ] ) );</span>
&lt;(o)-&gt;10; (x)-&gt;10x10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( G );</span>
Image of &lt;(o)&gt;:
A row module over Q of rank 10

Image of (o)-[{ 1*(x) }]-&gt;(o):
Source:
A row module over Q of rank 10

Matrix:
[ [     0,     0,     3,     0,    -1,     3,    -8,     6,     0,    -3 ],
  [    39,    15,   -25,     2,     0,    -9,    10,   -15,     2,     1 ],
  [    21,     5,    -5,     3,    -1,     2,   -16,     5,     0,    -7 ],
  [    30,    10,    -4,     3,    -5,    10,   -44,    22,    -2,   -18 ],
  [    40,     0,   -66,     9,    27,   -70,   170,  -140,     9,    62 ],
  [  -204,     0,    82,   -57,   -36,    50,    29,   100,     5,    13 ],
  [   -52,   -15,    18,    -6,     2,    -1,    30,    -5,     0,    14 ],
  [   105,     0,   -51,    29,    22,   -36,    14,   -72,    -1,     4 ],
  [     6,     1,   -11,     1,     3,    -9,    19,   -18,     0,     7 ],
  [   152,    45,   -52,    17,    -7,     5,   -93,    19,     0,   -43 ] ]

Range:
A row module over Q of rank 10

A morphism in Rows( Q )

An object in PreSheaves(
Algebra( Q, FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) ) ) / relations,
Rows( Q ) ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cy := ProjectionOntoCoequalizer( CoYonedaLemmaCoequalizerPair( G )[2] );</span>
&lt;(o)-&gt;60x10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismFromSomeProjectiveObject( G );</span>
&lt;(o)-&gt;18x10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pmat := UnderlyingMatrix( CoimageObject( pi ).x );</span>
&lt;An unevaluated 10 x 10 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">range3 := [ 1 .. 3 * d ];</span>
[ 1 .. 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pmat3 := CertainColumns( CertainRows( pmat, range3 ), range3 );</span>
&lt;An unevaluated 6 x 6 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( pmat3 );</span>
[ [   0,   1,   0,   0,   0,   0 ],
  [   0,   0,   1,   0,   0,   0 ],
  [   0,   0,   0,   1,   0,   0 ],
  [   0,   0,   0,   0,   1,   0 ],
  [   0,   0,   0,   0,   0,   1 ],
  [   1,   3,   0,  -5,   0,   3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pmat3 = TransposedMatrix( cmat3 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">range1 := [ 1 .. 1 * d ];</span>
[ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pmat1_1 := CertainColumns( CertainRows( pmat, 3 * d + range1 ), 3 * d + range1 );</span>
&lt;An unevaluated 2 x 2 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( pmat1_1 );</span>
[ [  0,  1 ],
  [  1,  1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pmat1_1 = TransposedMatrix( cmat1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pmat1_2 := CertainColumns( CertainRows( pmat, 4 * d + range1 ), 4 * d + range1 );</span>
&lt;An unevaluated 2 x 2 matrix over an internal ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( pmat1_2 );</span>
[ [  0,  1 ],
  [  1,  1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pmat1_2 = TransposedMatrix( cmat1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoimageObject( cy ) = CoimageObject( pi );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EpimorphismFromSomeProjectiveObjectUsingSplits( G );</span>
&lt;(o)-&gt;18x10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nf := CoimageObject( ps );</span>
&lt;(o)-&gt;10; (x)-&gt;10x10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nf = CoimageObject( cy );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( nf );</span>
Image of &lt;(o)&gt;:
A row module over Q of rank 10

Image of (o)-[{ 1*(x) }]-&gt;(o):
Source:
A row module over Q of rank 10

Matrix:
[ [   0,   1,   0,   0,   0,   0,   0,   0,   0,   0 ],
  [   0,   0,   1,   0,   0,   0,   0,   0,   0,   0 ],
  [   0,   0,   0,   1,   0,   0,   0,   0,   0,   0 ],
  [   0,   0,   0,   0,   1,   0,   0,   0,   0,   0 ],
  [   0,   0,   0,   0,   0,   1,   0,   0,   0,   0 ],
  [   1,   3,   0,  -5,   0,   3,   0,   0,   0,   0 ],
  [   0,   0,   0,   0,   0,   0,   0,   1,   0,   0 ],
  [   0,   0,   0,   0,   0,   0,   1,   1,   0,   0 ],
  [   0,   0,   0,   0,   0,   0,   0,   0,   0,   1 ],
  [   0,   0,   0,   0,   0,   0,   0,   0,   1,   1 ] ]

Range:
A row module over Q of rank 10

A morphism in Rows( Q )

An object in PreSheaves(
Algebra( Q, FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) ) ) / relations,
Rows( Q ) ) given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">section := SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject( G );</span>
&lt;A morphism in AdditiveClosure(
 Algebra( Q, FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) ) ) / relations )
 defined by a 3 x 10 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( section );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Emb := EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheaves( PSh );</span>
The embedding functor of the finite coproduct completion into f.p. presheaves
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ip := PreCompose( Emb( section ), cy );</span>
&lt;(o)-&gt;18x10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualAsFactorobjects( pi, ip );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi = ip;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoimageObject( ip ) = CoimageObject( pi );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">retraction := RetractionFromCoYonedaProjectiveObjectOntoOptimizedCoYonedaProjectiveObject( G );</span>
&lt;A morphism in AdditiveClosure(
 Algebra( Q, FreeCategory( RightQuiver( "q(o)[x:o-&gt;o]" ) ) ) / relations )
 defined by a 10 x 3 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( retraction );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( PreCompose( section, retraction ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co := ProjectionOntoCoequalizer( OptimizedCoYonedaLemmaCoequalizerPair( G )[2] );</span>
&lt;(o)-&gt;18x10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualAsFactorobjects( pi, co );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi = co;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoimageObject( pi ) = CoimageObject( co );</span>
true
</pre></div>

<p><a id="X83AF88FC800DB182" name="X83AF88FC800DB182"></a></p>

<h5>2.6-6 <span class="Heading">Optimized co-Yoneda lemma for posets</span></h5>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", "&gt;= 2024.03-13", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := FinQuiver( "q(a,l,r,i,c,b)[ac:a-&gt;c,lc:l-&gt;c,ri:r-&gt;i,ic:i-&gt;c,cb:c-&gt;b]" );</span>
FinQuiver( "q(a,l,r,i,c,b)[ac:a-≻c,lc:l-≻c,ri:r-≻i,ic:i-≻c,cb:c-≻b]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := PathCategory( q );</span>
PathCategory(
FinQuiver( "q(a,l,r,i,c,b)[ac:a-≻c,lc:l-≻c,ri:r-≻i,ic:i-≻c,cb:c-≻b]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( F );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PosetOfCategory( F );</span>
PosetOfCategory( PathCategory(
FinQuiver( "q(a,l,r,i,c,b)[ac:a-≻c,lc:l-≻c,ri:r-≻i,ic:i-≻c,cb:c-≻b]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( P );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( P );</span>
PreSheaves( PosetOfCategory( PathCategory(
FinQuiver( "q(a,l,r,i,c,b)[ac:a-≻c,lc:l-≻c,ri:r-≻i,ic:i-≻c,cb:c-≻b]" ) ) ),
IntervalCategory )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := PSh.c;</span>
&lt;A projective object in PreSheaves( PosetOfCategory( PathCategory(
 FinQuiver( "q(a,l,r,i,c,b)[ac:a-≻c,lc:l-≻c,ri:r-≻i,ic:i-≻c,cb:c-≻b]" ) ) ),
 IntervalCategory )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">section :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject( c );</span>
&lt;A split monomorphism in FiniteStrictCoproductCompletion(
 PosetOfCategory( PathCategory(
 FinQuiver( "q(a,l,r,i,c,b)[ac:a-≻c,lc:l-≻c,ri:r-≻i,ic:i-≻c,cb:c-≻b]" ) ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( section );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( section );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Source( section ) );</span>
[ 1, [ An object in the poset given by: (c) ] ]

An object in FiniteStrictCoproductCompletion( PosetOfCategory( PathCategory(
FinQuiver( "q(a,l,r,i,c,b)[ac:a-≻c,lc:l-≻c,ri:r-≻i,ic:i-≻c,cb:c-≻b]" ) ) ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Target( section ) );</span>
[ 5, [ An object in the poset given by: (a),
       An object in the poset given by: (l),
       An object in the poset given by: (r),
       An object in the poset given by: (i),
       An object in the poset given by: (c) ] ]

An object in FiniteStrictCoproductCompletion( PosetOfCategory( PathCategory(
FinQuiver( "q(a,l,r,i,c,b)[ac:a-≻c,lc:l-≻c,ri:r-≻i,ic:i-≻c,cb:c-≻b]" ) ) ) )
given by the above data
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
