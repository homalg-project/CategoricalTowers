# SPDX-License-Identifier: GPL-2.0-or-later
# FunctorCategories: Categories of functors
#
# Declarations
#

#! @Chapter Category of presheaves of a finitely presented (linear) category

####################################
#
#! @Section &GAP; Categories
#
####################################

#! @Description
#!  The &GAP; category of a presheaf category of a finitely presented enriched category.
#! @Arguments category
DeclareCategory( "IsPreSheafCategoryOfFpEnrichedCategory",
        IsPreSheafCategory );

#! @Description
#!  The &GAP; category of cells in a presheaf category of a finitely presented enriched category.
#! @Arguments cell
DeclareCategory( "IsCellInPreSheafCategoryOfFpEnrichedCategory",
        IsCellInPreSheafCategory );

#! @Description
#!  The &GAP; category of objects in a presheaf category of a finitely presented enriched category.
#! @Arguments obj
DeclareCategory( "IsObjectInPreSheafCategoryOfFpEnrichedCategory",
        IsCellInPreSheafCategoryOfFpEnrichedCategory and
        IsObjectInPreSheafCategory );

#! @Description
#!  The &GAP; category of morphisms in a presheaf category of a finitely presented enriched category.
#! @Arguments mor
DeclareCategory( "IsMorphismInPreSheafCategoryOfFpEnrichedCategory",
        IsCellInPreSheafCategoryOfFpEnrichedCategory and
        IsMorphismInPreSheafCategory );

####################################
#
#! @Section Attributes
#
####################################

##
DeclareAttribute( "ValuesOfPreSheaf",
        IsObjectInPreSheafCategory );

CapJitAddTypeSignature( "ValuesOfPreSheaf", [ IsObjectInPreSheafCategory ],
  function ( input_types )
    
    Assert( 0, IsPreSheafCategory( input_types[1].category ) );
    
    return CapJitDataTypeOfNTupleOf( 2,
                   CapJitDataTypeOfListOf( CapJitDataTypeOfObjectOfCategory( Target( input_types[1].category ) ) ),
                   CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( Target( input_types[1].category ) ) ) );
    
end );

#! @Description
#!  Returns the values of the presheaf morphism <A>eta</A> on all objects of the source category of presheaf category <A>PSh</A>.
#! @Arguments eta
#! @Returns a list
DeclareAttribute( "ValuesOnAllObjects",
        IsMorphismInPreSheafCategory );

CapJitAddTypeSignature( "ValuesOnAllObjects", [ IsMorphismInPreSheafCategory ],
  function ( input_types )
    
    Assert( 0, IsPreSheafCategory( input_types[1].category ) );
    
    return CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( Target( input_types[1].category ) ) );
    
end );

#!  The 2-cell underlying the functor object <A>F_or_eta</A>.
#! @Arguments F_or_eta
#! @Returns a &CAP; functor or natural transformation
DeclareAttribute( "UnderlyingCapTwoCategoryCell",
        IsCellInPreSheafCategory );

##
DeclareAttribute( "YonedaEmbeddingDataOfSourceCategory",
        IsPreSheafCategoryOfFpEnrichedCategory );

#! @Arguments B
#! @Returns a &CAP; functor
DeclareAttribute( "YonedaEmbedding",
        IsCapCategory );

#! @Arguments PSh
#! @Returns a &CAP; functor
DeclareAttribute( "YonedaEmbeddingOfSourceCategory",
        IsPreSheafCategory );

#! @Arguments PSh
#! Returns the full subcategory of <A>PSh</A> generated by the values of the Yoneda embedding on the objects of <C>Source</C>(<A>PSh</A>).
#! @Returns a &CAP; category
DeclareAttribute( "ImageOfYonedaEmbeddingOfSource",
        IsPreSheafCategory );

#! @Description
#!  The input is a category of presheaves <A>PSh</A> of an admissible $k$-algebroid for some field $k$.
#!  The output is the list of simple objects in <A>PSh</A>.
#! @Arguments PSh
#! @Returns a list of objects
DeclareAttribute( "SimpleObjects", IsPreSheafCategory );

#! @InsertChunk ProjectiveResolution
#! @InsertChunk ProjectiveResolutionAlgebroidFromDataTables

#! @Description
#!  The input is a category <A>B</A> with finitely many objects equipped with
#!  a homomorphism structure with values in a finite complete and finite cocomplete category <A>H</A>.
#!  The output is the nerve of <A>B</A> truncated in degree $2$,
#!  as an object in the category of presheaves on <C>SimplicialCategoryTruncatedInDegree</C>($2$)
#!  with values in <A>H</A>.
#! @Arguments B
#! @Returns a presheaf
DeclareAttribute( "NerveTruncatedInDegree2", IsCapCategory );
#! @InsertChunk NerveTruncatedInDegree2
#! @InsertChunk CategoryFromNerveData
#! @InsertChunk CategoryFromDataTables

#! @Description
#!  The input is a monomorphism <A>iota</A>:$Q \to P$ in the category of
#!  presheaves with values in <C>RangeCategoryOfHomomorphismStructure</C>($C$)
#!  on the finitely presented category
#!  $C:=$(<C>Source</C>($P$)) with finite $\mathrm{Hom}$-sets.
#!  The output is the morphism from $P$ to
#!  the <C>SieveFunctor</C>($C$) mapping for each $c \in C$ the element $x \in P(c)$
#!  to its <Q>paths to truth</Q> $f: a \to c$ translating $x$ into $f(x) \in Q(a) \subseteq P(a)$.
#! @Returns a monomorphisms in a Hom-category of functors
#! @Arguments iota
DeclareAttribute( "SievesOfPathsToTruth", IsMorphismInPreSheafCategory );

#! @Description
#!  Given the presheaf category <A>PSh</A>=<C>PreSheaves</C>( $C$, $V$ ), return
#!  the "sub"category <C>EnrichmentSpecificFiniteStrictCoproductCompletion</C>( $C$ ).
#! @Arguments PSh
#! @Returns a &CAP; category
DeclareAttribute( "FiniteStrictCoproductCompletionOfSourceCategory",
        IsPreSheafCategory );

CapJitAddTypeSignature( "FiniteStrictCoproductCompletionOfSourceCategory", [ IsPreSheafCategory ],
  function ( input_types )
    
    return CapJitDataTypeOfCategory( EnrichmentSpecificFiniteStrictCoproductCompletion( Source( input_types[1].category ) ) );
    
end );

#! @Description
#!  Given the presheaf category <A>PSh</A>=<C>PreSheaves</C>( $C$, $V$ ), return
#!  the ambient category <C>CoequalizerCompletion</C>( <C>FiniteStrictCoproductCompletionOfSourceCategory</C>( <A>PSh</A> ) ).
#! @Arguments PSh
#! @Returns a &CAP; category
DeclareAttribute( "FiniteColimitCompletionWithStrictCoproductsOfSourceCategory",
        IsPreSheafCategory );

CapJitAddTypeSignature( "FiniteColimitCompletionWithStrictCoproductsOfSourceCategory", [ IsPreSheafCategory ],
  function ( input_types )
    
    return CapJitDataTypeOfCategory( FiniteColimitCompletionWithStrictCoproducts( Source( input_types[1].category ) ) );
    
end );

#! @Description
#!  Given the presheaf category <A>PSh</A>=<C>PreSheaves</C>( $C$, $V$ ) return
#!  the ambient category <C>CategoryOfColimitQuivers</C>( $C$ ), provided
#!  $C$ is enriched over <C>SkeletalFinSets</C> or over <C>IntervalCategory</C>.
#! @Arguments PSh
#! @Returns a &CAP; category
DeclareAttribute( "CategoryOfColimitQuiversOfSourceCategory",
        IsPreSheafCategory );

CapJitAddTypeSignature( "CategoryOfColimitQuiversOfSourceCategory", [ IsPreSheafCategory ],
  function ( input_types )
    
    return CapJitDataTypeOfCategory( CategoryOfColimitQuivers( Source( input_types[1].category ) ) );
    
end );

####################################
#
#! @Section Operations
#
####################################

CapJitAddTypeSignature( "ListOfValues", [ IsList ],
  function ( input_types )
    
    return input_types[1];
    
end );

#! @Description
#!  Apply the presheaf <A>F</A> to the object <A>obj</A>.
#!  The shorthand is <A>F</A>(<A>obj</A>).
#! @Arguments F, obj
#! @Returns a &CAP; object
DeclareOperation( "ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToObject",
        [ IsPreSheafCategoryOfFpEnrichedCategory, IsObjectInPreSheafCategoryOfFpEnrichedCategory, IsCapCategoryObject ] );

#! @Description
#!  Apply the presheaf <A>F</A> to the morphism <A>mor</A>.
#!  The shorthand is <A>F</A>(<A>mor</A>).
#! @Arguments F, mor
#! @Returns a &CAP; morphism
DeclareOperation( "ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToMorphism",
        [ IsPreSheafCategoryOfFpEnrichedCategory, IsObjectInPreSheafCategoryOfFpEnrichedCategory, IsCapCategoryMorphism ] );

#! @Description
#!  Apply the presheaf <A>F</A> to the morphism <A>mor</A> which is either a generating morphism or an identity morphism.
#! @Arguments F, mor
#! @Returns a &CAP; morphism
DeclareOperation( "ApplyObjectInPreSheafCategoryOfFpEnrichedCategoryToGeneratingMorphismOrIdentity",
        [ IsPreSheafCategoryOfFpEnrichedCategory, IsObjectInPreSheafCategoryOfFpEnrichedCategory, IsCapCategoryMorphism ] );

#! @Description
#!  Apply the presheaf morphism <A>eta</A> to the object <A>obj</A>.
#!  The shorthand is <A>eta</A>(<A>o</A>).
#! @Arguments eta, obj
#! @Returns a &CAP; morphism
DeclareOperation( "ApplyMorphismInPreSheafCategoryOfFpEnrichedCategoryToObject",
        [ IsPreSheafCategoryOfFpEnrichedCategory, IsMorphismInPreSheafCategoryOfFpEnrichedCategory, IsCapCategoryObject ] );

####################################
#
#! @Section Constructors
#
####################################

#! @Arguments B, k
#! @Group PreSheaves
DeclareOperationWithCache( "PreSheaves",
        [ IsCapCategory, IsHomalgRing ] );

DeclareOperationWithCache( "PreSheavesOfFpEnrichedCategory",
        [ IsCapCategory, IsCapCategory ] );

CapJitAddTypeSignature( "PreSheavesOfFpEnrichedCategory", [ IsCapCategory, IsCapCategory ], IsPreSheafCategoryOfFpEnrichedCategory );

DeclareOperation( "CreatePreSheafByValues", [ IsPreSheafCategory, IsList, IsList ] );

DeclareOperation( "CreatePreSheafByFunctions", [ IsPreSheafCategory, IsFunction, IsFunction ] );

#! @Description
#!  Turn the functor <C><A>F</A>:<A>B</A>^op</C> $\to$ <C>D</C> into an object in the category of functors <C><A>PSh</A> := PreSheaves( <A>B</A>, D )</C>.
#! @Arguments PSh, values_of_all_objects, values_of_all_generating_morphisms
#! @Returns a presheaf
#! @Group CreatePreSheaf

#! @Arguments F
#! @Group CreatePreSheaf
DeclareAttribute( "CreatePreSheaf",
        IsCapFunctor );

#! @Description
#!  An alternative input is the source category <A>B</A> and two defining records <A>rec_images_of_objects</A> and <A>rec_images_of_morphisms</A> of <A>F</A>.
#! @Arguments B, rec_images_of_objects, rec_images_of_morphisms
#! @Group CreatePreSheaf
DeclareOperation( "CreatePreSheaf",
        [ IsCapCategory, IsRecord, IsRecord ] );

#! @Description
#!  Another alternative input is the source category <A>B</A> and two defining lists <A>images_of_objects</A> and <A>images_of_morphisms</A> of <A>F</A>.
#!  The order of their entries must correspond to that of the vertices and arrows of the underlying quiver.
#!
#!  For the convenience of the user the following input is also valid:
#!  If <A>images_of_objects</A> is a list of nonnegative integers,
#!  <A>images_of_morphisms</A> is a list of matrices, and
#!  $k:=$ <C>CommutativeRingOfLinearCategory</C>( B ) is a field
#!  then the two lists are interpreted as objects and morphisms
#!  in a matrix category or a category of rows over $k$, respectively.
#! @Arguments B, images_of_objects, images_of_morphisms
#! @Group CreatePreSheaf
DeclareOperation( "CreatePreSheaf",
        [ IsCapCategory, IsList, IsList ] );

#! @Description
#! @Returns a morphism in a &CAP; category
#! @Group CreatePreSheafMorphism
DeclareOperation( "CreatePreSheafMorphismByValues",
        [ IsPreSheafCategory, IsObjectInPreSheafCategory, IsList, IsObjectInPreSheafCategory ] );

#! @Description
#!  Turn the natrual transformation <A>eta</A>:$F \to G$ into a morphism
#!  <C><A>U</A> := AsObjectInFunctorCategory( F )</C> $\to$ <C><A>V</A> := AsObjectInFunctorCategory( G )</C>
#!  in the category of functors <C><A>Hom</A> := Hom( B, D )</C>, where
#!  <C>B := Source( F ) = Source( G )</C> and <C>C := Target( F ) = Target( G )</C>.
#! @Arguments eta
#! @Group CreatePreSheafMorphism
DeclareAttribute( "CreatePreSheafMorphism",
        IsCapNaturalTransformation );

#!  Another alternative input is the triple (<A>U</A>, <A>e</A>, <A>V</A>),
#!  where <A>e</A> is a defining list of <A>eta</A>.
#! @Arguments U, e, V
#! @Group CreatePreSheafMorphism
DeclareOperation( "CreatePreSheafMorphism",
        [ IsObjectInPreSheafCategory, IsList, IsObjectInPreSheafCategory ] );

#! @Arguments U, e, V
#!  An alternative input is the triple (<A>U</A>, <A>e</A>, <A>V</A>),
#!  where <A>e</A> is a defining record of <A>eta</A>.
#! @Group CreatePreSheafMorphism
DeclareOperation( "CreatePreSheafMorphism",
        [ IsObjectInPreSheafCategory, IsRecord, IsObjectInPreSheafCategory ] );

#! @Group CreatePreSheafMorphism
DeclareOperation( "CreatePreSheafMorphismByFunction",
        [ IsObjectInPreSheafCategory, IsFunction, IsObjectInPreSheafCategory ] );

#! @Arguments F
DeclareAttribute( "CoYonedaLemmaOnObjects",
        IsObjectInPreSheafCategory );

#! @Arguments phi
DeclareAttribute( "CoYonedaLemmaOnMorphisms",
        IsMorphismInPreSheafCategory );

#! @Arguments F
DeclareAttribute( "CoequalizerDataOfPreSheafUsingCoYonedaLemma",
        IsObjectInPreSheafCategory );

#! @Arguments F
DeclareAttribute( "CoYonedaLemmaCoequalizerPair",
        IsObjectInPreSheafCategory );

#! @Arguments PSh
DeclareAttribute( "EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheavesData",
        IsPreSheafCategory );

#! @Arguments PSh
DeclareAttribute( "EmbeddingFunctorOfFiniteStrictCoproductCompletionIntoPreSheaves",
        IsPreSheafCategory );

#! @Arguments PSh, objB, morC, F
DeclareOperation( "MorphismFromRepresentableByYonedaLemma",
    [ IsPreSheafCategory, IsCapCategoryObject, IsCapCategoryMorphism, IsObjectInPreSheafCategory ] );

#! @Arguments PSh, list, F
DeclareOperation( "MorphismFromCoproductOfRepresentables",
    [ IsPreSheafCategory, IsList, IsObjectInPreSheafCategory ] );

#! @Arguments F
DeclareAttribute( "MaximalMorphismFromRepresentable",
        IsObjectInPreSheafCategory );

#! @Arguments F
DeclareAttribute( "CoveringListOfRepresentables",
        IsObjectInPreSheafCategory );

#! @Arguments F
DeclareAttribute( "CoveringListOfRepresentablesUsingSplits",
        IsObjectInPreSheafCategory );

#! @Arguments F
DeclareAttribute( "EpimorphismFromSomeProjectiveObjectUsingSplits",
        IsObjectInPreSheafCategory );

#! @Arguments F
DeclareOperation( "SectionAndComplementByCoveringListOfRepresentables",
        [ IsPreSheafCategory, IsList, IsObjectInPreSheafCategory ] );

#! @Arguments F
DeclareAttribute( "SectionFromOptimizedCoYonedaProjectiveObjectIntoCoYonedaProjectiveObject",
        IsObjectInPreSheafCategory );

#! @Arguments F
DeclareOperation( "RetractionByCoveringListOfRepresentables",
        [ IsPreSheafCategory, IsList, IsObjectInPreSheafCategory ] );

#! @Arguments F
DeclareAttribute( "RetractionFromCoYonedaProjectiveObjectOntoOptimizedCoYonedaProjectiveObject",
        IsObjectInPreSheafCategory );

#! @Arguments F
DeclareAttribute( "OptimizedCoYonedaLemmaOnObjects",
        IsObjectInPreSheafCategory );

#! @Arguments phi
DeclareAttribute( "OptimizedCoYonedaLemmaOnMorphisms",
        IsMorphismInPreSheafCategory );

#! @Arguments F
DeclareAttribute( "CoequalizerDataOfPreSheafUsingOptimizedCoYonedaLemma",
        IsObjectInPreSheafCategory );

#! @Arguments F
DeclareAttribute( "AssociatedCoequalizerPairInPreSheaves",
        IsObjectInCategoryOfColimitQuivers );

#! @Arguments F
DeclareAttribute( "AssociatedCellInPreSheaves",
        IsCellInCategoryOfColimitQuivers );

#! @Arguments F
DeclareAttribute( "AssociatedCoequalizerPairInPreSheaves",
        IsObjectInFiniteColimitCompletionWithStrictCoproducts );

#! @Arguments F
DeclareAttribute( "OptimizedCoYonedaLemmaCoequalizerPair",
        IsObjectInPreSheafCategory );

#! @Arguments PSh, presheaf, obj
DeclareOperation( "ApplyPreSheafToObjectInFiniteStrictCoproductCompletion",
        [ IsCapCategory, IsObjectInPreSheafCategory, IsObjectInFiniteStrictCoproductCompletion ] );

#! @Arguments PSh, presheaf, mor
DeclareOperation( "ApplyPreSheafToMorphismInFiniteStrictCoproductCompletion",
        [ IsCapCategory, IsObjectInPreSheafCategory, IsMorphismInFiniteStrictCoproductCompletion ] );

#! @Description
#!  Construct the category of categories internal to the monoidal or cartesian category <A>C</A>.
#!  The output the full subcategory of the subcategory of functors from the
#!  <C>SimplicialCategoryTruncatedInDegree</C>(2) into <A>C</A>
#!  for which each such functor is the nerve truncated in degree $2$ of a category internal to <A>C</A>.
#! @Arguments C
DeclareAttribute( "CategoryOfInternalCategories",
        IsCapCategory );
