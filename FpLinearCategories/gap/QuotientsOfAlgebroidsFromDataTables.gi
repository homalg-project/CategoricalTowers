# SPDX-License-Identifier: GPL-2.0-or-later
# FpLinearCategories: Finitely presented linear categories by generating quivers and relations
#
# Implementations
#

##
InstallOtherMethod( QuotientCategory,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  function ( A, relations )
    local A_op, A_as_presheaf, eager, PSh, tau, S, H, pi, congruence_func, name, quo_A, FinalizeCategory, range_of_HomStructure, ring;
    
    if not IsPackageMarkedForLoading( "FunctorCategories", "2023.12-01" ) then
        
        Error( "the package `FunctorCategories` with version at least V2023.12-01 is required for this method!\n" );
        
    fi;
    
    A_op := OppositeAlgebroid( A );
    
    A_as_presheaf := ValueGlobal( "AlgebroidAsObjectInPreSheavesCategory" )( A : eager := false );
    
    PSh := CapCategory( A_as_presheaf );
    
    tau := UniversalMorphismFromDirectSum( PSh, A_as_presheaf,
              List( relations, rel -> ValueGlobal( "AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory" )( rel ) ) );
    
    S := Source( PSh );
    H := Target( PSh );
    
    if HasIsAbelianCategory( H ) and IsAbelianCategory( H ) then
        
        pi := CokernelProjection( PSh, tau );
        
        congruence_func :=
          function ( m )
            local obj;
            
            obj := ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( Target( m ) )], Source( m ), S );
            
            return IsZeroForMorphisms( H, PreCompose( H, ValueGlobal( "AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory" )( m )( obj ), pi( obj ) ) );
            
        end;
        
    elif CanCompute( H, "IsLiftable" ) then
        
        congruence_func :=
          function ( m )
            local obj;
            
            obj := ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( Target( m ) )], Source( m ), S );
            
            return IsLiftable( H, ValueGlobal( "AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory" )( m )( obj ), tau( obj ) );
            
        end;
        
    else
        
        Error( "the operation 'IsLiftable' must be added to the range category of Hom-Structure!" );
        
    fi;
    
    name := Concatenation( "QuotientCategory( ", Name( A ), ", 2-sided ideal generated by ", String( Length( relations ) ), " morphisms )" );
    
    if Length( relations ) = 1 then
        name := ReplacedString( name, "morphisms )", "morphism )" );
    fi;
    
    quo_A := QuotientCategory(
                  rec( underlying_category := A,
                        name := name,
                        congruence_func := congruence_func,
                        nr_arguments_of_congruence_func := 1 ) : FinalizeCategory := false );
    
    ##
    ## Adding the Hom-Structure
    ##
    
    range_of_HomStructure := RangeCategoryOfHomomorphismStructure( A );
    
    ring := UnderlyingRing( range_of_HomStructure );
    
    if IsFieldForHomalg( ring ) then
        
        SetRangeCategoryOfHomomorphismStructure( quo_A, range_of_HomStructure );
        
        AddDistinguishedObjectOfHomomorphismStructure( quo_A,
          function ( quo_A )
            
            return DistinguishedObjectOfHomomorphismStructure( A );
            
        end );
        
        AddHomomorphismStructureOnObjects( quo_A,
          function ( quo_A, s, t )
            
            s := ObjectDatum( quo_A, s );
            t := ObjectDatum( quo_A, t );
            
            return Target( pi )( ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( t )], s, S ) );
            
        end );
        
        AddHomomorphismStructureOnMorphismsWithGivenObjects( quo_A,
          function ( quo_A, s, f, g, t )
            local g_op, g_op_x_f;
            
            f := MorphismDatum( quo_A, f );
            g := MorphismDatum( quo_A, g );
            
            g_op := MorphismConstructor( A_op,
                      SetOfObjects( A_op )[ObjectIndex( Target( g ) )],
                      CoefficientsList( g ),
                      IndicesOfSupportMorphisms( g ),
                      SetOfObjects( A_op )[ObjectIndex( Source( g ) )] );
            
            g_op_x_f := ElementaryTensor( g_op, f, S );
            
            return CokernelObjectFunctorialWithGivenCokernelObjects( RangeCategoryOfHomomorphismStructure( quo_A ),
                        s,
                        tau( Target( g_op_x_f ) ),
                        A_as_presheaf( g_op_x_f ),
                        tau( Source( g_op_x_f ) ),
                        t );
            
        end );
        
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( quo_A,
          function ( quo_A, mor )
            local distinguished_object, s, t, t_op_x_s;
            
            distinguished_object := DistinguishedObjectOfHomomorphismStructure( quo_A );
            
            mor := MorphismDatum( quo_A, mor );
            
            s := Source( mor );
            t := Target( mor );
            
            t_op_x_s := ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( t )], s, S );
            
            return PreCompose( RangeCategoryOfHomomorphismStructure( quo_A ),
                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( A, distinguished_object, mor, A_as_presheaf( t_op_x_s ) ),
                      pi( t_op_x_s ) );
            
        end );
        
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( quo_A,
          function ( quo_A, source, target, eta )
            local s, t, mor;
            
            s := ObjectDatum( quo_A, source );
            t := ObjectDatum( quo_A, target );
            
            eta := ProjectiveLift( RangeCategoryOfHomomorphismStructure( quo_A ),
                      eta, pi( ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( t )], s, S ) ) );
            
            mor := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( A, s, t, eta );
            
            return MorphismConstructor( quo_A, source, mor, target );
            
        end );
         
    else
        
        range_of_HomStructure := FreydCategory( range_of_HomStructure );
        
        SetRangeCategoryOfHomomorphismStructure( quo_A, range_of_HomStructure );
        
        AddDistinguishedObjectOfHomomorphismStructure( quo_A,
          function ( quo_A )
            
            return AsFreydCategoryObject( range_of_HomStructure, DistinguishedObjectOfHomomorphismStructure( A ) );
            
        end );
        
        AddHomomorphismStructureOnObjects( quo_A,
          function ( quo_A, s, t )
            
            s := ObjectDatum( quo_A, s );
            t := ObjectDatum( quo_A, t );
            
            return FreydCategoryObject( RangeCategoryOfHomomorphismStructure( quo_A ),
                          tau( ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( t )], s, S ) ) );
            
        end );
        
        AddHomomorphismStructureOnMorphismsWithGivenObjects( quo_A,
          function ( quo_A, s, f, g, t )
            local g_op;
            
            f := MorphismDatum( quo_A, f );
            g := MorphismDatum( quo_A, g );
            
            g_op := MorphismConstructor( A_op,
                      SetOfObjects( A_op )[ObjectIndex( Target( g ) )],
                      CoefficientsList( g ),
                      IndicesOfSupportMorphisms( g ),
                      SetOfObjects( A_op )[ObjectIndex( Source( g ) )] );
            
            return FreydCategoryMorphism( RangeCategoryOfHomomorphismStructure( quo_A ),
                        s,
                        A_as_presheaf( ElementaryTensor( g_op, f, S ) ),
                        t );
            
        end );
        
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( quo_A,
          function ( quo_A, distinguished_object, mor, t )
            
            return FreydCategoryMorphism( RangeCategoryOfHomomorphismStructure( quo_A ),
                      distinguished_object,
                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( A,
                                        Target( RelationMorphism( distinguished_object ) ),
                                        MorphismDatum( quo_A, mor ),
                                        Target( RelationMorphism( t ) ) ),
                      t );
            
        end );
        
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( quo_A,
          function ( quo_A, source, target, eta )
            local mor;
            
            mor := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( A,
                                    ObjectDatum( quo_A, source ),
                                    ObjectDatum( quo_A, target ),
                                    UnderlyingMorphism( eta ) );
            
            return MorphismConstructor( quo_A, source, mor, target );
            
        end );
    
    fi;
    
    ##
    InstallMethod( ViewString,
              [ ObjectFilter( quo_A ) ],
      function ( obj )
        
        return ViewString( ObjectDatum( obj ) );
        
    end );
    
    ##
    InstallMethod( DisplayString,
              [ ObjectFilter( quo_A ) ],
      function ( obj )
      
        return DisplayString( ObjectDatum( obj ) );
      
    end );
    
    ##
    InstallMethod( ViewString,
              [ MorphismFilter( quo_A ) ],
      function ( mor )
        local string;
        
        string := ViewString( UnderlyingCell( mor ) );
        string := ReplacedString( string, "<", "<[" );
        string := ReplacedString( string, ">", "]>" );
        
        return string;
        
    end );
    
    ##
    InstallMethod( DisplayString,
              [ MorphismFilter( quo_A ) ],
      function ( mor )
        
        return Concatenation( ViewString( mor ), "\n" );
        
    end );
    
    Finalize( quo_A );
    
    return quo_A;
    
end );

##
InstallOtherMethod( AlgebroidFromDataTables,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  function ( A, relations )
    
    return AlgebroidFromDataTables( QuotientCategory( A, relations ) );
    
end );

##
InstallOtherMethod( \/,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  function ( A, relations )
    
    return AlgebroidFromDataTables( A, relations );
    
end );
