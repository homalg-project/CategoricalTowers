<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (FiniteCocompletions) - Chapter 2: Finite strict product completion</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X86DB6D0E819FA591" name="X86DB6D0E819FA591"></a></p>
<div class="ChapSects"><a href="chap2.html#X86DB6D0E819FA591">2 <span class="Heading">Finite strict product completion</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7C701DBF7BAE649A">2.1 <span class="Heading">Attributes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X849BF31781AB814D">2.1-1 PairOfIntAndList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X851AE46B7C603DFF">2.1-2 PairOfLists</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C72332C853BB940">2.1-3 UnderlyingCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X79B7ADFC81DB2664">2.1-4 NumberOfObjectsOfUnderlyingCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8347FE427A599F92">2.1-5 EmbeddingOfUnderlyingCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X87313D7C8282D2C2">2.1-6 ExtendFunctorToFiniteStrictCoproductCompletionOfObjectFiniteCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8701742881CE0C4D">2.1-7 PairOfIntAndList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7FAE718A7DB3B29A">2.1-8 PairOfLists</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D07FCA482AD18F1">2.1-9 UnderlyingCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X863DD64B78748D3F">2.1-10 EmbeddingOfUnderlyingCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X874A12677A2C5833">2.1-11 ExtendFunctorToFiniteStrictProductCompletion</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X86EC0F0A78ECBC10">2.2 <span class="Heading">Constructors</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B7C07B987F2F7B5">2.2-1 FiniteStrictCoproductCompletionOfObjectFiniteCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8640207B7E9F0CB4">2.2-2 FiniteStrictProductCompletion</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7D03633A7D98026B">2.3 <span class="Heading">GAP categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8698FCF17CA8865C">2.3-1 IsFiniteStrictCoproductCompletionOfObjectFiniteCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8261903A78289AD7">2.3-2 IsCellInFiniteStrictCoproductCompletionOfObjectFiniteCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X84063CC47AACDCA2">2.3-3 IsObjectInFiniteStrictCoproductCompletionOfObjectFiniteCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X828A21A584D97F34">2.3-4 IsMorphismInFiniteStrictCoproductCompletionOfObjectFiniteCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X85A2FA1C7A8DF8B0">2.3-5 IsFiniteStrictProductCompletion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C58CDAA87425E6B">2.3-6 IsCellInFiniteStrictProductCompletion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F1175D1834265B7">2.3-7 IsObjectInFiniteStrictProductCompletion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X807ECF148202A522">2.3-8 IsMorphismInFiniteStrictProductCompletion</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7A489A5D79DA9E5C">2.4 <span class="Heading">Examples</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D4582397CD2E4D7">2.4-1 <span class="Heading">Cartesian braiding</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80ADA08878BD2857">2.4-2 <span class="Heading">Cartesian diagonal</span></a>
</span>
</div></div>
</div>

<h3>2 <span class="Heading">Finite strict product completion</span></h3>

<p><a id="X7C701DBF7BAE649A" name="X7C701DBF7BAE649A"></a></p>

<h4>2.1 <span class="Heading">Attributes</span></h4>

<p><a id="X849BF31781AB814D" name="X849BF31781AB814D"></a></p>

<h5>2.1-1 PairOfIntAndList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PairOfIntAndList</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X851AE46B7C603DFF" name="X851AE46B7C603DFF"></a></p>

<h5>2.1-2 PairOfLists</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PairOfLists</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7C72332C853BB940" name="X7C72332C853BB940"></a></p>

<h5>2.1-3 UnderlyingCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingCategory</code>( <var class="Arg">UC</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Return the category <span class="Math">C</span> underlying the finite product completion category <var class="Arg">UC</var><code class="code"> := FiniteStrictCoproductCompletionOfObjectFiniteCategory(</code> <span class="Math">C</span> <code class="code">)</code>).</p>

<p><a id="X79B7ADFC81DB2664" name="X79B7ADFC81DB2664"></a></p>

<h5>2.1-4 NumberOfObjectsOfUnderlyingCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfObjectsOfUnderlyingCategory</code>( <var class="Arg">UC</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Return the number of objects in the category <span class="Math">C</span> underlying the finite product completion category <var class="Arg">UC</var><code class="code"> := FiniteStrictCoproductCompletionOfObjectFiniteCategory(</code> <span class="Math">C</span> <code class="code">)</code>).</p>

<p><a id="X8347FE427A599F92" name="X8347FE427A599F92"></a></p>

<h5>2.1-5 EmbeddingOfUnderlyingCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmbeddingOfUnderlyingCategory</code>( <var class="Arg">PC</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a CAP functor</p>

<p>The full embedding functor from the category <span class="Math">C</span> underlying the finite product completion <var class="Arg">PC</var> into <var class="Arg">PC</var>.</p>

<p><a id="X87313D7C8282D2C2" name="X87313D7C8282D2C2"></a></p>

<h5>2.1-6 ExtendFunctorToFiniteStrictCoproductCompletionOfObjectFiniteCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtendFunctorToFiniteStrictCoproductCompletionOfObjectFiniteCategory</code>( <var class="Arg">PC</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a CAP functor</p>

<p>The full embedding functor from the category <span class="Math">C</span> underlying the finite product completion <var class="Arg">UC</var> into <var class="Arg">UC</var>.</p>

<p><a id="X8701742881CE0C4D" name="X8701742881CE0C4D"></a></p>

<h5>2.1-7 PairOfIntAndList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PairOfIntAndList</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7FAE718A7DB3B29A" name="X7FAE718A7DB3B29A"></a></p>

<h5>2.1-8 PairOfLists</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PairOfLists</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7D07FCA482AD18F1" name="X7D07FCA482AD18F1"></a></p>

<h5>2.1-9 UnderlyingCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingCategory</code>( <var class="Arg">UC</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Return the category <span class="Math">C</span> underlying the finite product completion category <var class="Arg">UC</var><code class="code"> := FiniteStrictProductCompletion(</code> <span class="Math">C</span> <code class="code">)</code>).</p>

<p><a id="X863DD64B78748D3F" name="X863DD64B78748D3F"></a></p>

<h5>2.1-10 EmbeddingOfUnderlyingCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmbeddingOfUnderlyingCategory</code>( <var class="Arg">PC</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a CAP functor</p>

<p>The full embedding functor from the category <span class="Math">C</span> underlying the finite product completion <var class="Arg">PC</var> into <var class="Arg">PC</var>.</p>

<p><a id="X874A12677A2C5833" name="X874A12677A2C5833"></a></p>

<h5>2.1-11 ExtendFunctorToFiniteStrictProductCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtendFunctorToFiniteStrictProductCompletion</code>( <var class="Arg">PC</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a CAP functor</p>

<p>The full embedding functor from the category <span class="Math">C</span> underlying the finite product completion <var class="Arg">UC</var> into <var class="Arg">UC</var>.</p>

<p><a id="X86EC0F0A78ECBC10" name="X86EC0F0A78ECBC10"></a></p>

<h4>2.2 <span class="Heading">Constructors</span></h4>

<p><a id="X7B7C07B987F2F7B5" name="X7B7C07B987F2F7B5"></a></p>

<h5>2.2-1 FiniteStrictCoproductCompletionOfObjectFiniteCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FiniteStrictCoproductCompletionOfObjectFiniteCategory</code>( <var class="Arg">cat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Return the finite product completion of the category <var class="Arg">cat</var> in which the cartesian associators are given by identities.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FiniteCocompletions", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := FinQuiver( "q(a,b,c)[m:a-&gt;b,n:b-&gt;c]" );</span>
FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PathCategory( q : skeletal := true );</span>
PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mUP := FiniteStrictCoproductCompletionOfObjectFiniteCategory( P );</span>
FiniteStrictCoproductCompletionOfObjectFiniteCategory(
PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := mUP.a;</span>
&lt;An object in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := mUP.b;</span>
&lt;An object in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := mUP.c;</span>
&lt;An object in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := mUP.m;</span>
&lt;A morphism in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := mUP.n;</span>
&lt;A morphism in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( m, n );</span>
&lt;A morphism in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := [ 3, [ 1, 2, 0 ] ] / mUP;</span>
&lt;An object in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := [ 6, [ 3, 2, 1 ] ] / mUP;</span>
&lt;An object in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ix := InjectionOfCofactorOfCoproduct( [ x, y ], 1 );</span>
&lt;A morphism in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iy := InjectionOfCofactorOfCoproduct( [ x, y ], 2 );</span>
&lt;A morphism in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := UniversalMorphismFromCoproduct( [ ix, iy ] );</span>
&lt;A morphism in FiniteStrictCoproductCompletionOfObjectFiniteCategory(
 PathCategory( FinQuiver( "q(a,b,c)[m:a→b,n:b→c]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FiniteCocompletions", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := FinQuiver( "q(M,A,B,J)[a:M-&gt;A,b:M-&gt;B,i:A-&gt;J,j:B-&gt;J]" );</span>
FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := PathCategory( q );</span>
PathCategory( FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := PosetOfCategory( D );</span>
PosetOfCategory( PathCategory( \
FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L.ai = L.bj;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( SetOfObjects( L ), Display );</span>
(M)

An object in the poset given by the above data
(A)

An object in the poset given by the above data
(B)

An object in the poset given by the above data
(J)

An object in the poset given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ltilde := FiniteStrictCoproductCompletionOfObjectFiniteCategory( L );</span>
FiniteStrictCoproductCompletionOfObjectFiniteCategory( PosetOfCategory( \
PathCategory( FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( SetOfObjects( Ltilde ) );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lhat := PosetOfCategory( Ltilde );</span>
PosetOfCategory( FiniteStrictCoproductCompletionOfObjectFiniteCategory( \
PosetOfCategory( PathCategory( \
FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Lhat );</span>
A CAP category with name PosetOfCategory( \
FiniteStrictCoproductCompletionOfObjectFiniteCategory( PosetOfCategory( \
PathCategory( FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) ) ) ) ):

10 primitive operations were used to derive 98 operations for this category which not yet algorithmically
* IsCategoryWithDecidableColifts
* IsCategoryWithDecidableLifts
* IsFiniteCategory
* IsEquippedWithHomomorphismStructure
* IsJoinSemiLattice
</pre></div>

<p><a id="X8640207B7E9F0CB4" name="X8640207B7E9F0CB4"></a></p>

<h5>2.2-2 FiniteStrictProductCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FiniteStrictProductCompletion</code>( <var class="Arg">cat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Return the finite product completion of the category <var class="Arg">cat</var> in which the cartesian associators are given by identities.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FiniteCocompletions", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := FinQuiver( "q(M,A,B,J)[a:M-&gt;A,b:M-&gt;B,i:A-&gt;J,j:B-&gt;J]" );</span>
FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := PathCategory( q );</span>
PathCategory( FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := PosetOfCategory( D );</span>
PosetOfCategory( PathCategory( \
FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L.ai = L.bj;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( SetOfObjects( L ), Display );</span>
(M)

An object in the poset given by the above data
(A)

An object in the poset given by the above data
(B)

An object in the poset given by the above data
(J)

An object in the poset given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ltilde := FiniteStrictProductCompletion( L );</span>
FiniteStrictProductCompletion( PosetOfCategory( PathCategory( \
FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( SetOfObjects( Ltilde ) );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lhat := PosetOfCategory( Ltilde );</span>
PosetOfCategory( FiniteStrictProductCompletion( PosetOfCategory( \
PathCategory( FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lhat_objs := SetOfObjects( Lhat );; Length( Lhat_objs );</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := Lhat.M;</span>
An object in the poset given by: \
&lt;An object in FiniteStrictProductCompletion( PosetOfCategory( \
PathCategory( FinQuiver( "q(M,A,B,J)[a:M→A,b:M→B,i:A→J,j:B→J]" ) ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := Lhat.A;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Lhat.B;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := Lhat.J;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := DirectProduct( Lhat.A, Lhat.B );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := TerminalObject( Lhat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P = M;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T = J;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lhat_objs = [ T, M, A, B, J, P ];</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FiniteCocompletions" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := FiniteStrictProductCompletion( InitialCategory( ) );</span>
FiniteStrictProductCompletion( InitialCategory( ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( T );</span>
A CAP category with name FiniteStrictProductCompletion( InitialCategory( ) ):

131 primitive operations were used to derive 627 operations for this category
which algorithmically
* IsCategoryWithDecidableColifts
* IsCategoryWithDecidableLifts
* IsFiniteCategory
* IsEquippedWithHomomorphismStructure
* IsLinearCategoryOverCommutativeRing
* IsLeftClosedMonoidalCategory
* IsLeftCoclosedMonoidalCategory
* IsRigidSymmetricClosedMonoidalCategory
* IsRigidSymmetricCoclosedMonoidalCategory
* IsAbelianCategoryWithEnoughInjectives
* IsAbelianCategoryWithEnoughProjectives
* IsAdditiveMonoidalCategory
* IsSymmetricClosedMonoidalLattice
* IsSymmetricCoclosedMonoidalLattice
* IsBooleanAlgebra
and not yet algorithmically
* IsLinearCategoryOverCommutativeRingWithFinitelyGeneratedFreeExternalHoms
and furthermore mathematically
* IsFinitelyPresentedLinearCategory
* IsLinearClosureOfACategory
* IsLocallyOfFiniteInjectiveDimension
* IsLocallyOfFiniteProjectiveDimension
* IsSymmetricMonoidalCategoryStructureGivenByCoproduct
* IsSymmetricMonoidalCategoryStructureGivenByDirectProduct
* IsTerminalCategory
* IsTotalOrderCategory
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := InitialObject( T );</span>
&lt;An object in FiniteStrictProductCompletion( InitialCategory( ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := TerminalObject( T );</span>
&lt;An object in FiniteStrictProductCompletion( InitialCategory( ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := ZeroObject( T );</span>
&lt;A zero object in FiniteStrictProductCompletion( InitialCategory( ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( i );</span>
[ 0, [  ] ]

An object in FiniteStrictProductCompletion( InitialCategory( ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t );</span>
[ 0, [  ] ]

An object in FiniteStrictProductCompletion( InitialCategory( ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( z );</span>
[ 0, [  ] ]

An object in FiniteStrictProductCompletion( InitialCategory( ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( i, z );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIdenticalObj( i, z );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( t, z );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIdenticalObj( t, z );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( z );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id_z := IdentityMorphism( z );</span>
&lt;A zero, identity morphism in
 FiniteStrictProductCompletion( InitialCategory( ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fn_z := ZeroObjectFunctorial( T );</span>
&lt;A zero, isomorphism in FiniteStrictProductCompletion( InitialCategory( ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( fn_z );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( id_z, fn_z );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( id_z, fn_z );</span>
true
</pre></div>

<p><a id="X7D03633A7D98026B" name="X7D03633A7D98026B"></a></p>

<h4>2.3 <span class="Heading">GAP categories</span></h4>

<p><a id="X8698FCF17CA8865C" name="X8698FCF17CA8865C"></a></p>

<h5>2.3-1 IsFiniteStrictCoproductCompletionOfObjectFiniteCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFiniteStrictCoproductCompletionOfObjectFiniteCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of finite product completion categories.</p>

<p><a id="X8261903A78289AD7" name="X8261903A78289AD7"></a></p>

<h5>2.3-2 IsCellInFiniteStrictCoproductCompletionOfObjectFiniteCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCellInFiniteStrictCoproductCompletionOfObjectFiniteCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of cells in a finite product completion category.</p>

<p><a id="X84063CC47AACDCA2" name="X84063CC47AACDCA2"></a></p>

<h5>2.3-3 IsObjectInFiniteStrictCoproductCompletionOfObjectFiniteCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsObjectInFiniteStrictCoproductCompletionOfObjectFiniteCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of objects in a finite product completion category.</p>

<p><a id="X828A21A584D97F34" name="X828A21A584D97F34"></a></p>

<h5>2.3-4 IsMorphismInFiniteStrictCoproductCompletionOfObjectFiniteCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMorphismInFiniteStrictCoproductCompletionOfObjectFiniteCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of morphisms in a finite product completion category.</p>

<p><a id="X85A2FA1C7A8DF8B0" name="X85A2FA1C7A8DF8B0"></a></p>

<h5>2.3-5 IsFiniteStrictProductCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFiniteStrictProductCompletion</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of finite product completion categories.</p>

<p><a id="X7C58CDAA87425E6B" name="X7C58CDAA87425E6B"></a></p>

<h5>2.3-6 IsCellInFiniteStrictProductCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCellInFiniteStrictProductCompletion</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of cells in a finite product completion category.</p>

<p><a id="X7F1175D1834265B7" name="X7F1175D1834265B7"></a></p>

<h5>2.3-7 IsObjectInFiniteStrictProductCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsObjectInFiniteStrictProductCompletion</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of objects in a finite product completion category.</p>

<p><a id="X807ECF148202A522" name="X807ECF148202A522"></a></p>

<h5>2.3-8 IsMorphismInFiniteStrictProductCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMorphismInFiniteStrictProductCompletion</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of morphisms in a finite product completion category.</p>

<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>

<h4>2.4 <span class="Heading">Examples</span></h4>

<p><a id="X7D4582397CD2E4D7" name="X7D4582397CD2E4D7"></a></p>

<h5>2.4-1 <span class="Heading">Cartesian braiding</span></h5>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FiniteCocompletions" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "Algebroids" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LazyCategories", "&gt;= 2023.01-02" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := RightQuiver( "Q(a,b)[]" );</span>
Q(a,b)[]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := FreeCategory( Q );</span>
FreeCategory( RightQuiver( "Q(a,b)[]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( C.a, "C.a" ); SetName( C.b, "C.b" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PC := FiniteStrictProductCompletion( C );</span>
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ModelingCategory( PC );</span>
Opposite( FiniteStrictCoproductCompletion( Opposite(
FreeCategory( RightQuiver( "Q(a,b)[]" ) ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := PC.a;</span>
&lt;An object in
 FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := PC.b;</span>
&lt;An object in
 FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ab := DirectProduct( a, b );</span>
&lt;An object in
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ab );</span>
[ 2, [ C.a, C.b ] ]

An object in
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ba := DirectProduct( b, a );</span>
&lt;An object in
 FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ba );</span>
[ 2, [ C.b, C.a ] ]

An object in
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( ab, ba );</span>
|1|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := MorphismsOfExternalHom( ab, ba );</span>
[ &lt;A morphism in
   FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := hom[1];</span>
&lt;A morphism in
 FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source( gamma ) = ab;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Target( gamma ) = ba;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( gamma );</span>
{ 0, 1 } ⱶ[ 1, 0 ]→ { 0, 1 }

[ (b)-[(b)]-&gt;(b), (a)-[(a)]-&gt;(a) ]

A morphism in
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma = CartesianBraiding( a, b );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LPC := LazyCategory( PC );</span>
LazyCategory(
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Emb := EmbeddingFunctorOfUnderlyingCategory( LPC );</span>
Embedding functor into lazy category
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Emb );</span>
Embedding functor into lazy category:

FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )
  |
  V
LazyCategory(
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := PreCompose( EmbeddingOfUnderlyingCategory( PC ), Emb );</span>
Precomposition of
Embedding functor into a finite strict product completion category and
Embedding functor into lazy category
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( F );</span>
Precomposition of
Embedding functor into a finite strict product completion category and
Embedding functor into lazy category:

FreeCategory( RightQuiver( "Q(a,b)[]" ) )
  |
  V
LazyCategory(
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExtendFunctorToFiniteStrictProductCompletion( F );</span>
Extension to FiniteStrictProductCompletion( Source( Precomposition of
Embedding functor into a finite strict product completion category and
Embedding functor into lazy category ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( G );</span>
Extension to FiniteStrictProductCompletion( Source( Precomposition of
Embedding functor into a finite strict product completion category and
Embedding functor into lazy category ) ):

FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) )
  |
  V
LazyCategory(
FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ggamma := G( gamma );</span>
&lt;A morphism in LazyCategory(
 FiniteStrictProductCompletion( FreeCategory( RightQuiver( "Q(a,b)[]" ) ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( Ggamma );</span>
true
</pre></div>

<p><a id="X80ADA08878BD2857" name="X80ADA08878BD2857"></a></p>

<h5>2.4-2 <span class="Heading">Cartesian diagonal</span></h5>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FiniteCocompletions" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "Algebroids" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LazyCategories", "&gt;= 2023.01-02" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := FinQuiver( "Q(a)[]" );</span>
FinQuiver( "Q(a)[]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := PathCategory( Q );</span>
PathCategory( FinQuiver( "Q(a)[]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( C.a, "C.a" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PC := FiniteStrictProductCompletion( C );</span>
FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ModelingCategory( PC );</span>
Opposite( FiniteStrictCoproductCompletion( Opposite(
PathCategory( FinQuiver( "Q(a)[]" ) ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := PC.a;</span>
&lt;An object in
 FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aa := DirectProduct( a, a );</span>
&lt;An object in
 FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( aa );</span>
[ 2, [ C.a, C.a ] ]

An object in
FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a = aa;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( aa, a );</span>
|2|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom_aa_a := MorphismsOfExternalHom( aa, a );</span>
[ &lt;A morphism in
   FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )&gt;,
  &lt;A morphism in
   FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom_aa_a[1] = ProjectionInFactorOfDirectProduct( [ a, a ], 1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom_aa_a[2] = ProjectionInFactorOfDirectProduct( [ a, a ], 2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( a, aa );</span>
|1|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom_a_aa := MorphismsOfExternalHom( a, aa );</span>
[ &lt;A morphism in
   FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta := hom_a_aa[1];</span>
&lt;A morphism in
 FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source( delta ) = a;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Target( delta ) = aa;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( ComponentOfMorphismIntoDirectProduct( delta, [ a, a ], 1 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( ComponentOfMorphismIntoDirectProduct( delta, [ a, a ], 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( delta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( delta );</span>
{ 0, 1 } ⱶ[ 0, 0 ]→ { 0 }

[ id(a):C.a → C.a, id(a):C.a → C.a ]

A morphism in
FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )
given by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id_a := IdentityMorphism( C.a );</span>
id(a):C.a → C.a
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta = CartesianDiagonal( a, 2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CellAsEvaluatableString( delta, [ "C", "PC" ] );</span>
"MorphismConstructor( PC,
        ObjectConstructor( PC,
                Pair( 1, [ ObjectConstructor( C, 1 ) ] ) ),
        Pair( [ 0, 0 ],
              [ IdentityMorphism( C, ObjectConstructor( C, 1 ) ),
                IdentityMorphism( C, ObjectConstructor( C, 1 ) ) ] ),
        ObjectConstructor( PC,
                Pair( 2,
                      [ ObjectConstructor( C, 1 ),
                        ObjectConstructor( C, 1 ) ] ) ) )"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LPC := LazyCategory( PC );</span>
LazyCategory(
FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Emb := EmbeddingFunctorOfUnderlyingCategory( LPC );</span>
Embedding functor into lazy category
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Emb );</span>
Embedding functor into lazy category:

FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )
  |
  V
LazyCategory(
FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := PreCompose( EmbeddingOfUnderlyingCategory( PC ), Emb );</span>
Precomposition of
Embedding functor into a finite strict product completion category and
Embedding functor into lazy category
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( F );</span>
Precomposition of
Embedding functor into a finite strict product completion category and
Embedding functor into lazy category:

PathCategory( FinQuiver( "Q(a)[]" ) )
  |
  V
LazyCategory(
FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExtendFunctorToFiniteStrictProductCompletion( F );</span>
Extension to FiniteStrictProductCompletion( Source( Precomposition of
Embedding functor into a finite strict product completion category and
Embedding functor into lazy category ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( G );</span>
Extension to FiniteStrictProductCompletion( Source( Precomposition of
Embedding functor into a finite strict product completion category and
Embedding functor into lazy category ) ):

FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) )
  |
  V
LazyCategory(
FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gdelta := G( delta );</span>
&lt;A morphism in LazyCategory(
 FiniteStrictProductCompletion( PathCategory( FinQuiver( "Q(a)[]" ) ) ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( Gdelta );</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
