# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

SetInfoLevel( InfoAlgebroids, 1 );

InstallValue( ALGEBROIDS,
        rec(
            ring := HomalgFieldOfRationals( ),
           )
);

####################################
#
# methods for attributes:
#
####################################

##
InstallOtherMethod( Range,
        "for a primitive path",
        [ IsPrimitivePath and IsNontrivialPath and IsArrow ],
        
  Target );

##
InstallMethod( Dimension,
        "for an algebroid",
        [ IsAlgebroid ],
        
  function( A )
    
    return Dimension( UnderlyingQuiverAlgebra( A ) );
    
end );

##
InstallMethod( SetOfObjects,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  A -> List( Vertices( UnderlyingQuiver( A ) ), o -> A.( String( o ) ) ) );

##
InstallMethod( AssignSetOfObjects,
        [ IsAlgebroid and HasUnderlyingQuiver, IsString ],
        
  function( A, label )
    local names, objects, func;
    
    names := List( Vertices( UnderlyingQuiver( A ) ), String );
    
    objects := SetOfObjects( A );
    
    func := function( name, o )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, o );
              
              return 1;
              
            end;
            
    ListN( names, objects, func );
    
end );

##
InstallOtherMethod( AssignSetOfObjects,
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  function( A )
  
    AssignSetOfObjects( A, "" );
    
end );

##
InstallMethod( SetOfGeneratingMorphisms,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  A -> List( Arrows( UnderlyingQuiver( A ) ), o -> A.(String( o ) ) ) );

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for an algebroid and two objects",
        [ IsAlgebroid and HasUnderlyingQuiver, IsObjectInAlgebroid, IsObjectInAlgebroid ],
        
  { A, obj_1, obj_2 } -> Filtered( SetOfGeneratingMorphisms( A ), m -> IsEqualForObjects( obj_1, Source( m ) ) and IsEqualForObjects( obj_2, Range( m ) ) )
);

##
InstallMethod( SetOfGeneratingMorphisms,
        "for two objects in an algebroid",
         [ IsObjectInAlgebroid, IsObjectInAlgebroid ],
         
  { obj_1, obj_2 } -> SetOfGeneratingMorphisms( CapCategory( obj_1 ), obj_1, obj_2 )
);

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for an algebroid and two integers",
        [ IsAlgebroid and HasUnderlyingQuiver, IsInt, IsInt ],
        
  { A, i, j } -> SetOfGeneratingMorphisms( A, SetOfObjects( A )[ i ], SetOfObjects( A )[ j ] )
);

##
InstallMethod( AssignSetOfGeneratingMorphisms,
        [ IsAlgebroid and HasUnderlyingQuiver, IsString ],
        
  function( A, label )
    local names, morphisms, func;
    
    names := List( Arrows( UnderlyingQuiver( A ) ), String );
    
    morphisms := SetOfGeneratingMorphisms( A );
    
    func := function( name, m )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, m );
              
              return 1;
              
            end;
            
    ListN( names, morphisms, func );
    
end );

##
InstallOtherMethod( AssignSetOfGeneratingMorphisms,
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  function( A )
    
    AssignSetOfGeneratingMorphisms( A, "" );
    
end );


##
InstallMethod( RelationsOfAlgebroid,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra ],
        
  function( A )
    local relations;
    
    relations := RelationsOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    relations := Filtered( relations, r -> not IsZero( r ) );
    
    return List( relations, a -> MorphismInAlgebroid( A, a ) );
    
end );

##
InstallMethod( BijectionBetweenPairsAndElementaryTensors,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( Qq )
    local Qqq, gens, prod;
    
    if HasPathAlgebra( Qq ) then
        Qq := PathAlgebra( Qq );
    fi;
    
    Qqq := TensorProductOfAlgebras( Qq, Qq );
    
    gens := PrimitivePaths( QuiverOfAlgebra( Qq ) );
    
    gens := Cartesian( gens, gens );
    
    prod := List( gens,
                  p -> ElementaryTensor(
                          PathAsAlgebraElement( Qq, p[1] ),
                          PathAsAlgebraElement( Qq, p[2] ),
                          Qqq ) );
    
    
    prod := List( prod, a -> Paths( Representative( a ) )[1] );
    
    return [ prod, gens ];
    
end );

##
InstallMethod( DecompositionOfMorphismInAlgebroid,
        "for a morphism in an algebroid",
        [ IsMorphismInAlgebroid ],
        
  function( mor )
    local B, func;
    
    B := CapCategory( mor );
    
    mor := UnderlyingQuiverAlgebraElement( mor );
    
    mor := DecomposeQuiverAlgebraElement( mor );
    
    func :=
      function( a )
        return List( a,
                     function( f )
                       f := B.(String( f ));
                       if IsCapCategoryObject( f ) then
                           return IdentityMorphism( f );
                       fi;
                       return f;
                     end );
        
      end;
    
    mor[2] := List( mor[2], func );
    
    return ListN( mor[1], mor[2], function( r, s ) return [ r, s ]; end );
    
end );

##
InstallMethod( DecompositionOfMorphismInSquareOfAlgebroid,
        "for a morphism in an algebroid",
        [ IsMorphismInAlgebroid ],
        
  function( mor )
    local B, Rq, gens, prod, func;
    
    B := CapCategory( mor )!.PowerOf;
    
    Rq := UnderlyingQuiverAlgebra( B );
    
    gens := BijectionBetweenPairsAndElementaryTensors( Rq );
    prod := gens[2];
    gens := gens[1];
    
    mor := UnderlyingQuiverAlgebraElement( mor );
    
    mor := DecomposeQuiverAlgebraElement( mor );
    
    mor[2] := List( mor[2], p -> List( p, a -> prod[Position( gens, a )] ) );
    
    func :=
      function( a )
        return List( a,
                     function( f )
                       f := B.(String( f ));
                       if IsCapCategoryObject( f ) then
                           return IdentityMorphism( f );
                       fi;
                       return f;
                     end );
        
      end;
    
    mor[2] := List( mor[2], p -> List( p, func ) );
    
    return ListN( mor[1], mor[2], function( r, s ) return [ r, s ]; end );
    
end );

####################################
#
# methods for operation:
#
####################################

##
InstallMethod( DecomposeQuiverAlgebraElement,
        "for a quiver algebra element",
        [ IsQuiverAlgebraElement ],
        
  function( p )
    
    if IsQuotientOfPathAlgebraElement( p ) then
        p := Representative( p );
    fi;
    
    return [ Coefficients( p ),
             List( Paths( p ),
                   function( a )
                     if Length( a ) = 0 then
                         return [ a ];
                     fi;
                     return ArrowList( a );
                   end ) ];
    
end );

##
InstallMethod( ApplyToQuiverAlgebraElement,
        "for an object function, a morphism function, a category, a quiver algebra element and a boolean",
        [ IsFunction, IsFunction, IsCapCategory, IsQuiverAlgebraElement, IsBool ],
        
  function( object_func, morphism_func, range_category, p, covariant )
    local applyF, paths, paths_final;
    
    # function to be applied to an arrow (or a vertex representing the trivial path at this vertex)
    applyF :=
      function( b )
        local m;
        
        if IsQuiverVertex( b ) then
            m := object_func( b );
            return IdentityMorphism( m );
        fi;
        
        return morphism_func( b );
        
    end;
    
    paths := DecomposeQuiverAlgebraElement( p )[2];
    
    if covariant then
        paths_final := List( paths, a -> PreCompose( List( a, applyF ) ) );
    else
        paths_final := List( paths, a -> PreCompose( Reversed( List( a, applyF ) ) ) );
    fi;
    
    return PreCompose( paths_final );
    
end );

##
InstallMethod( ApplyToQuiverAlgebraElement,
        "for an object function, a morphism function, a linear category, a quiver algebra element, and a boolean",
        [ IsFunction, IsFunction, IsCapCategory and IsLinearCategoryOverCommutativeRing, IsQuiverAlgebraElement, IsBool ],
        
  function( object_func, morphism_func, range_category, p, covariant )
    local applyF, paths, coefs, paths_final, s, all_objects_in_image;

    if IsZero( p ) then
        Error( "cannot handle the zero path algebra element, as it contains no information about its source and target\n" );
    fi;
    
    # function to be applied to an arrow (or a vertex representing the trivial path at this vertex)
    applyF :=
      function( b )
        local m;
        
        if IsQuiverVertex( b ) then
            m := object_func( b );
            return IdentityMorphism( m );
        fi;
        
        return morphism_func( b );
        
    end;
      
    paths := DecomposeQuiverAlgebraElement( p );
    
    coefs := paths[1];
    paths := paths[2];

    if covariant then
        paths_final := List( paths, a -> PreCompose( List( a, applyF ) ) );
    else
        paths_final := List( paths, a -> PreCompose( Reversed( List( a, applyF ) ) ) );
    fi;
    
    if Length( coefs ) > 0 then
        s := Sum( ListN( coefs, paths_final, function( r, p ) return r * p; end ) );
    fi;
    
    return s;
    
end );

##
InstallMethod( ApplyToQuiverAlgebraElement,
        "for a functor and a quiver algebra element",
        [ IsCapFunctor, IsQuiverAlgebraElement ],

  function( functor, p )
    local algebroid, func;
    
    algebroid := AsCapCategory( Source( functor ) );
    
    func := b -> ApplyFunctor( functor, algebroid.(String( b )) );
    
    if IsBound( functor!.IsContravariant ) and functor!.IsContravariant then
        return ApplyToQuiverAlgebraElement( func, func, AsCapCategory(Range(functor)), p, false );
    fi;
    
    return ApplyToQuiverAlgebraElement( func, func, AsCapCategory(Range(functor)), p, true );
    
end );

####################################
#
# methods for constructors:
#
####################################

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_ALGEBROID,
  
  function( category, over_Z )
    
    ##
    AddObjectConstructor( category,
      function( category, v )
        
        return ObjectInAlgebroid( category, v );
        
    end );
    
    ##
    AddObjectDatum( category,
      function( category, o )
        
        return UnderlyingVertex( o );
        
    end );
    
    ##
    AddMorphismConstructor( category,
      function( category, source, m, range )
        
        return MorphismInAlgebroid( category, source, m, range );
        
    end );
    
    ##
    AddMorphismDatum( category,
      function( category, m )
        
        return UnderlyingQuiverAlgebraElement( m );
        
    end );
    
    ##
    AddIsWellDefinedForObjects( category,
      function( category, o )
        
        o := UnderlyingVertex( o );
        
        return IsQuiverVertex( o ) and IsIdenticalObj( QuiverOfPath( o ), UnderlyingQuiver( category ) );
        
    end );
    
    ##
    AddIsWellDefinedForMorphisms( category,
      function( category, alpha )
        local m, v, w;
        
        m := UnderlyingQuiverAlgebraElement( alpha );
        
        if not IsIdenticalObj( AlgebraOfElement( m ), UnderlyingQuiverAlgebra( category ) ) then
            
            return false;
            
        fi;
        
        if IsZero( m ) then
            
            return true;
            
        fi;
        
        if not IsUniform( m ) then
            
            return false;
            
        fi;
        
        if IsQuotientOfPathAlgebraElement( m ) then
            
            m := Representative( m );
            
        fi;
        
        v := Source( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Source( alpha ) ) = v ) then
            
            return false;
            
        fi;
        
        w := Target( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Range( alpha ) ) = w ) then
            
            return false;
            
        fi;
        
        # all tests passed, so it is well-defined
        return true;
        
    end );
    
    ##
    AddIsEqualForObjects( category,
      function( category, object_1, object_2 )
        
        return UnderlyingVertex( object_1 ) = UnderlyingVertex( object_2 );
        
    end );
    
    ##
    AddIsEqualForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIdentityMorphism( category,
      function( category, object )
        local quiver_algebra, id;
        
        quiver_algebra := UnderlyingQuiverAlgebra( category );
        
        id := PathAsAlgebraElement( quiver_algebra, UnderlyingVertex( object ) );
        
        return MorphismInAlgebroid( category,
                       object,
                       id,
                       object );
        
    end );
    
    if IsRightQuiver( UnderlyingQuiver( category ) ) then
        
        ##
        AddPreCompose( category,
          function( category, morphism_1, morphism_2 )
            
            return MorphismInAlgebroid( category,
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_1 ) * UnderlyingQuiverAlgebraElement( morphism_2 ),
                           Range( morphism_2 ) );
            
        end );
        
    else
        
        ##
        AddPreCompose( category,
          function( category, morphism_1, morphism_2 )
            
            return MorphismInAlgebroid( category,
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_2 ) * UnderlyingQuiverAlgebraElement( morphism_1 ),
                           Range( morphism_2 ) );
            
        end );
        
    fi;
    
    ##
    AddAdditionForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return MorphismInAlgebroid( category,
                       Source( morphism_1 ),
                       UnderlyingQuiverAlgebraElement( morphism_1 ) + UnderlyingQuiverAlgebraElement( morphism_2 ),
                       Range( morphism_1 ) );
        
    end );
    
    ##
    AddAdditiveInverseForMorphisms( category,
      function( category, morphism )
        
        return MorphismInAlgebroid( category,
                       Source( morphism ),
                       -UnderlyingQuiverAlgebraElement( morphism ),
                       Range( morphism ) );
        
    end );
    
    ##
    AddMultiplyWithElementOfCommutativeRingForMorphisms( category,
      function( category, r, morphism )
        
        return MorphismInAlgebroid( category,
                       Source( morphism ),
                       r * UnderlyingQuiverAlgebraElement( morphism ),
                       Range( morphism ) );
        
    end );
    
    ##
    AddZeroMorphism( category,
      function( category, S, T )
        
        return MorphismInAlgebroid( category,
                       S,
                       Zero( UnderlyingQuiverAlgebra( category ) ),
                       T );
        
    end );
    
    AddIsZeroForMorphisms( category,
      function( category, morphism )
        
        return IsZero( UnderlyingQuiverAlgebraElement( morphism ) );
        
    end );
    
    ## only create the Hom-structure for finite dimensional quiver algebras
    if IsFiniteDimensional( UnderlyingQuiverAlgebra( category ) ) then
        
        ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_ALGEBROID( category, over_Z );
        
        ADD_FUNCTIONS_FOR_RANDOM_METHODS_OF_ALGEBROID( category, over_Z );
        
    fi;
    
    Finalize( category );
    
    SetFilterObj( IdentityFunctor( category ), IsAlgebroidMorphism );
    
    return category;
    
end );

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_ALGEBROID,
  function( algebroid, over_Z )
    local quiver_algebra, quiver, vertices, basis, basis_paths_by_vertex_index, maps, path,
          MATRIX_FOR_HOMSTRUCTURE, hom_structure_on_basis_paths,
          representative_func, ring, default_range_of_HomStructure, range_category,
          object_constructor, object_datum, morphism_constructor, morphism_datum;
    
    quiver_algebra := UnderlyingQuiverAlgebra( algebroid );
    
    ## Prepare quick access to basis elements
    quiver := QuiverOfAlgebra( quiver_algebra );
    
    vertices := Vertices( quiver );
    
    basis := BasisPaths( CanonicalBasis( quiver_algebra ) );
    
    ## prepare the homomorphism structure
    
    ## storing the basis paths
    ## basis_paths_by_vertex_index[ v_index ][ w_index ] = [ p_1:v -> w, p_2:v -> w, ... ]
    
    basis_paths_by_vertex_index := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    maps := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    for path in basis do
        
        Add( basis_paths_by_vertex_index[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], path );
        
        Add( maps[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], MorphismInAlgebroid( algebroid, PathAsAlgebraElement( quiver_algebra, path ) ) );
        
    od;
    
    # if `basis_paths_by_vertex_index` would be mutable, setting the attribute below would create an (immuatable) copy, which would not be identical to `basis_paths_by_vertex_index` anymore
    MakeImmutable( basis_paths_by_vertex_index );
    
    SetBasisPathsByVertexIndex( algebroid, basis_paths_by_vertex_index );
    
    Assert( 0, IsIdenticalObj( basis_paths_by_vertex_index, BasisPathsByVertexIndex( algebroid ) ) );
    
    ## precomputing matrices for the hom structure
    ## hom_structure_on_basis_paths[ v_index ][ w_index ][ v'_index ][ w'_index ][ basis_path_1_index ][ basis_path_2_index ] =
    ## [ Hom(v,w) -> Hom(v',w'): x -> basis_path_1 * x * basis_path_2 ]
    ## for basis_path_1: v' -> v and basis_path_2: w -> w'
    
    MATRIX_FOR_HOMSTRUCTURE := function( v, w, vp, wp, path_1, path_2 )
        local mat, hom_v_w, hom_vp_wp, alpha, beta, path;
        
        mat := [];
        
        hom_v_w := basis_paths_by_vertex_index[ VertexIndex( v ) ][ VertexIndex( w ) ];
        
        if IsEmpty( hom_v_w ) then
            
            return mat;
            
        fi;
        
        hom_vp_wp := basis_paths_by_vertex_index[ VertexIndex( vp ) ][ VertexIndex( wp ) ];
        
        if IsEmpty( hom_vp_wp ) then
            
            return mat;
            
        fi;
        
        alpha := PathAsAlgebraElement( quiver_algebra, path_1 );
        
        beta := PathAsAlgebraElement( quiver_algebra, path_2 );
        
        if IsQuotientOfPathAlgebra( quiver_algebra ) then
            
            for path in hom_v_w do
                
                Add( mat,
                  CoefficientsOfPaths( hom_vp_wp, Representative( alpha * PathAsAlgebraElement( quiver_algebra, path ) * beta ) )
                );
                
            od;
            
        else
            
            for path in hom_v_w do
                
                Add( mat,
                  CoefficientsOfPaths( hom_vp_wp, ( alpha * PathAsAlgebraElement( quiver_algebra, path ) * beta ) )
                );
                
            od;
            
        fi;
        
        return mat;
        
    end;
    
    hom_structure_on_basis_paths :=
        List( vertices, v ->
            List( vertices, w ->
                List( vertices, vp ->
                    List( vertices, wp ->
                        List( basis_paths_by_vertex_index[ VertexIndex( vp ) ][ VertexIndex( v ) ], basis_path_1 ->
                            List( basis_paths_by_vertex_index[ VertexIndex( w ) ][ VertexIndex( wp ) ], basis_path_2 ->
                                MATRIX_FOR_HOMSTRUCTURE( v, w, vp, wp, basis_path_1, basis_path_2 )
                            )
                        )
                    )
                )
            )
        );
    
    # if `hom_structure_on_basis_paths` would be mutable, setting the attribute below would create an (immuatable) copy, which would not be identical to `hom_structure_on_basis_paths` anymore
    MakeImmutable( hom_structure_on_basis_paths );
    
    SetHomStructureOnBasisPaths( algebroid, hom_structure_on_basis_paths );
    
    Assert( 0, IsIdenticalObj( hom_structure_on_basis_paths, HomStructureOnBasisPaths( algebroid ) ) );
    
    ##
    if IsQuotientOfPathAlgebra( quiver_algebra ) then
        
        representative_func := Representative;
        
    else
        
        representative_func := IdFunc;
        
    fi;
    
    ring := CommutativeRingOfLinearCategory( algebroid );
    
    if over_Z then
        
        if ValueOption( "no_precompiled_code" ) = true then
            
            default_range_of_HomStructure := CategoryOfRowsAsAdditiveClosureOfRingAsCategory( ring );
            
        else
            
            default_range_of_HomStructure := CategoryOfRows( ring );
            
        fi;
        
    else
        
        if ValueOption( "no_precompiled_code" ) = true then
            
            default_range_of_HomStructure := MatrixCategoryAsAdditiveClosureOfRingAsCategory( ring );
            
        else
            
            default_range_of_HomStructure := MatrixCategory( ring );
            
        fi;
        
    fi;
    
    range_category := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "range_of_HomStructure", default_range_of_HomStructure );
    
    if IsMatrixCategory( range_category ) then
        
        object_constructor := MatrixCategoryObject;
        object_datum := Dimension;
        morphism_constructor := VectorSpaceMorphism;
        morphism_datum := UnderlyingMatrix;
        
    elif IsCategoryOfRows( range_category ) then
        
        object_constructor := CategoryOfRowsObject;
        object_datum := RankOfObject;
        morphism_constructor := CategoryOfRowsMorphism;
        morphism_datum := UnderlyingMatrix;
        
    else
        
        Error( "range_of_HomStructure must be a matrix category or a category of rows" );
        
    fi;
    
    SetRangeCategoryOfHomomorphismStructure( algebroid, range_category );
    
    Assert( 0, IsIdenticalObj( RangeCategoryOfHomomorphismStructure( algebroid ), range_category ) );
    
    ##
    AddHomomorphismStructureOnObjects( algebroid,
      function( algebroid, object_1, object_2 )
        local nr_source, nr_range, basis_elements;
        
        nr_source := VertexIndex( UnderlyingVertex( object_1 ) );
        
        nr_range := VertexIndex( UnderlyingVertex( object_2 ) );
        
        basis_elements := BasisPathsByVertexIndex( algebroid )[nr_source][nr_range];
        
        return object_constructor( range_category, Length( basis_elements ) );
        
    end );
    
    ##
    AddHomomorphismStructureOnMorphismsWithGivenObjects( algebroid,
      function( algebroid, source, alpha, beta, range )
        local elem_alpha, elem_beta, a, b, ap, bp, basis_paths_by_vertex_index,
              basis_ap_a, basis_b_bp, size_source, size_range, coeffs_alpha, coeffs_beta, entries;
        
        elem_alpha := UnderlyingQuiverAlgebraElement( alpha );
        
        elem_beta := UnderlyingQuiverAlgebraElement( beta );
        
        a := VertexIndex( UnderlyingVertex( Range( alpha ) ) );
        
        b := VertexIndex( UnderlyingVertex( Source( beta ) ) );
        
        ap := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
        
        bp := VertexIndex( UnderlyingVertex( Range( beta ) ) );
        
        basis_paths_by_vertex_index := BasisPathsByVertexIndex( algebroid );
        
        basis_ap_a := basis_paths_by_vertex_index[ap][a];
        
        basis_b_bp := basis_paths_by_vertex_index[b][bp];
        
        # getting the sizes from `source` and `range` is more efficient for the compiler
        size_source := object_datum( source );
        size_range := object_datum( range );
        
        # the brackets allow the compiler to hoist the condition `IsZeroForMorphisms( algebroid, alpha ) or size_source = 0` more easily
        if (IsZeroForMorphisms( algebroid, alpha ) or size_source = 0) or (IsZeroForMorphisms( algebroid, beta ) or size_range = 0) then
            
            return ZeroMorphism( range_category, source, range );
            
        else
            
            ## These two lines need QPA in a dynamic way
            coeffs_alpha := CoefficientsOfPaths( basis_ap_a, elem_alpha );
            coeffs_beta := CoefficientsOfPaths( basis_b_bp, elem_beta );
            
            # If Length( basis_ap_a ) = 0 (resp. Length( basis_b_bp ) = 0), then alpha (resp. beta) must be zero,
            # and these cases are handled above -> we can ignore the empty cases here.
            entries := Sum(
                [ 1 .. Length( basis_ap_a ) ],
                p ->
                Sum(
                    [ 1 .. Length( basis_b_bp ) ],
                    q -> coeffs_alpha[p] * coeffs_beta[q] * hom_structure_on_basis_paths[ a ][ b ][ ap ][ bp ][ p ][ q ]
                )
            );
            
            return morphism_constructor( range_category, source, HomalgMatrixListList( entries, size_source, size_range, ring ), range );
            
        fi;
        
    end );
    
    ##
    AddDistinguishedObjectOfHomomorphismStructure( algebroid,
      function( algebroid )
        
        return object_constructor( range_category, 1 );
        
    end );
    
    ##
    AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( algebroid,
      function( algebroid, alpha )
        local a, b, basis_elements, size_basis, source, range, element;
        
        a := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
        
        b := VertexIndex( UnderlyingVertex( Range( alpha ) ) );
        
        basis_elements := BasisPathsByVertexIndex( algebroid )[a][b];
        
        size_basis := Length( basis_elements );
        
        source := DistinguishedObjectOfHomomorphismStructure( algebroid );
        range := HomomorphismStructureOnObjects( algebroid, Source( alpha ), Range( alpha ) );
        
        if size_basis = 0 then
            
            return ZeroMorphism( range_category, source, range );
            
        fi;
        
        element := UnderlyingQuiverAlgebraElement( alpha );
        
        return morphism_constructor(
                range_category,
                source,
                HomalgMatrixListList( [ CoefficientsOfPaths( basis_elements, representative_func( element ) ) ], 1, size_basis, ring ),
                range
              );
        
    end );
    
    ##
    AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( algebroid,
      function( algebroid, a, b, morphism )
        local coefficients, basis, element;
        
        coefficients := EntriesOfHomalgMatrixAsListList( morphism_datum( morphism ) )[1];
        
        basis := BasisPathsByVertexIndex( algebroid )[VertexIndex( UnderlyingVertex( a ) )][VertexIndex( UnderlyingVertex( b ) )];
        
        element := QuiverAlgebraElement( quiver_algebra, coefficients, basis );
        
        return MorphismInAlgebroid( algebroid, a, element, b );
        
    end );
    
    ## Both methods can be derived, but it is more efficient to add them as primitive methods.
    ##
    AddBasisOfExternalHom( algebroid,
      function( algebroid, object_1, object_2 )
        local nr_source, nr_range;
        
        nr_source := VertexIndex( UnderlyingVertex( object_1 ) );
        
        nr_range := VertexIndex( UnderlyingVertex( object_2 ) );
         
        return maps[nr_source][nr_range];
        
    end );
    
    ##
    AddCoefficientsOfMorphismWithGivenBasisOfExternalHom( algebroid,
    
      { algebroid, morphism, basis } -> CoefficientsOfMorphism( morphism )
    );
    
    ##
    InstallMethod( CoefficientsOfMorphism,
              [ IsMorphismInAlgebroid and MorphismFilter( algebroid ) ],
              
      function( morphism )
        local nr_source, nr_range, element;
       
        nr_source := VertexIndex( UnderlyingVertex( Source( morphism ) ) );
        
        nr_range := VertexIndex( UnderlyingVertex( Range( morphism ) ) );
        
        element := UnderlyingQuiverAlgebraElement( morphism );
        
        return CoefficientsOfPaths( BasisPathsByVertexIndex( algebroid )[nr_source][nr_range], representative_func( element ) );
        
    end );
    
    SetIsEquippedWithHomomorphismStructure( algebroid, true );
    
end );

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_RANDOM_METHODS_OF_ALGEBROID,
  function( A, over_Z )
    
    if over_Z then
      
      # to do
      return;
      
    else
      
      AddRandomObjectByInteger( A,
        { A, n } -> Random( SetOfObjects( A ) )
      );
      
      AddRandomMorphismWithFixedSourceByInteger( A,
        function( A, o, n )
          local objects, p, b;
          
          objects := Shuffle( ShallowCopy( SetOfObjects( A ) ) );
          
          p := PositionProperty( objects, obj -> not IsZero( HomStructure( o, obj ) ) );
          
          if p = fail then
              return Random( [ 0 .. AbsInt( n ) ] ) * One( UnderlyingAlgebra( A ) ) * IdentityMorphism( o );
          fi;
          
          b := BasisOfExternalHom( o, objects[ p ] );
          
          return Sum( List( [ 0 .. AbsInt( n ) ], i -> Random( b ) ) );
          
      end );
      
      AddRandomMorphismWithFixedRangeByInteger( A,
        function( A, o, n )
          local objects, p, b;
          
          objects := Shuffle( ShallowCopy( SetOfObjects( A ) ) );
          
          p := PositionProperty( objects, obj -> not IsZero( HomStructure( obj, o ) ) );
          
          if p = fail then
              return Random( [ 0 .. AbsInt( n ) ] ) * One( UnderlyingAlgebra( A ) ) * IdentityMorphism( o );
          fi;
          
          b := BasisOfExternalHom( objects[ p ], o );
          
          return Sum( List( [ 0 .. AbsInt( n ) ], i -> Random( b ) ) );
          
      end );
      
      AddRandomMorphismWithFixedSourceAndRangeByInteger( A,
        function( A, s, r, n )
          local b;
          
          b := BasisOfExternalHom( s, r );
          
          if IsEmpty( b ) then
              return ZeroMorphism( s, r );
          fi;
          
          return Sum( List( [ 0 .. AbsInt( n ) ], i -> Random( b ) ) );
          
      end );
      
    fi;
    
end );

BindGlobal( "ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidPrecompiled", function ( cat )
  local A, Rq, is_finite_dimensional, is_path_algebra, is_right_quiver, over_field;
    
    Assert( 0, IsAdditiveClosureCategory( cat ) );
    
    A := UnderlyingCategory( cat );
    
    Assert( 0, IsAlgebroid( A ) );
    
    Rq := UnderlyingQuiverAlgebra( A );
    
    is_finite_dimensional := IsFiniteDimensional( Rq );
    
    is_path_algebra := IsPathAlgebra( Rq );
    
    is_right_quiver := IsRightQuiver( QuiverOfAlgebra( Rq ) );
    
    over_field := not A!.over_Z;
    
    if is_finite_dimensional and is_path_algebra and is_right_quiver and over_field and IsMatrixCategory( RangeCategoryOfHomomorphismStructure( A ) ) then
        
        ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidOfFiniteDimensionalPathAlgebraOfRightQuiverOverFieldPrecompiled( cat );
        
        return true;
        
    elif is_finite_dimensional and not is_path_algebra and is_right_quiver and over_field and IsMatrixCategory( RangeCategoryOfHomomorphismStructure( A ) ) then
        
        Assert( 0, IsQuotientOfPathAlgebra( Rq ) );
        
        ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidOfFiniteDimensionalQuotientOfPathAlgebraOfRightQuiverOverFieldPrecompiled( cat );
        
        return true;
        
    elif is_finite_dimensional and is_path_algebra and is_right_quiver and not over_field and IsCategoryOfRows( RangeCategoryOfHomomorphismStructure( A ) ) then
        
        ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidOfFiniteDimensionalPathAlgebraOfRightQuiverOverZPrecompiled( cat );
        
        return true;
        
    elif is_finite_dimensional and not is_path_algebra and is_right_quiver and not over_field and IsCategoryOfRows( RangeCategoryOfHomomorphismStructure( A ) ) then
        
        Assert( 0, IsQuotientOfPathAlgebra( Rq ) );
        
        ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidOfFiniteDimensionalQuotientOfPathAlgebraOfRightQuiverOverZPrecompiled( cat );
        
        return true;
        
    else
        
        return false;
        
    fi;
    
end );

BindGlobal( "ADD_FUNCTIONS_FOR_AdelmanCategoryOfAdditiveClosureOfAlgebroidPrecompiled", function ( cat )
  local Add, A, Rq, is_finite_dimensional, is_path_algebra, is_right_quiver, over_field;
    
    Assert( 0, IsAdelmanCategory( cat ) );
    
    Add := UnderlyingCategory( cat );
    
    Assert( 0, IsAdditiveClosureCategory( Add ) );
    
    A := UnderlyingCategory( Add );
    
    Assert( 0, IsAlgebroid( A ) );
    
    Rq := UnderlyingQuiverAlgebra( A );
    
    is_finite_dimensional := IsFiniteDimensional( Rq );
    
    is_path_algebra := IsPathAlgebra( Rq );
    
    is_right_quiver := IsRightQuiver( QuiverOfAlgebra( Rq ) );
    
    over_field := not A!.over_Z;
    
    if is_finite_dimensional and is_path_algebra and is_right_quiver and not over_field and IsCategoryOfRows( RangeCategoryOfHomomorphismStructure( A ) ) then
        
        ADD_FUNCTIONS_FOR_AdelmanCategoryOfAdditiveClosureOfAlgebroidOfFiniteDimensionalPathAlgebraOfRightQuiverOverZPrecompiled( cat );
        
        return true;
        
    else
        
        return false;
        
    fi;
    
end );

##
InstallMethod( Algebroid,
        "for a QPA quiver algebra and a boolean",
        [ IsQuiverAlgebra, IsBool ],
        
  function( Rq, over_Z )
    local domain, paths, p, q, parity, quiver, A;
    
    domain := LeftActingDomain( Rq );
    
    if over_Z then
        
        if IsIdenticalObj( domain, Rationals )
           or
           ( HasIsRationalsForHomalg( domain ) and IsRationalsForHomalg( domain )
             and not IsHomalgExternalRingRep( domain ) )
        then
            
            ## Test if the multiplication table which is induced by the basis of the quiver algebra
            ## (computed by the Groebner basis) only has integral coefficients.
            paths := BasisPaths( CanonicalBasis( Rq ) );
            
            for p in paths do
                
                for q in paths do
                    
                    if not ForAll( Coefficients( PathAsAlgebraElement( Rq, p ) * PathAsAlgebraElement( Rq, q ) ), IsInt ) then
                        
                        Error( "the basis of the given quiver algebra does give rise to a well-defined algebroid over Z\n");
                        
                    fi;
                    
                od;
                
            od;
            
        else
            
            Error( "the left acting domain of the given quiver algebra is not supported for constructing an algebroid of the integers\n");
            
        fi;
        
    fi;
    
    if IsRightQuiverAlgebra( Rq ) then
        parity := "Right";
    else
        parity := "Left";
    fi;
    
    quiver := QuiverOfAlgebra( Rq );

    if Length( Vertices( quiver ) ) > 1 then
        A := "Algebroid( ";
    else
        A := "Algebra( ";
    fi;
    
    if over_Z then
        A := Concatenation( A, "Z, " );
    else
        A := Concatenation( A, RingName( domain ), ", " );
    fi;
    
    A := Concatenation( A, "FreeCategory( ", parity, "Quiver( \"", String( quiver ), "\" ) ) )" );
    
    if not IsPathAlgebra( Rq ) then
        A := Concatenation( A, " / relations" );
    fi;
    
    A := CreateCapCategory( A );
    
    A!.category_as_first_argument := true;
    
    A!.compiler_hints :=
      rec( category_attribute_names :=
           [ "SetOfObjects",
             "SetOfGeneratingMorphisms",
             "UnderlyingQuiverAlgebra",
             "BasisPathsByVertexIndex",
             "HomStructureOnBasisPaths",
             ],
        category_filter := IsAlgebroid,
        object_filter := IsObjectInAlgebroid,
        morphism_filter := IsMorphismInAlgebroid,
        precompiled_towers := [
            rec(
                remaining_constructors_in_tower := [ "AdditiveClosure" ],
                precompiled_functions_adder := ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidPrecompiled
            ),
            rec(
                remaining_constructors_in_tower := [ "AdditiveClosure", "AdelmanCategory" ],
                precompiled_functions_adder := ADD_FUNCTIONS_FOR_AdelmanCategoryOfAdditiveClosureOfAlgebroidPrecompiled
            ),
        ],
    );
    
    DeactivateCachingOfCategory( A );
    CapCategorySwitchLogicOff( A );
    DisableSanityChecks( A );
    
    AddObjectRepresentation( A, IsObjectInAlgebroid );
    AddMorphismRepresentation( A, IsMorphismInAlgebroid );
    
    SetIsAbCategory( A, true );
    SetIsLinearCategoryOverCommutativeRing( A, true );
    
    SetIsFinitelyPresentedLinearCategory( A, true );
    SetUnderlyingQuiver( A, quiver );
    SetUnderlyingAlgebra( A, domain );
    SetParity( A, parity );
    
    if over_Z then
        SetCommutativeRingOfLinearCategory( A, HomalgRingOfIntegers() );
    else
        SetCommutativeRingOfLinearCategory( A, LeftActingDomain( Rq ) );
    fi;
    A!.over_Z := over_Z;
    
    SetUnderlyingQuiverAlgebra( A, Rq );
    SetFilterObj( A, IsAlgebroid );
    if Length( Vertices( quiver ) ) = 1 then
        SetFilterObj( A, IsAlgebraAsCategory );
    fi;
    
    A!.Vertices := rec( );
    A!.Arrows := rec( );
    
    return ADD_FUNCTIONS_FOR_ALGEBROID( A, over_Z );
    
end );

##
InstallMethod( Algebroid,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( A )
    
    return Algebroid( A, false );
    
end );

##
InstallMethod( Algebroid,
        "for a QPA path algebra, a list, and a boolean",
        [ IsQuiverAlgebra, IsList, IsBool ],
        
  function( Rq, L, over_Z )
    local path;
    
    for path in L do
        if not IsUniform( path ) then
            Error( "only uniform relations are admissible, while the path algebra element ", path, " is not uniform\n" );
        fi;
    od;
    
    L := Filtered( L, r -> not IsZero( r ) );
    
    return Algebroid( Rq / Ideal( Rq, L ), over_Z );
    
end );

##
InstallMethod( Algebroid,
        "for a QPA path algebra and a list",
        [ IsQuiverAlgebra, IsList ],
        
  function( Rq, L )
    
    return Algebroid( Rq, L, false );
    
end );

##
InstallMethod( Algebroid,
        "for a homalg ring and a QPA quiver",
        [ IsHomalgRing, IsQuiver ],
        
  function( R, quiver )
    
    return Algebroid( PathAlgebra( R, quiver ) );
    
end );

##
InstallMethodWithCache( Algebroid,
        "for a homalg ring and a finitely presented category",
        [ IsHomalgRing, IsFpCategory ],
        
  function( k, C )
    local relations, kq, A, over_Z;
    
    relations := C!.relations;
    
    if relations = [ ] and not IsPathAlgebra( UnderlyingQuiverAlgebra( C ) ) then
        Error( "the underlying quiver algebra is not a path algebra, nevertheless the list of relations is empty\n" );
    fi;
    
    if HasIsIntegersForHomalg( k ) and IsIntegersForHomalg( k ) then
        k := HomalgFieldOfRationals( );
        over_Z := true;
    else
        over_Z := false;
    fi;
    
    kq := PathAlgebra( k, UnderlyingQuiver( C ) );
    
    relations := List( relations, a -> PathAsAlgebraElement( kq, a[1] ) - PathAsAlgebraElement( kq, a[2] ) );
    
    A := kq / Ideal( kq, relations );
    
    A := kq / GroebnerBasis( IdealOfQuotient( A ) );
    
    A := Algebroid( A, over_Z ); ## do not call the single argument method Algebroid as it is an attribute
    
    SetUnderlyingCategory( A, C );
    
    SetIsLinearClosureOfACategory( A, true );
    
    return A;
    
end );

##
InstallMethodWithCache( Algebroid,
        "for a finitely presented category and a category",
        [ IsFpCategory, IsCapCategory ],
        
  function( C, H )
    local relations, k, kq, A, over_Z;
    
    relations := C!.relations;
    
    if relations = [ ] and not IsPathAlgebra( UnderlyingQuiverAlgebra( C ) ) then
        Error( "the underlying quiver algebra is not a path algebra, nevertheless the list of relations is empty\n" );
    fi;
    
    k := CommutativeRingOfLinearCategory( H );
    
    if HasIsIntegersForHomalg( k ) and IsIntegersForHomalg( k ) then
        k := HomalgFieldOfRationals( );
        over_Z := true;
    else
        over_Z := false;
    fi;
    
    kq := PathAlgebra( k, UnderlyingQuiver( C ) );
    
    relations := List( relations, a -> PathAsAlgebraElement( kq, a[1] ) - PathAsAlgebraElement( kq, a[2] ) );
    
    A := kq / Ideal( kq, relations );
    
    A := kq / GroebnerBasis( IdealOfQuotient( A ) );
    
    A := Algebroid( A, over_Z : range_of_HomStructure := H ); ## do not call the single argument method Algebroid as it is an attribute
    
    SetUnderlyingCategory( A, C );
    
    SetIsLinearClosureOfACategory( A, true );
    
    return A;
    
end );

##
InstallMethod( \[\],
        "for a homalg ring and a finitely presented category",
        [ IsHomalgRing, IsFpCategory ],
        
  Algebroid );

##
InstallMethod( \/,
        "for an algebroid and a list",
        [ IsAlgebroid, IsList ],

  function( A, relations )
    
    return Algebroid( UnderlyingQuiverAlgebra( A ), List( relations, UnderlyingQuiverAlgebraElement ), A!.over_Z );
    
end );

##
InstallMethod( DescentToZDefinedByBasisPaths,
        "for an algebroid",
        [ IsAlgebroid ],
        
  function( A )
    
    return Algebroid( UnderlyingQuiverAlgebra( A ), true );
    
end );

##
InstallMethod( Multiplication,
        "for a commutative algebra as cateogry",
        [ IsAlgebraAsCategory and IsCommutative ],
        
  function( A )
    local unique_object_in_A, unique_object_in_A_string,
          morphisms_in_A, A2, unique_object_in_A2, unique_object_in_A2_string,
          mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms,
          a, b, axg, axg_string, fxb, fxb_string, mult_functor, g, f;

    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    morphisms_in_A := SetOfGeneratingMorphisms(A);

    A2 := A*A;
    
    unique_object_in_A2 := SetOfObjects( A2 )[1];
    unique_object_in_A2_string := String( UnderlyingVertex( unique_object_in_A2 ) );
    
    mult_functor_images_of_objects := rec( );
    mult_functor_images_of_objects.(unique_object_in_A2_string) := unique_object_in_A;

    mult_functor_images_of_generating_morphisms := rec(); # FIXME

    a := unique_object_in_A;
    b := unique_object_in_A;

    for g in morphisms_in_A do

        axg := ElementaryTensor( a, g, A2 );
        axg_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( axg ) ) ) );

        mult_functor_images_of_generating_morphisms.(axg_string) := g;

    od;

    for f in morphisms_in_A do

        fxb := ElementaryTensor( f, b, A2 );
        fxb_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( fxb ) ) ) );

        mult_functor_images_of_generating_morphisms.(fxb_string) := f;

    od;
    
    mult_functor := CapFunctor( A2, mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms );
    
    return mult_functor;

end );

##
InstallMethod( Unit,
        "for algebra as category",
        [ IsAlgebraAsCategory ],
        
  function( A )
    local unique_object_in_A, unique_object_in_A_string,
          unique_object_in_A0, unique_object_in_A0_string,
          unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms, A0;
    
    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    
    A0 := A^0;
    
    unique_object_in_A0 := SetOfObjects( A0 )[1];
    unique_object_in_A0_string := String( UnderlyingVertex( unique_object_in_A0 ) );
    
    unit_functor_images_of_objects := rec( );
    unit_functor_images_of_objects.(unique_object_in_A0_string) := unique_object_in_A;
    unit_functor_images_of_generating_morphisms := rec( );
    
    return CapFunctor(A0, unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms );
end );

##
InstallMethod( ObjectInAlgebroid,
         "for an algebroid and a vertex of a quiver",
        [ IsAlgebroid, IsQuiverVertex ],
        
  function( A, v )
    local o, name;
    
    o := rec( );
    
    name := String( v );
    
    ObjectifyObjectForCAPWithAttributes(
            o, A,
            UnderlyingVertex, v,
            Label, name );
    
    A!.Vertices.(name) := o;
    
    return o;
    
end );

##
InstallOtherMethodForCompilerForCAP( MorphismInAlgebroid,
                                     "for an algebroid, two objects in this algebroid and an element of the quiver algebra",
                                     [ IsAlgebroid, IsObjectInAlgebroid, IsQuiverAlgebraElement, IsObjectInAlgebroid ],
                                     
  function( A, S, path, T )
    local l;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    if not IsZero( path ) then
        
        if not IsUniform( path ) then
            Error( "the quiver algebra element ", path, " is neither zero nor uniform\n" );
        fi;
        
        ## TODO: we are avoiding for the moment the sanity test for
        ## elements of path algebras with relations, this should be
        ## reintroduced in the future
        if IsPathAlgebraElement( path ) then
            l := LeadingPath( path );
        
            if not ( Source( l ) = UnderlyingVertex( S ) ) and not ( Target( l ) = UnderlyingVertex( T ) ) then
                Error( "the path algebra element ", path, " is not zero, it does not match the given source S and it does not match the given target T\n" );
            elif not ( Source( l ) = UnderlyingVertex( S ) ) then
                Error( "the path algebra element ", path, " is not zero and it does not match the given source S\n" );
            elif not ( Target( l ) = UnderlyingVertex( T ) ) then
                Error( "the path algebra element ", path, " is not zero and it does not match the given target T\n" );
            fi;
        fi;
        
    fi;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    CAP_INTERNAL_ASSERT_IS_OBJECT_OF_CATEGORY( S, A, {} -> "the source given to MorphismInAlgebroid" );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    CAP_INTERNAL_ASSERT_IS_OBJECT_OF_CATEGORY( T, A, {} -> "the range given to MorphismInAlgebroid" );
    
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes(
        rec( ), A,
        S, T,
        UnderlyingQuiverAlgebraElement, path
    );
    
end );

##
InstallMethod( MorphismInAlgebroid,
               "for two objects in an algebroid and an element of the quiver algebra",
               [ IsObjectInAlgebroid, IsQuiverAlgebraElement, IsObjectInAlgebroid ],
               
  function( S, path, T )
    
    return MorphismInAlgebroid( CapCategory( S ), S, path, T );
    
end );

##
InstallMethod( \.,
        "for an algebroid and a positive integer",
        [ IsAlgebroid, IsPosInt ],
        
  function( B, string_as_int )
    local name, q, a, b;
    
    name := NameRNam( string_as_int );
    
    q := UnderlyingQuiver( B );
    
    a := q.(name);
    
    if IsQuiverVertex( a ) then
        if IsBound( B!.Vertices.(name) ) then
            return B!.Vertices.(name);
        fi;
        b := ObjectInAlgebroid( B, a );
    elif IsArrow( a ) or IsCompositePath( a ) then
        if IsBound( B!.Arrows.(name) ) then
            return B!.Arrows.(name);
        fi;
        b := MorphismInAlgebroid(
                     B.(String( Source( a ) ) ),
                     PathAsAlgebraElement( UnderlyingQuiverAlgebra( B ), a ),
                     B.(String( Target( a ) ) ) );
        SetLabel( b, name );
        B!.Arrows.(name) := b;
    else
        Error( "the given component ", name, " is neither a vertex nor an arrow of the quiver q = ", q, "\n" );
    fi;
    
    return b;
    
end );

##
InstallMethod( MorphismInAlgebroid,
        "for an algebroid and an element of a path algebra",
        [ IsAlgebroid, IsPathAlgebraElement ],
        
  function( A, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the path algebra element ", path, " is not uniform\n" );
    fi;
    
    l := LeadingPath( path );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInAlgebroid( A, A.(S), path, A.(T) );
    
end );

##
InstallOtherMethod( \/,
        [ IsPathAlgebraElement, IsAlgebroid ],
        
  function( path, A )
    
    return MorphismInAlgebroid( A, path );
    
end );

##
InstallMethod( MorphismInAlgebroid,
        "for an algebroid and an element of a quotient of a path algebra",
        [ IsAlgebroid, IsQuotientOfPathAlgebraElement ],
        
  function( A, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is not uniform\n" );
    fi;
    
    l := LeadingPath( Representative( path ) );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInAlgebroid( A, A.(S), path, A.(T) );
    
end );

##
InstallOtherMethod( \/,
        [ IsQuotientOfPathAlgebraElement, IsAlgebroid ],
        
  function( path, A )
    
    return MorphismInAlgebroid( A, path );
    
end );

##
InstallMethod( POW,
        "for an algebroid and an integer",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra, IsInt ],
        
  function( A, n )
    local Rq, R, parity;
    
    if n < 0 then
        Error( "the only admissible values for n are non-negative integers\n" );
    elif n = 1 then
        return A;
    elif not IsBound( A!.powers ) then
        A!.powers := rec( );
    fi;
    
    Rq := UnderlyingQuiverAlgebra( A );
    
    R := LeftActingDomain( Rq );
    
    if n = 0 then
        
        if not IsBound( A!.powers.0 ) then
            
            if IsRightQuiverAlgebra( Rq ) then
                parity := "Right";
            else
                parity := "Left";
            fi;
            
            A!.powers.0 := TrivialAlgebroid( R, parity );
            
        fi;
        
        return A!.powers.0;
        
    fi;
    
    A!.powers.1 := A;
    
    if not IsBound( A!.powers.(n) ) then
        if not IsBound( A!.powers.(n-1) ) then
            A!.powers.(n-1) := A^(n-1);
        fi;
        
        A!.powers.(n) := A!.powers.(n-1) * A;
        
        A!.powers.(n)!.PowerOf := A;
        
    fi;
    
    return A!.powers.(n);
    
end );

##
InstallMethod( TrivialAlgebroid,
        "for a homalg ring and a string",
        [ IsHomalgRing, IsString ],
        
  function( R, parity )
    local trivial_quiver;
    
    if parity = "Right" then
        trivial_quiver := RightQuiver( "*(1)[]" );
    elif parity = "Left" then
        trivial_quiver := LeftQuiver( "*(1)[]" );
    else
        Error( "parity must be either \"Left\" or \"Right\"" );
    fi;
    
    return Algebroid( PathAlgebra( R, trivial_quiver ) );
    
end );

##
InstallMethod( ElementaryTensor,
        "for objects in algebroids",
        [ IsObjectInAlgebroid, IsObjectInAlgebroid, IsAlgebroid ],
        
  function( a, b, T )
    local product_string, a_string, b_string, product_vertex;
    
    product_vertex := PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ UnderlyingVertex( a ), UnderlyingVertex( b ) ] );
    product_string := String(product_vertex);
    
    return T.(product_string);
    
end );

##
InstallMethod( ElementaryTensor,
        "for object and morphism in algebroids",
        [ IsObjectInAlgebroid, IsMorphismInAlgebroid, IsAlgebroid ],
        
  function( object, morphism, T )
    local source, range, morphism_as_quiver_algebra_element, paths, coeffs,
          object_underlying_vertex, object_string, sum, i, arrows_of_path,
          mors, o, product_of_arrows_as_morphism;
    
    source := ElementaryTensor( object, Source( morphism ), T );
    range := ElementaryTensor( object, Range( morphism ), T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then
        
        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );
        
    fi;
    
    if IsZero( morphism_as_quiver_algebra_element ) then
        
        return ZeroMorphism( source, range );
        
    fi;
    
    paths := Paths( morphism_as_quiver_algebra_element );
    coeffs := Coefficients( morphism_as_quiver_algebra_element );
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    sum := ZeroMorphism( source, range );
    
    for i in [ 1 .. Length( paths ) ] do
        
        arrows_of_path := ArrowList( paths[i] );
        
        mors := List( List( arrows_of_path,
                        b -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ object_underlying_vertex, b ] ) ),
                      b -> MorphismInAlgebroid(
                              ObjectInAlgebroid( T, Source( b ) ),
                              QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ b ] ),
                              ObjectInAlgebroid( T, Target( b ) ) ) );
        
        if Length( mors ) = 0 then
            
            Assert( 3, IsQuiverVertex( paths[i] ) );
            
            o := ObjectInAlgebroid( CapCategory( morphism ), paths[i] );
            
            Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
                
            product_of_arrows_as_morphism := IdentityMorphism( ElementaryTensor( object, o, T ) );
            
        else
            
            product_of_arrows_as_morphism := PreCompose( mors );
            
        fi;
        
        sum := sum + coeffs[i] * product_of_arrows_as_morphism;
        
    od;
    
    return sum;
    
end );

##
InstallMethod( ElementaryTensor,
        "for morphism and object in algebroids",
        [ IsMorphismInAlgebroid, IsObjectInAlgebroid, IsAlgebroid ],
        
  function( morphism, object, T )
    local source, range, morphism_as_quiver_algebra_element, coeffs, paths,
          object_underlying_vertex, object_string, sum, i, arrows_of_path,
          mors, o, product_of_arrows_as_morphism;
    
    source := ElementaryTensor( Source( morphism ), object, T );
    range := ElementaryTensor( Range( morphism ), object, T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then
        
        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );
        
    fi;
    
    if IsZero( morphism_as_quiver_algebra_element ) then
        
        return ZeroMorphism( source, range );
        
    fi;
    
    paths := Paths( morphism_as_quiver_algebra_element );
    coeffs := Coefficients( morphism_as_quiver_algebra_element );
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    sum := ZeroMorphism( source, range );
    
    for i in [ 1 .. Length( paths ) ] do
        
        arrows_of_path := ArrowList( paths[ i ] );
        
        mors := List( List( arrows_of_path,
                        a -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ a, object_underlying_vertex ] ) ),
                      a -> MorphismInAlgebroid(
                              ObjectInAlgebroid( T, Source( a ) ),
                              QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ a ] ),
                              ObjectInAlgebroid( T, Target( a ) ) ) );
        
        if Length( mors ) = 0 then
            
            Assert( 3, IsQuiverVertex( paths[i] ) );
            
            o := ObjectInAlgebroid( CapCategory( morphism ), paths[i] );
            
            Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
            
            product_of_arrows_as_morphism := IdentityMorphism( ElementaryTensor( o, object, T ) );
            
        else
            
            product_of_arrows_as_morphism := PreCompose( mors );
            
        fi;
        
        sum := sum + coeffs[i] * product_of_arrows_as_morphism;
        
    od;
    
    return sum;
    
end );

##
InstallMethod( \*,
        "for two algebroids",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra, IsAlgebroid and HasUnderlyingQuiverAlgebra ],
        
  function( A, B )

    return Algebroid( TensorProductOfAlgebras( UnderlyingQuiverAlgebra( A ), UnderlyingQuiverAlgebra( B ) ) );
    
end );

##
InstallMethod( CapFunctor,
        "for an algebroid, two lists, a CAP Category, and a boolean",
        [ IsAlgebroid, IsList, IsList, IsCapCategory, IsBool ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B, covariant )
    local kq, vertices, arrows, functor, func_obj, func_mor;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    arrows := Arrows( kq );
    
    functor := Concatenation( "Functor from ", Name( A ), " -> ", Name( B ) );
    
    functor := CapFunctor( functor, A, B );
    
    functor!.ValuesOnAllObjects := images_of_objects;
    functor!.ValuesOnAllGeneratingMorphisms := images_of_generating_morphisms;
    
    functor!.IsContravariant := not covariant;
    
    DeactivateCachingObject( ObjectCache( functor ) );
    DeactivateCachingObject( MorphismCache( functor ) );
    
    SetFilterObj( functor, IsAlgebroidMorphism );
    
    AddObjectFunction( functor,
      function( obj )
        local i;
        
        i := SafePosition( vertices, UnderlyingVertex( obj ) );
        
        if IsInt( i ) then
            return images_of_objects[i];
        fi;
        
        Error( "vertex UnderlyingVertex( obj ) = ", UnderlyingVertex( obj ), " not found in the list ", vertices, " of vertices\n" );
        
    end );
    
    func_obj := o -> images_of_objects[SafePosition( vertices, o )];
    func_mor := a -> images_of_generating_morphisms[SafePosition( arrows, a )];
    
    if covariant then
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            if IsZero( mor ) then
                return ZeroMorphism( new_source, new_range );
            fi;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_generating_morphisms[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, true );
            
        end );
        
    else
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            if IsZero( mor ) then
                return ZeroMorphism( new_source, new_range );
            fi;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_objects[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, false );
            
        end );
        
    fi;
    
    return functor;
    
end );

##
InstallMethod( CapFunctor,
        "for an algebroid, two lists, and a CAP category",
        [ IsAlgebroid, IsList, IsList, IsCapCategory ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B )
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, true );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for an algebroid, two records, and a boolean",
        [ IsAlgebroid, IsRecord, IsRecord, IsBool ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms, covariant )
    local kq, vertices, images_of_objects, arrows, images_of_generating_morphisms,
          mor, Rq, B;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    
    images_of_objects := List( vertices, v -> rec_images_of_objects.(String( v ) ) );
    
    if images_of_objects = [ ] then
        Error( "the record rec_images_of_objects does not contain a named image of an object in the source category A\n" );
    fi;
    
    arrows := Arrows( kq );
    
    images_of_generating_morphisms := List( arrows, a -> rec_images_of_generating_morphisms.(String( a ) ) );
    
    # Construct the target category B
    if not IsEmpty( images_of_generating_morphisms ) then
        for mor in images_of_generating_morphisms do
            if IsQuiverAlgebraElement( mor ) then
                Rq := AlgebraOfElement( mor );
                B := Algebroid( Rq );
                break;
            elif IsCapCategoryCell( mor ) then
                if not IsCapCategoryMorphism( mor ) then
                    Error( Concatenation( "the image ", mor, " is not a morphism"));
                fi;
                B := CapCategory( mor );
                break;
            fi;
        od;
    else
        B := CapCategory( images_of_objects[1] );
    fi;
    
    if not IsBound( B ) then
        Error( "unable to extract target category from the records of images\n" );
    fi;
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, covariant );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for an algebroid and two records",
        [ IsAlgebroid, IsRecord, IsRecord ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms )
    
    return CapFunctor( A, rec_images_of_objects, rec_images_of_generating_morphisms, true );
    
end );

##
InstallMethod( CapFunctor,
        "for an algebroid and a CAP category object",
        [ IsFpCategory, IsCapCategoryObject ],
        
  function( A, object )
    
    return CapFunctor(
                   A,
                   ListWithIdenticalEntries( Length( SetOfObjects( A ) ), object ),
                   ListWithIdenticalEntries( Length( SetOfGeneratingMorphisms( A ) ), IdentityMorphism( object ) ),
                   CapCategory( object ) );
    
end );

##
InstallMethod( OppositeAlgebroid,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  function( A )
    local ring, over_Z, range_category, A_op;
    
    ring := CommutativeRingOfLinearCategory( A );
     
    if IsIntegers( ring ) or ( HasIsIntegersForHomalg( ring ) and IsIntegersForHomalg( ring ) ) then
        over_Z := true;
    else
        over_Z := false;
    fi;
    
    if HasRangeCategoryOfHomomorphismStructure( A ) then
        range_category := RangeCategoryOfHomomorphismStructure( A );
    else
        range_category := fail;
    fi;
    
    A_op := Algebroid(
                    OppositeAlgebra( UnderlyingQuiverAlgebra( A ) ),
                    over_Z : range_of_HomStructure := range_category
                    );
    
    SetOppositeAlgebroid( A_op, A );
    
    return A_op;
    
end );

####################################
#
# methods for properties:
#
####################################

##
InstallMethod( IsCommutative,
        "for an Algebroid",
        [ IsAlgebroid ],
     
  function( A )
    local arrows, i, j;
    
    arrows := Arrows( UnderlyingQuiverAlgebra( A ) );
    
    for i in [ 1 .. Length(arrows) ] do
      for j in [ (i+1) .. Length(arrows) ] do
        if not arrows[i]*arrows[j] = arrows[j]*arrows[i] then
          return false;
        fi;
      od;
    od;
    
    return true;
end );

##
InstallMethod( NaturalTransformation,
        "for a list and two CAP functors",
        [ IsCapFunctorRep, IsList, IsCapFunctorRep ],
        
  function( F, images, G )
    local eta, vertices;
    
    eta := NaturalTransformation( Concatenation( "Natural transformation from ", Name( F ), " -> ", Name( G ) ), F, G );
    
    eta!.ValuesOnAllObjects := images;
    
    vertices := Vertices( QuiverOfAlgebra( UnderlyingQuiverAlgebra( AsCapCategory( Source( F ) ) ) ) );
    
    AddNaturalTransformationFunction( eta,
      function( source, obj, range )
        local pos;
        
        pos := SafePosition( vertices, UnderlyingVertex( obj ) );
        
        if not IsInt( pos ) then
            Error( "vertex UnderlyingVertex( obj ) = ", UnderlyingVertex( obj ), " not found in the list ", vertices, " of vertices\n" );
        fi;
        
        return images[pos];
        
    end );
    
    return eta;
    
end );

##
InstallMethod( NaturalTransformation,
        "for a record and two CAP functors",
        [ IsRecord, IsCapFunctorRep, IsCapFunctorRep ],
        
  function( eta, F, G )
    local vertices, images;
    
    if NamesOfComponents( F ) = [ ] then
        Error( "the record of images is empty\n" );
    fi;
    
    vertices := Vertices( QuiverOfAlgebra( UnderlyingQuiverAlgebra( AsCapCategory( Source( F ) ) ) ) );
    
    images := List( vertices, v -> eta.(String( v ) ) );
    
    return NaturalTransformation( F, images, G );
    
end );

##
InstallMethod( POW,
        "for a CAP endomorphism and an integer",
        [ IsCapCategoryMorphism, IsInt ],

  function( phi, i )
    
    if not IsEndomorphism( phi ) then
        TryNextMethod( );
    elif i = 0 then
        return IdentityMorphism( Source( phi ) );
    elif i < 0 then
        if not IsIsomorphism( phi ) then
            Error( "the given endomorphism is not an isomorphism\n" );
        fi;
        
        return Inverse( phi )^(-i);
    fi;
    
    return PreCompose( ListWithIdenticalEntries( i, phi ) );
    
end );

####################################
#
# View, Print, and Display methods:
#
####################################

##
InstallMethod( ViewObj,
        "for an object in an algebroid",
        [ IsObjectInAlgebroid ],
        
  function( o )
    
    Print( "<", StringView( UnderlyingVertex( o ) ), ">" );
    
end );

##
InstallMethod( ViewObj,
        "for a morphism in an algebroid",
        [ IsMorphismInAlgebroid ],
        
  function( o )
    
    if IsRightQuiverAlgebra( UnderlyingQuiverAlgebra( CapCategory( o ) ) ) then
        ViewObj( UnderlyingVertex( Source( o ) ) );
        Print( "-[" );
        ViewObj( UnderlyingQuiverAlgebraElement( o ) );
        Print( "]->" );
        ViewObj( UnderlyingVertex( Range( o ) ) );
    else
        ViewObj( UnderlyingVertex( Range( o ) ) );
        Print( "<-[" );
        ViewObj( UnderlyingQuiverAlgebraElement( o ) );
        Print( "]-" );
        ViewObj( UnderlyingVertex( Source( o ) ) );
    fi;
    
end );

##
InstallMethod( LaTeXOutput,
          [ IsObjectInAlgebroid ],
          
  o -> LaTeXStringForQPA( UnderlyingVertex( o ) )
);

##
InstallMethod( LaTeXOutput,
          [ IsMorphismInAlgebroid ],
          
  function( m )
    local s;
    
    s := LaTeXStringForQPA( UnderlyingQuiverAlgebraElement( m ) );
    
    if ValueOption( "OnlyDatum" ) = true then
      
      return s;
      
    else
      
      return Concatenation(
                "{", LaTeXOutput( Source( m ) ), "}-\\left(",
                "{", s, "}\\right)\\rightarrow",
                "{", LaTeXOutput( Range( m ) ), "}"
              );
              
    fi;
    
end );
