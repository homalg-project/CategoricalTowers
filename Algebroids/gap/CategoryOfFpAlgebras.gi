# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

##
InstallMethodWithCrispCache( CreateAmbientLinearClosureOfFpAlgebra,
        [ IsHomalgRing, IsInt, IsString ],
        
  function( k, nrgens, var_name )
    local nmgens, quiver, F;
    
    nmgens := ParseListOfIndeterminates( [ Concatenation( var_name, "1..", String( nrgens ) ) ] );
    
    quiver := FinQuiver(
                      Triple( "q",
                              Pair( 1, [ "o" ] ),
                              NTuple( 4,
                                      nrgens,
                                      ListWithIdenticalEntries( nrgens, 1 ),
                                      ListWithIdenticalEntries( nrgens, 1 ),
                                      nmgens ) ) );
    
    F := PathCategory( quiver );
    
    return LinearClosure( k, F );
    
end );

##
InstallMethod( CategoryOfFpAlgebras,
        "for a commutative homalg ring",
        [ IsHomalgRing and IsCommutative ],
        
  function( k )
    local name, FpAlg_k;
    
    ##
    name := Concatenation( "CategoryOfFpAlgebras( ", RingName( k ), " )" );
    
    ##
    FpAlg_k :=
      CreateCapCategory( name,
              IsCategoryOfFinitelyPresentedAlgebras,
              IsObjectInCategoryOfFpAlgebras,
              IsMorphismInCategoryOfFpAlgebras,
              IsCapCategoryTwoCell );
    
    FpAlg_k!.supports_empty_limits := true;
    
    SetCoefficientsRing( FpAlg_k, k );
    SetIsFiniteCocompleteCategory( FpAlg_k, true );
    SetIsBicartesianCategory( FpAlg_k, true );
    #SetIsCodistributiveCategory( FpAlg_k, true );
    SetIsSymmetricMonoidalCategory( FpAlg_k, true );
    
    FpAlg_k!.compiler_hints :=
      rec( category_attribute_names :=
           [ "CoefficientsRing",
             ] );
    
    ##
    AddObjectConstructor( FpAlg_k,
      function( FpAlg_k, septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens )
        local L, unique_object, nr_of_generators, generators, nr_of_relations, relations, names_of_generators;
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0,
                IsList( septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens ) and
                Length( septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens ) = 7 );
        
        L := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[1];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0,
                IsLinearClosure( L ) and
                IsPathCategory( UnderlyingCategory( L ) ) and
                HasCommutativeRingOfLinearCategory( L ) and
                IsIdenticalObj( k, CommutativeRingOfLinearCategory( L ) ) );
        
        unique_object := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[2];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0,
                IsLinearClosureObject( unique_object ) and
                IsIdenticalObj( L, CapCategory( unique_object ) ) );
        
        nr_of_generators := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[3];
        generators := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[4];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0,
                IsInt( nr_of_generators ) and
                IsList( generators ) and
                Length( generators ) = nr_of_generators and
                ForAll( generators, IsLinearClosureMorphism ) );
        
        nr_of_relations := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[5];
        relations := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[6];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0,
                IsInt( nr_of_relations ) and
                IsList( relations ) and
                Length( relations ) = nr_of_relations and
                ForAll( relations, IsLinearClosureMorphism ) );
        
        names_of_generators := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[7];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0,
                IsList( names_of_generators ) and
                Length( names_of_generators ) = nr_of_generators and
                ForAll( names_of_generators, IsStringRep ) );
        
        return CreateCapCategoryObjectWithAttributes( FpAlg_k,
                       DefiningSeptupleOfFinitelyPresentedAlgebra, septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens );
        
    end );
    
    ##
    AddObjectDatum( FpAlg_k,
      function( FpAlg_k, algebra )
        
        return DefiningSeptupleOfFinitelyPresentedAlgebra( algebra );
        
    end );
    
    ##
    AddMorphismConstructor( FpAlg_k,
      function( FpAlg_k, source, list_of_images, target )
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0,
                IsList( list_of_images ) and
                ForAll( list_of_images, IsLinearClosureMorphism ) );
        
        return CreateCapCategoryMorphismWithAttributes( FpAlg_k,
                       source,
                       target,
                       ListOfImages, list_of_images );
        
    end );
    
    ##
    AddMorphismDatum( FpAlg_k,
      function( FpAlg_k, algebra_morphism )
        
        return ListOfImages( algebra_morphism );
        
    end );
    
    ##
    AddIsEqualForObjects( FpAlg_k,
      function( FpAlg_k, algebra1, algebra2 )
        local datum1, datum2, L;
        
        datum1 := ObjectDatum( FpAlg_k, algebra1 );
        datum2 := ObjectDatum( FpAlg_k, algebra2 );
        
        L := datum1[1];
        
        return IsIdenticalObj( L, datum2[1] ) and
               IsEqualForObjects( L, datum1[2], datum2[2] ) and
               datum1[3] = datum2[3] and
               ForAll( [ 1 .. datum1[3] ], i -> IsEqualForMorphisms( L, datum1[4][i], datum2[4][i] ) ) and
               datum1[5] = datum2[5] and
               ForAll( [ 1 .. datum1[5] ], i -> IsEqualForMorphisms( L, datum1[6][i], datum2[6][i] ) );
        
    end );
    
    ##
    AddIsEqualForMorphisms( FpAlg_k,
      function( FpAlg_k, morphism1, morphism2 )
        local datum1, datum2, L;
        
        datum1 := MorphismDatum( FpAlg_k, morphism1 );
        datum2 := MorphismDatum( FpAlg_k, morphism2 );
        
        L := ObjectDatum( FpAlg_k, Source( morphism1 ) )[1];
        
        return Length( datum1 ) = Length( datum2 ) and
               ForAll( [ 1 .. Length( datum1 ) ], i -> IsEqualForMorphisms( L, datum1[i], datum2[i] ) );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( FpAlg_k,
      function( FpAlg_k, morphism1, morphism2 )
        local S, T, nrgens, L, datum1, datum2, diffs, GB, reds;
        
        S := Source( morphism1 );
        T := Target( morphism1 );
        
        nrgens := ObjectDatum( FpAlg_k, S )[3];
        
        L := ObjectDatum( FpAlg_k, T )[1];
        
        datum1 := MorphismDatum( FpAlg_k, morphism1 );
        datum2 := MorphismDatum( FpAlg_k, morphism2 );
        
        diffs := List( [ 1 .. nrgens ], i -> SubtractionForMorphisms( L, datum1[i], datum2[i] ) );
        
        GB := GroebnerBasisOfDefiningRelations( T );
        
        reds := List( diffs, diff -> ReductionOfMorphism( L, diff, GB ) );
        
        return ForAll( reds, red -> IsZeroForMorphisms( L, red ) );
        
    end );
    
    ##
    AddIsWellDefinedForObjects( FpAlg_k,
      function( FpAlg_k, algebra )
        local k, datum;
        
        k := CoefficientsRing( FpAlg_k );
        
        datum := ObjectDatum( FpAlg_k, algebra );
        
        if not IsList( datum ) then
            return false;
        elif not Length( datum ) = 7 then
            return false;
        elif not ( IsLinearClosure( datum[1] ) and
                IsPathCategory( UnderlyingCategory( datum[1] ) ) and
                HasCommutativeRingOfLinearCategory( datum[1] ) and
                IsIdenticalObj( k, CommutativeRingOfLinearCategory( datum[1] ) ) ) then
            return false;
        elif not IsLinearClosureObject( datum[2] ) then
            return false;
        elif not IsIdenticalObj( CapCategory( datum[2] ), datum[1] ) then
            return false;
        elif not IsInt( datum[3] ) then
            return false;
        elif not ( IsList( datum[4] ) and Length( datum[4] ) = datum[3] ) then
            return false;
        elif not ForAll( datum[4], IsLinearClosureMorphism ) then
            return false;
        elif not ForAll( datum[4], gen -> IsIdenticalObj( CapCategory( gen ), datum[1] ) ) then
            return false;
        elif not IsInt( datum[5] ) then
            return false;
        elif not ( IsList( datum[6] ) and Length( datum[6] ) = datum[5] ) then
            return false;
        elif not ForAll( datum[6], rel -> IsIdenticalObj( CapCategory( rel ), datum[1] ) ) then
            return false;
        elif not ( IsList( datum[7] ) and Length( datum[7] ) = datum[3] ) then
            return false;
        elif not ForAll( datum[7], IsStringRep ) then
            return false;
        fi;
        
        return true;
        
    end );
    
    ##
    AddIsWellDefinedForMorphisms( FpAlg_k,
      function( FpAlg_k, algebra_morphism )
        local S, T, datumS, datumT, datum, L, o, functor_on_mors, image_of_source_relations, GB, reds;
        
        S := Source( algebra_morphism );
        T := Target( algebra_morphism );
        
        datumS := ObjectDatum( FpAlg_k, S );
        datumT := ObjectDatum( FpAlg_k, T );
        
        datum := MorphismDatum( FpAlg_k, algebra_morphism );
        
        if not IsList( datum ) then
            return false;
        elif not ForAll( datum, image -> IsIdenticalObj( CapCategory( image ), ObjectDatum( FpAlg_k, Target( algebra_morphism ) )[1] ) ) then
            return false;
        elif not Length( datum ) = ObjectDatum( FpAlg_k, Source( algebra_morphism ) )[3] then
            return false;
        fi;
        
        L := datumT[1];
        
        o := datumT[2];
        
        functor_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, algebra_morphism )[2][2];
        
        image_of_source_relations := List( datumS[6], rel -> functor_on_mors( o, rel, o ) );
        
        GB := GroebnerBasisOfDefiningRelations( T );
        
        reds := List( image_of_source_relations, image -> ReductionOfMorphism( L, image, GB ) );
        
        return ForAll( reds, red -> IsZeroForMorphisms( L, red ) );
        
    end );
    
    ##
    AddIdentityMorphism( FpAlg_k,
      function( FpAlg_k, algebra )
        
        return MorphismConstructor( FpAlg_k,
                       algebra,
                       ObjectDatum( FpAlg_k, algebra )[4],
                       algebra );
        
    end );
    
    ##
    AddPreCompose( FpAlg_k,
      function( FpAlg_k, pre_morphism, post_morphism )
        local o, post_functor_on_mors;
        
        o := ObjectDatum( Target( post_morphism ) )[2];
        
        post_functor_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, post_morphism )[2][2];
        
        return MorphismConstructor( FpAlg_k,
                       Source( pre_morphism ),
                       List( MorphismDatum( FpAlg_k, pre_morphism ), image -> post_functor_on_mors( o, image, o ) ),
                       Target( post_morphism ) );
        
    end );
    
    ##
    AddDirectProduct( FpAlg_k,
      function( FpAlg_k, diagram )
        local l, data, nrsgens, nrgens, var, nmgens, k, L, o, gens, ambient,
              idem, orth_idem, central_idem, GB, sum, nrsrels, ambients, mors, functors_on_mors, rels;
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> ObjectDatum( FpAlg_k, diagram[m] ) );
        
        nrsgens := List( [ 1 .. l ], m -> data[m][3] );
        
        nrgens := Sum( nrsgens ) + l;
        
        var := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "variable_name", "a" );
        
        nmgens := ParseListOfIndeterminates( [ Concatenation( var, "1..", String( nrgens ) ) ] );
        
        k := CoefficientsRing( FpAlg_k );
        
        L := CreateAmbientLinearClosureOfFpAlgebra( k, nrgens, var );
        
        o := SetOfObjects( L )[1];
        
        gens := List( nmgens, name -> L.(name) );
        
        ambient := ObjectConstructor( FpAlg_k,
                           NTuple( 7,
                                   L,
                                   o,
                                   nrgens,
                                   gens,
                                   0,
                                   CapJitTypedExpression( [ ], cat -> CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( L ) ) ),
                                   nmgens ) );
        
        gens := List( [ 1 .. l ], m -> gens{[ m + Sum( nrsgens{[ 1 .. m - 1 ]} ) .. m + Sum( nrsgens{[ 1 .. m ]} ) ]} );
        
        ## e_m⋅e_m = e_m
        idem := List( [ 1 .. l ], m ->
                      SubtractionForMorphisms( L,
                              PreCompose( L, gens[m][nrsgens[m] + 1], gens[m][nrsgens[m] + 1] ),
                              gens[m][nrsgens[m] + 1] ) );
        
        ## e_m⋅e_n = 0 for m ≠ n
        orth_idem := List( [ 1 .. l ], m ->
                           List( Concatenation( [ 1 .. m - 1 ], [ m + 1 .. l ] ), n ->
                                 PreCompose( L, gens[m][nrsgens[m] + 1], gens[n][nrsgens[n] + 1] ) ) );
        
        orth_idem := Concatenation( orth_idem );
        
        ## e_m⋅a = a = a⋅e_m for a in the m-the factor
        central_idem := List( [ 1 .. l ], m ->
                              List( [ 1 .. nrsgens[m] ], i ->
                                    [ SubtractionForMorphisms( L,
                                            PreCompose( L, gens[m][nrsgens[m] + 1], gens[m][i] ),
                                            gens[m][i] ),
                                      SubtractionForMorphisms( L,
                                            PreCompose( L, gens[m][i], gens[m][nrsgens[m] + 1] ),
                                            gens[m][i] ) ] ) );
        
        central_idem := Concatenation( Concatenation( central_idem ) );
        
        GB := ReducedGroebnerBasis( L, Concatenation( idem, orth_idem, central_idem ) );
        
        sum := SubtractionForMorphisms( L,
                       SumOfMorphisms( o, List( [ 1 .. l ], m -> gens[m][nrsgens[m] + 1] ), o ),
                       IdentityMorphism( L, o ) );
        
        nrsrels := List( [ 1 .. l ], m -> data[m][5] );
        
        ambients := List( [ 1 .. l ], m -> AmbientAlgebra( diagram[m] ) );
        
        mors := List( [ 1 .. l ], m -> MorphismConstructor( FpAlg_k, ambients[m], gens[m]{[ 1 .. nrsgens[m] ]}, ambient ) );
        
        functors_on_mors := List( [ 1 .. l ], m -> AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mors[m] )[2][2] );
        
        rels := List( [ 1 .. l ], m ->
                      List( data[m][6], rel ->
                            PreCompose( L,
                                    functors_on_mors[m]( o, rel, o ),
                                    gens[m][nrsgens[m] + 1] ) ) ); ## project into the m-th factor
        
        rels := Concatenation( rels );
        
        ## get rid of the unnecessary central idempotents in the various summands,
        ## for the relations of the result to resemble the relations of the factors
        rels := List( rels, rel -> ReductionOfMorphism( L, rel, GB ) );
        
        return ObjectConstructor( FpAlg_k,
                       NTuple( 7,
                               L,
                               o,
                               nrgens,
                               Concatenation( gens ),
                               Sum( nrsrels ) + 2 * nrgens + (l - 1)^2,
                               Concatenation( rels, idem, orth_idem, central_idem, [ sum ] ),
                               nmgens ) );
        
    end );
    
    ##
    AddProjectionInFactorOfDirectProductWithGivenDirectProduct( FpAlg_k,
      function( FpAlg_k, diagram, p, product )
        local l, nrsgens, target, datum, L, o, gens, id, zero, func, images;
        
        l := Length( diagram );
        
        nrsgens := List( [ 1 .. l ], m -> ObjectDatum( FpAlg_k, diagram[m] )[3] );
        
        target := diagram[p];
        
        datum := ObjectDatum( FpAlg_k, target );
        
        L := datum[1];
        o := datum[2];
        gens := datum[4];
        
        id := IdentityMorphism( L, o );
        zero := ZeroMorphism( L, o, o );
        
        func :=
          function( m )
            
            if m = p then
                return Concatenation( gens, [ id ] );
            fi;
            
            return ListWithIdenticalEntries( nrsgens[m] + 1, zero );
            
        end;
        
        images := List( [ 1 .. l ], func );

        images := Concatenation( images );
        
        return MorphismConstructor( FpAlg_k,
                       product,
                       images,
                       target );
        
    end );
    
    ##
    AddUniversalMorphismIntoDirectProductWithGivenDirectProduct( FpAlg_k,
      function( FpAlg_k, diagram, source, tau, product )
        local l, data, nrsgens, datum, L, gens, idem, orth_idem, central_idem, GB,
              o, ambient, ambients, mors, functors_on_mors, images, nrgens_source;
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> ObjectDatum( FpAlg_k, diagram[m] ) );
        
        nrsgens := List( [ 1 .. l ], m -> data[m][3] );
        
        datum := ObjectDatum( FpAlg_k, product );
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, datum[3] = Sum( nrsgens ) + l );
        
        L := datum[1];
        
        gens := datum[4];
        
        gens := List( [ 1 .. l ], m -> gens{[ m + Sum( nrsgens{[ 1 .. m - 1 ]} ) .. m + Sum( nrsgens{[ 1 .. m ]} ) ]} );
        
        ## e_m⋅e_m = e_m
        idem := List( [ 1 .. l ], m ->
                      SubtractionForMorphisms( L,
                              PreCompose( L, gens[m][nrsgens[m] + 1], gens[m][nrsgens[m] + 1] ),
                              gens[m][nrsgens[m] + 1] ) );
        
        ## e_m⋅e_n = 0 for m ≠ n
        orth_idem := List( [ 1 .. l ], m ->
                           List( Concatenation( [ 1 .. m - 1 ], [ m + 1 .. l ] ), n ->
                                 PreCompose( L, gens[m][nrsgens[m] + 1], gens[n][nrsgens[n] + 1] ) ) );
        
        orth_idem := Concatenation( orth_idem );
        
        ## e_m⋅a = a = a⋅e_m for a in the m-the factor
        central_idem := List( [ 1 .. l ], m ->
                              List( [ 1 .. nrsgens[m] ], i ->
                                    [ SubtractionForMorphisms( L,
                                            PreCompose( L, gens[m][nrsgens[m] + 1], gens[m][i] ),
                                            gens[m][i] ),
                                      SubtractionForMorphisms( L,
                                            PreCompose( L, gens[m][i], gens[m][nrsgens[m] + 1] ),
                                            gens[m][i] ) ] ) );
        
        central_idem := Concatenation( Concatenation( central_idem ) );
        
        GB := ReducedGroebnerBasis( L, Concatenation( idem, orth_idem, central_idem ) );
        
        o := datum[2];
        
        ambient := AmbientAlgebra( product );
        
        ambients := List( [ 1 .. l ], m -> AmbientAlgebra( diagram[m] ) );
        
        mors := List( [ 1 .. l ], m -> MorphismConstructor( FpAlg_k, ambients[m], gens[m]{[ 1 .. nrsgens[m] ]}, ambient ) );
        
        functors_on_mors := List( [ 1 .. l ], m -> AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mors[m] )[2][2] );
        
        images := List( [ 1 .. l ], m ->
                        List( MorphismDatum( FpAlg_k, tau[m] ), image ->
                              PreCompose( L,
                                      functors_on_mors[m]( o, image, o ),
                                      gens[m][nrsgens[m] + 1] ) ) ); ## project into the m-th factor
        
        nrgens_source := ObjectDatum( FpAlg_k, source )[3];
        
        images := List( [ 1 .. nrgens_source ], i -> SumOfMorphisms( o, List( [ 1 .. l ], m -> images[m][i] ), o ) );
        
        ## get rid of the unnecessary central idempotents in the various summands,
        ## for the images in the result to resemble the relations of the factors
        images := List( images, image -> ReductionOfMorphism( L, image, GB ) );
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       images,
                       product );
        
    end );
    
    ##
    AddCoproduct( FpAlg_k,
      function( FpAlg_k, diagram )
        local l, data, nrsgens, nrgens, ambients, var, nmgens, k, L, o, gens,
              ambient, mors, functors_on_mors, nrsrels, rels;
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> ObjectDatum( FpAlg_k, diagram[m] ) );
        
        nrsgens := List( [ 1 .. l ], m -> data[m][3] );
        
        nrgens := Sum( nrsgens );
        
        var := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "variable_name", "a" );
        
        nmgens := ParseListOfIndeterminates( [ Concatenation( var, "1..", String( nrgens ) ) ] );
        
        k := CoefficientsRing( FpAlg_k );
        
        L := CreateAmbientLinearClosureOfFpAlgebra( k, nrgens, var );
        
        o := SetOfObjects( L )[1];
        
        gens := List( nmgens, name -> L.(name) );
        
        ambient := ObjectConstructor( FpAlg_k,
                           NTuple( 7,
                                   L,
                                   o,
                                   nrgens,
                                   gens,
                                   0,
                                   CapJitTypedExpression( [ ], cat -> CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( L ) ) ),
                                   nmgens ) );
        
        gens := List( [ 1 .. l ], m -> gens{[ 1 + Sum( nrsgens{[ 1 .. m - 1 ]} ) .. Sum( nrsgens{[ 1 .. m ]} ) ]} );
        
        ambients := List( [ 1 .. l ], m -> AmbientAlgebra( diagram[m] ) );
        
        mors := List( [ 1 .. l ], m -> MorphismConstructor( FpAlg_k, ambients[m], gens[m], ambient ) );
        
        functors_on_mors := List( [ 1 .. l ], m -> AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mors[m] )[2][2] );
        
        nrsrels := List( [ 1 .. l ], m -> data[m][5] );
        
        rels := List( [ 1 .. l ], m ->
                      List( data[m][6], rel -> functors_on_mors[m]( o, rel, o ) ) );
        
        rels := Concatenation( rels );
        
        return ObjectConstructor( FpAlg_k,
                       NTuple( 7,
                               L,
                               o,
                               nrgens,
                               Concatenation( gens ),
                               Sum( nrsrels ),
                               rels,
                               nmgens ) );
        
    end );
    
    ##
    AddInjectionOfCofactorOfCoproductWithGivenCoproduct( FpAlg_k,
      function( FpAlg_k, diagram, p, coproduct )
        local l, data, nrsgens, gens, images;
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> ObjectDatum( FpAlg_k, diagram[m] ) );
        
        nrsgens := List( [ 1 .. l ], m -> data[m][3] );
        
        gens := ObjectDatum( FpAlg_k, coproduct )[4];
        
        images := gens{[ 1 + Sum( nrsgens{[ 1 .. p - 1 ]} ) .. Sum( nrsgens{[ 1 .. p ]} ) ]};
        
        return MorphismConstructor( FpAlg_k,
                       diagram[p],
                       images,
                       coproduct );
        
    end );
    
    ##
    AddUniversalMorphismFromCoproductWithGivenCoproduct( FpAlg_k,
      function( FpAlg_k, diagram, target, tau, coproduct )
        local l, images;
        
        l := Length( diagram );
        
        images := List( [ 1 .. l ], m -> MorphismDatum( FpAlg_k, tau[m] ) );
        
        return MorphismConstructor( FpAlg_k,
                       coproduct,
                       Concatenation( images ),
                       target );
        
    end );
    
    ##
    AddTensorUnit( FpAlg_k,
      function( FpAlg_k )
        
        return InitialObject( FpAlg_k );
        
    end );
    
    ##
    AddTensorProductOnObjects( FpAlg_k,
      function( FpAlg_k, algebra1, algebra2 )
        local datum1, datum2, nrgens1, nrgens2, nrgens, ambient1, ambient2,
              var, nmgens, k, L, o, gens, gens1, gens2, ambient,
              mor1, mor2, functor1_on_mors, functor2_on_mors, nrrels, rels1, rels2, rels, mixed;
        
        datum1 := ObjectDatum( FpAlg_k, algebra1 );
        datum2 := ObjectDatum( FpAlg_k, algebra2 );
        
        nrgens1 := datum1[3];
        nrgens2 := datum2[3];
        
        nrgens := nrgens1 + nrgens2;
        
        ambient1 := AmbientAlgebra( algebra1 );
        ambient2 := AmbientAlgebra( algebra2 );
        
        var := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "variable_name", "a" );
        
        nmgens := ParseListOfIndeterminates( [ Concatenation( var, "1..", String( nrgens ) ) ] );
        
        k := CoefficientsRing( FpAlg_k );
        
        L := CreateAmbientLinearClosureOfFpAlgebra( k, nrgens, var );
        
        o := SetOfObjects( L )[1];
        
        gens := List( nmgens, name -> L.(name) );
        
        ambient := ObjectConstructor( FpAlg_k,
                           NTuple( 7,
                                   L,
                                   o,
                                   nrgens,
                                   gens,
                                   0,
                                   CapJitTypedExpression( [ ], cat -> CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( L ) ) ),
                                   nmgens ) );
        
        gens1 := gens{[ 1 .. nrgens1 ]};
        gens2 := gens{[ nrgens1 + 1 .. nrgens ]};
        
        mor1 := MorphismConstructor( FpAlg_k, ambient1, gens1, ambient );
        mor2 := MorphismConstructor( FpAlg_k, ambient2, gens2, ambient );
        
        functor1_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor1 )[2][2];
        functor2_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor2 )[2][2];
        
        nrrels := datum1[5] + datum2[5];
        
        rels1 := List( datum1[6], rel -> functor1_on_mors( o, rel, o ) );
        rels2 := List( datum2[6], rel -> functor2_on_mors( o, rel, o ) );
        
        rels := Concatenation( rels1, rels2 );
        
        mixed := List( [ 1 .. nrgens1 ], i ->
                       List( [ 1 .. nrgens2 ], j ->
                             SubtractionForMorphisms( L,
                                     PreCompose( L, gens1[i], gens2[j] ),
                                     PreCompose( L, gens2[j], gens1[i] ) ) ) );
        
        mixed := Concatenation( mixed );
        
        return ObjectConstructor( FpAlg_k,
                       NTuple( 7,
                               L,
                               o,
                               nrgens,
                               gens,
                               nrrels + nrgens1 * nrgens2,
                               Concatenation( rels, mixed ),
                               nmgens ) );
        
    end );
    
    ##
    AddTensorProductOnMorphismsWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, algebra_morphism1, algebra_morphism2, target )
        local target1, target2, ambient_target1, ambient_target2, ngens1, ngens2,
              ambient_target, datum, ngens, gens, gens1, gens2, mor1, mor2,
              functor1_on_mors, functor2_on_mors, o, datum_morphism1, datum_morphism2,
              list_of_images;
        
        target1 := Target( algebra_morphism1 );
        target2 := Target( algebra_morphism2 );
        
        ambient_target1 := AmbientAlgebra( target1 );
        ambient_target2 := AmbientAlgebra( target2 );
        
        ngens1 := ObjectDatum( FpAlg_k, ambient_target1 )[3];
        ngens2 := ObjectDatum( FpAlg_k, ambient_target2 )[3];
        
        ambient_target := AmbientAlgebra( target );
        
        datum := ObjectDatum( FpAlg_k, ambient_target );
        
        ngens := datum[3];
        gens := datum[4];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, ngens = ngens1 + ngens2 );
        
        gens1 := gens{[ 1 .. ngens1 ]};
        gens2 := gens{[ ngens1 + 1 .. ngens ]};
        
        mor1 := MorphismConstructor( FpAlg_k,
                        ambient_target1,
                        gens1,
                        ambient_target );
        
        mor2 := MorphismConstructor( FpAlg_k,
                        ambient_target2,
                        gens2,
                        ambient_target );
        
        functor1_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( mor1 )[2][2];
        functor2_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( mor2 )[2][2];
        
        o := datum[2];
        
        datum_morphism1 := MorphismDatum( FpAlg_k, algebra_morphism1 );
        datum_morphism2 := MorphismDatum( FpAlg_k, algebra_morphism2 );
        
        list_of_images := Concatenation(
                                  List( datum_morphism1, image -> functor1_on_mors( o, image, o ) ),
                                  List( datum_morphism2, image -> functor2_on_mors( o, image, o ) ) );
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       list_of_images,
                       target );
        
    end );
    
    ##
    AddLeftUnitorWithGivenTensorProduct( FpAlg_k,
      function( FpAlg_k, algebra, source )
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       ObjectDatum( FpAlg_k, algebra )[4],
                       algebra );
        
    end );
    
    ##
    AddLeftUnitorInverseWithGivenTensorProduct( FpAlg_k,
      function( FpAlg_k, algebra, target )
        
        return MorphismConstructor( FpAlg_k,
                       algebra,
                       ObjectDatum( FpAlg_k, target )[4],
                       target );
        
    end );
    
    ##
    AddRightUnitorWithGivenTensorProduct( FpAlg_k,
      function( FpAlg_k, algebra, source )
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       ObjectDatum( FpAlg_k, algebra )[4],
                       algebra );
        
    end );
    
    ##
    AddRightUnitorInverseWithGivenTensorProduct( FpAlg_k,
      function( FpAlg_k, algebra, target )
        
        return MorphismConstructor( FpAlg_k,
                       algebra,
                       ObjectDatum( FpAlg_k, target )[4],
                       target );
        
    end );
    
    ##
    AddAssociatorLeftToRightWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, algebra1, algebra2, algebra3, target )
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       ObjectDatum( FpAlg_k, target )[4],
                       target );
        
    end );
    
    ##
    AddAssociatorRightToLeftWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, algebra1, algebra2, algebra3, target )
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       ObjectDatum( FpAlg_k, target )[4],
                       target );
        
    end );
    
    ##
    AddBraidingWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, algebra1, algebra2, target )
        local nrgens1, nrgens2, datum, nrgens, gens;
        
        nrgens1 := ObjectDatum( FpAlg_k, algebra1 )[3];
        nrgens2 := ObjectDatum( FpAlg_k, algebra2 )[3];
        
        datum := ObjectDatum( FpAlg_k, target );
        
        nrgens := datum[3];
        gens := datum[4];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, nrgens = nrgens1 + nrgens2 );
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       Concatenation( gens{[ nrgens2 + 1 .. nrgens ]}, gens{[ 1 .. nrgens2 ]} ),
                       target );
        
    end );
    
    ##
    AddBraidingInverseWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, algebra1, algebra2, target )
        local nrgens1, nrgens2, datum, nrgens, gens;
        
        nrgens1 := ObjectDatum( FpAlg_k, algebra1 )[3];
        nrgens2 := ObjectDatum( FpAlg_k, algebra2 )[3];
        
        datum := ObjectDatum( FpAlg_k, target );
        
        nrgens := datum[3];
        gens := datum[4];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, nrgens = nrgens1 + nrgens2 );
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       Concatenation( gens{[ nrgens1 + 1 .. nrgens ]}, gens{[ 1 .. nrgens1 ]} ),
                       target );
        
    end );
    
    ##
    AddCoequalizer( FpAlg_k,
      function( FpAlg_k, target, diagram )
        local datum, L, l, data, rels, all_rels;
        
        ## if the diagram is empty there is no source
        
        datum := ObjectDatum( FpAlg_k, target );
        
        L := datum[1];
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> MorphismDatum( FpAlg_k, diagram[m] ) );
        
        rels := Concatenation( List( [ 1 .. l - 1 ], m -> data[m] - data[m + 1] ) );
        
        all_rels := Concatenation( rels, datum[6] );
        
        all_rels := Filtered( all_rels, rel -> not IsZeroForMorphisms( L, rel ) );
        
        return ObjectConstructor( FpAlg_k,
                       NTuple( 7,
                               datum[1],
                               datum[2],
                               datum[3],
                               datum[4],
                               Length( all_rels ),
                               all_rels,
                               datum[7] ) );
        
    end );
    
    ##
    AddProjectionOntoCoequalizerWithGivenCoequalizer( FpAlg_k,
      function( FpAlg_k, target, diagram, coequalizer )
        
        return MorphismConstructor( FpAlg_k,
                       target,
                       ObjectDatum( FpAlg_k, coequalizer )[4],
                       coequalizer );
        
    end );
    
    ##
    AddUniversalMorphismFromCoequalizerWithGivenCoequalizer( FpAlg_k,
      function( FpAlg_k, target, diagram, T, tau, coequalizer )
        
        return MorphismConstructor( FpAlg_k,
                       coequalizer,
                       MorphismDatum( FpAlg_k, tau ),
                       T );
        
    end );
    
    Finalize( FpAlg_k );
    
    return FpAlg_k;
    
end );

##
InstallMethod( NrGenerators,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    
    return ObjectDatum( algebra )[3];
    
end );

##
InstallMethod( Generators,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    
    return ObjectDatum( algebra )[4];
    
end );

##
InstallMethod( AssociatedLinearClosureOfPathCategory,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    
    return ObjectDatum( algebra )[1];
    
end );

##
InstallMethod( DefiningRelations,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    
    return ObjectDatum( algebra )[6];
    
end );

##
InstallMethod( AssociatedQuotientCategoryOfLinearClosureOfPathCategory,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    
    return AssociatedLinearClosureOfPathCategory( algebra ) / DefiningRelations( algebra );
    
end );

##
InstallMethod( GroebnerBasisOfDefiningRelations,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    
    return GroebnerBasis( AssociatedLinearClosureOfPathCategory( algebra ), DefiningRelations( algebra ) );
    
end );

##
InstallMethod( Dimension,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    local k, quotient;
    
    k := CommutativeRingOfLinearCategory( AssociatedLinearClosureOfPathCategory( algebra ) );
    
    if not ( HasIsFieldForHomalg( k ) and IsFieldForHomalg( k ) ) then
        Error( "the underlying commutative ring `k` is either not a field or not yet marked as a field\n" );
    fi;
    
    quotient := AssociatedQuotientCategoryOfLinearClosureOfPathCategory( algebra );
    
    if HasIsEquippedWithHomomorphismStructure( quotient ) and IsEquippedWithHomomorphismStructure( quotient ) and
       HasRangeCategoryOfHomomorphismStructure( quotient ) and
       MissingOperationsForConstructivenessOfCategory( quotient, "IsEquippedWithHomomorphismStructure" ) = [ ]  then
        
        ## there are finitely many Macaulay morphisms
        return Dimension( quotient );
        
    else
        
        ## there are infinitely many Macaulay morphisms
        return infinity;
        
    fi;
    
end );

##
InstallOtherMethodForCompilerForCAP( AmbientAlgebra,
        "for a category of finitely presented algebras and an algebra therein",
        [ IsCategoryOfFinitelyPresentedAlgebras, IsObjectInCategoryOfFpAlgebras ],
        
  function( FpAlg_k, algebra )
    local datum;
    
    datum := ObjectDatum( FpAlg_k, algebra );
    
    return ObjectConstructor( FpAlg_k,
                   NTuple( 7,
                           datum[1],
                           datum[2],
                           datum[3],
                           datum[4],
                           0,
                           CapJitTypedExpression( [ ], cat -> CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( datum[1] ) ) ),
                           datum[7] ) );
    
end );

##
InstallMethod( AmbientAlgebra,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    
    return AmbientAlgebra( CapCategory( algebra ), algebra );
    
end );

##
InstallMethod( \/,
        "for a linear category and a category of finitely presented algebras",
        [ IsCapCategory and IsLinearCategoryOverCommutativeRing, IsCategoryOfFinitelyPresentedAlgebras ],
        
  function( cat, FpAlg_k )
    local k, A, relations, object, generators, get_labels;
    
    k := CommutativeRingOfLinearCategory( cat );
    
    if IsQuotientCategory( cat ) then
        Assert( 0, HasDefiningRelations( cat ) );
        A := UnderlyingCategory( cat );
        relations := DefiningRelations( cat );
    elif IsLinearClosure( cat ) then
        A := cat;
        relations := [ ];
    else
        Error( "the first argument `cat` should either be an `IsQuotientCategory` or an `IsLinearClosure`\n" );
    fi;

    object := SetOfObjects( A )[1];
    
    generators := SetOfGeneratingMorphisms( A );
    
    get_labels :=
      function( gen )
        local coef, supp, g;
        
        coef := CoefficientsList( gen );
        supp := SupportMorphisms( gen );
        
        Assert( 0, Length( coef ) = 1 and coef[1] in k and IsOne( coef[1] ) );
        Assert( 0, Length( supp ) = 1 );
        
        return MorphismLabel( supp[1] );
        
    end;
    
    return ObjectConstructor( FpAlg_k,
                   NTuple( 7,
                           A,
                           object,
                           Length( generators ),
                           generators,
                           Length( relations ),
                           relations,
                           List( generators, get_labels ) ) );
    
end );

##
InstallMethod( \.,
        "for a finitely presented algebra and a positive integer",
        [ IsObjectInCategoryOfFpAlgebras, IsPosInt ],
        
  function( A, string_as_int )
    local name;
    
    name := NameRNam( string_as_int );
    
    return AssociatedLinearClosureOfPathCategory( A ).(name);
    
end );

##
InstallOtherMethodForCompilerForCAP( AssociatedFunctorOfLinearClosuresOfPathCategoriesData,
        "for a category of finitely presented algebras and a finitely presented algebra morphism therein",
        [ IsCategoryOfFinitelyPresentedAlgebras, IsMorphismInCategoryOfFpAlgebras ],
        
  function( FpAlg_k, algebra_morphism )
    local S, T, path_cat, image_of_unique_object, images_of_generating_morphism;
    
    S := ObjectDatum( FpAlg_k, Source( algebra_morphism ) )[1];
    T := ObjectDatum( FpAlg_k, Target( algebra_morphism ) )[1];
    
    path_cat := UnderlyingCategory( S );
    
    image_of_unique_object := SetOfObjects( T );
    images_of_generating_morphism := MorphismDatum( FpAlg_k, algebra_morphism );
    
    return ExtendFunctorToAlgebroidData(
                   S,
                   ExtendFunctorToFpCategoryData(
                           path_cat,
                           ## quiver_of_S → T
                           Pair( obj_in_quiver_S -> image_of_unique_object[obj_in_quiver_S],
                                 mor_in_quiver_S -> images_of_generating_morphism[mor_in_quiver_S] ),
                           T )[2],
                   T );
    
end );

##
InstallMethod( AssociatedFunctorOfLinearClosuresOfPathCategoriesData,
        "for a finitely presented algebra morphism",
        [ IsMorphismInCategoryOfFpAlgebras ],
        
  function( algebra_morphism )
    
    return AssociatedFunctorOfLinearClosuresOfPathCategoriesData( CapCategory( algebra_morphism ), algebra_morphism );
    
end );

##
InstallMethod( Counit,
        "for a finitely presented algebra and a list",
        [ IsObjectInCategoryOfFpAlgebras, IsList ],
        
  function( algebra, list_of_images_of_counit )
    local FpAlg_k, U, id;
    
    FpAlg_k := CapCategory( algebra );
    
    U := TensorUnit( FpAlg_k );
    
    id := U.id_o;
    
    return MorphismConstructor( FpAlg_k,
                   algebra,
                   List( list_of_images_of_counit, r -> r * id ),
                   U );
    
end );

##
InstallMethod( Comultiplication,
        "for a finitely presented algebra and a list",
        [ IsObjectInCategoryOfFpAlgebras, IsList ],
        
  function( algebra, list_of_images_of_comult )
    local FpAlg_k, algebra2, nrgens, nrgens2, L, gens, gens1, gens2,
          ambient, ambient2, mor1, mor2, functor1_on_mors, functor2_on_mors, o;
    
    FpAlg_k := CapCategory( algebra );
    
    algebra2 := TensorProductOnObjects( FpAlg_k, algebra, algebra );
    
    nrgens := NrGenerators( algebra );
    
    Assert( 0, nrgens = Length( list_of_images_of_comult ) and ForAll( list_of_images_of_comult, IsList ) );
    Assert( 0, ForAll( list_of_images_of_comult, list -> ForAll( list, pair -> Length( pair ) = 2 and ForAll( pair, IsLinearClosureMorphism ) ) ) );
    
    nrgens2 := NrGenerators( algebra2 );
    
    Assert( 0, 2 * nrgens = nrgens2 );
    
    L := AssociatedLinearClosureOfPathCategory( algebra2 );
    
    gens := Generators( algebra2 );
    
    gens1 := gens{[ 1 .. nrgens ]};
    gens2 := gens{[ nrgens + 1 .. nrgens2 ]};
        
    ambient := AmbientAlgebra( algebra );
    ambient2 := AmbientAlgebra( algebra2 );
    
    mor1 := MorphismConstructor( FpAlg_k, ambient, gens1, ambient2 );
    mor2 := MorphismConstructor( FpAlg_k, ambient, gens2, ambient2 );
        
    functor1_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor1 )[2][2];
    functor2_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor2 )[2][2];
    
    o := SetOfObjects( L )[1];
    
    return MorphismConstructor( FpAlg_k,
                   algebra,
                   List( list_of_images_of_comult, list -> Sum( list, pair -> functor1_on_mors( o, pair[1], o ) * functor2_on_mors( o, pair[2], o ) ) ),
                   algebra2 );
    
end );

####################################
#
# View, Print, Display and LaTeX methods:
#
####################################

##
InstallMethod( DisplayString,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( algebra )
    local k, datum, gens, q, str, rels;
    
    k := CoefficientsRing( CapCategory( algebra ) );
    
    datum := ObjectDatum( algebra );
    
    if datum[3] > 0 then
        gens := Concatenation( "<", JoinStringsWithSeparator( datum[7] ), ">" );
    else
        gens := "";
    fi;
    
    q := UnderlyingQuiver( datum[1] );
    
    if datum[5] > 3 then
        str := ", ...";
    else
        str := "";
    fi;
    
    rels := datum[6];
    
    rels := rels{[ 1 .. Minimum( 3, datum[5] ) ]};
    
    rels := Concatenation( " / [ ", JoinStringsWithSeparator( List( rels, rel -> CAP_INTERNAL_EXTRACT_STRING_OF_PATH( q, rel ) ), ", " ), str, " ]" );
    
    return Concatenation( RingName( k ), gens, rels, "\n" );
    
end );

##
InstallMethod( DisplayString,
        "for a finitely presented algebra morphism",
        [ IsMorphismInCategoryOfFpAlgebras ],
        
  function( algebra_morphism )
    local q, images;
    
    q := UnderlyingQuiver( AssociatedLinearClosureOfPathCategory( Source( algebra_morphism ) ) );
    
    images := MorphismDatum( algebra_morphism );
    
    images := Concatenation( "[ ", JoinStringsWithSeparator( List( images, image -> CAP_INTERNAL_EXTRACT_STRING_OF_PATH( q, image ) ), ", " ), " ]\n" );
    
    return Concatenation(
                   DisplayString( Target( algebra_morphism ) ),
                   " ^\n |\n",
                   images,
                   " |\n",
                   DisplayString( Source( algebra_morphism ) ) );
    
end );
