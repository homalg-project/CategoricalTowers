# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

##
InstallMethodWithCrispCache( CreateAmbientLinearClosureOfFpAlgebra,
        [ IsCategoryOfRows, IsInt, IsString ],
        
  function( B, nrgens, var_name )
    local nmgens, quiver, F;
    
    nmgens := ParseListOfIndeterminates( [ Concatenation( var_name, "1..", String( nrgens ) ) ] );
    
    quiver := FinQuiver(
                      Triple( "q",
                              Pair( 1, [ "o" ] ),
                              NTuple( 4,
                                      nrgens,
                                      ListWithIdenticalEntries( nrgens, 1 ),
                                      ListWithIdenticalEntries( nrgens, 1 ),
                                      nmgens ) ) );
    
    F := PathCategory( quiver );
    
    return LinearClosure( B, F );
    
end );

##
InstallMethod( CategoryOfFpAlgebras,
        "for a linear category",
        [ IsCapCategory and IsLinearCategoryOverCommutativeRing ],
        
  FunctionWithNamedArguments(
  [ [ "FinalizeCategory", true ],
  ],
  function( CAP_NAMED_ARGUMENTS, linear_category )
    local name, k, FpAlg_k;
    
    k := CommutativeRingOfLinearCategory( linear_category );
    
    ##
    name := Concatenation( "CategoryOfFpAlgebras( ", RingName( k ), " )" );
    
    ##
    FpAlg_k :=
      CreateCapCategoryWithDataTypes( name,
              IsCategoryOfFpAlgebras,
              IsObjectInCategoryOfFpAlgebras,
              IsMorphismInCategoryOfFpAlgebras,
              IsCapCategoryTwoCell,
              CapJitDataTypeOfNTupleOf( 7,
                      rec( category := false, filter := IsLinearClosure ),
                      rec( category := false, filter := IsLinearClosureObject ),
                      IsBigInt,
                      CapJitDataTypeOfListOf( rec( category := false, filter := IsLinearClosureMorphism ) ),
                      IsBigInt,
                      CapJitDataTypeOfListOf( rec( category := false, filter := IsLinearClosureMorphism ) ),
                      CapJitDataTypeOfListOf( IsStringRep ) ),
              CapJitDataTypeOfListOf( rec( category := false, filter := IsLinearClosureMorphism ) ),
              fail );
    
    SetIsFiniteCocompleteCategory( FpAlg_k, true );
    SetIsBicartesianCategory( FpAlg_k, true );
    SetIsSymmetricMonoidalCategory( FpAlg_k, true );

    ## see counterexample to codistributivity
    ## in examples/NonCodistributivityOfCategoryOfFpAlgebras.g;
    ## note that the category of (f.p.) *commutative* algebras is codistributive
    SetIsCodistributiveCategory( FpAlg_k, false );
    
    FpAlg_k!.supports_empty_limits := true;
    
    SetUnderlyingCategoryOfMatrices( FpAlg_k, linear_category );
    SetCoefficientsRing( FpAlg_k, k );
    
    FpAlg_k!.compiler_hints :=
      rec( category_attribute_names :=
           [ "UnderlyingCategoryOfMatrices",
             "CoefficientsRing",
             ] );
    
    ##
    AddObjectConstructor( FpAlg_k,
      function( FpAlg_k, septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens )
        local L, unique_object, nr_of_generators, generators, nr_of_relations, relations, names_of_generators;
        
        L := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[1];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0,
                IsPathCategory( UnderlyingCategory( L ) ) and
                HasCommutativeRingOfLinearCategory( L ) and
                IsIdenticalObj( k, CommutativeRingOfLinearCategory( L ) ) );
        
        unique_object := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[2];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, IsIdenticalObj( L, CapCategory( unique_object ) ) );
        
        nr_of_generators := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[3];
        generators := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[4];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, Length( generators ) = nr_of_generators );
        
        nr_of_relations := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[5];
        relations := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[6];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, Length( relations ) = nr_of_relations );
        
        names_of_generators := septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens[7];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, Length( names_of_generators ) = nr_of_generators );
        
        return CreateCapCategoryObjectWithAttributes( FpAlg_k,
                       DefiningSeptupleOfFinitelyPresentedAlgebra, septuple_lincat_uniqueobj_nrgens_gens_nrrels_rels_nmgens );
        
    end );
    
    ##
    AddObjectDatum( FpAlg_k,
      function( FpAlg_k, fp_algebra )
        
        return DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra );
        
    end );
    
    ##
    AddMorphismConstructor( FpAlg_k,
      function( FpAlg_k, source, list_of_images, target )
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, NrGenerators( source ) = Length( list_of_images ) );
        
        return CreateCapCategoryMorphismWithAttributes( FpAlg_k,
                       source,
                       target,
                       ListOfImages, list_of_images );
        
    end );
    
    ##
    AddMorphismDatum( FpAlg_k,
      function( FpAlg_k, fp_algebra_morphism )
        
        return ListOfImages( fp_algebra_morphism );
        
    end );
    
    ##
    AddIsEqualForObjects( FpAlg_k,
      function( FpAlg_k, fp_algebra1, fp_algebra2 )
        local datum1, datum2, L;
        
        datum1 := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra1 );
        datum2 := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra2 );
        
        L := datum1[1];
        
        return IsIdenticalObj( L, datum2[1] ) and
               IsEqualForObjects( L, datum1[2], datum2[2] ) and
               datum1[3] = datum2[3] and
               ForAll( [ 1 .. datum1[3] ], i -> IsEqualForMorphisms( L, datum1[4][i], datum2[4][i] ) ) and
               ForAll( [ 1 .. datum1[3] ], i -> datum1[7][i] = datum2[7][i] ) and
               datum1[5] = datum2[5] and
               ForAll( [ 1 .. datum1[5] ], i -> IsEqualForMorphisms( L, datum1[6][i], datum2[6][i] ) );
        
    end );
    
    ##
    AddIsEqualForMorphisms( FpAlg_k,
      function( FpAlg_k, fp_algebra_morphism1, fp_algebra_morphism2 )
        local list_of_images1, list_of_images2, L;
        
        list_of_images1 := ListOfImages( fp_algebra_morphism1 );
        list_of_images2 := ListOfImages( fp_algebra_morphism2 );
        
        L := DefiningSeptupleOfFinitelyPresentedAlgebra( Source( fp_algebra_morphism1 ) )[1];
        
        return Length( list_of_images1 ) = Length( list_of_images2 ) and
               ForAll( [ 1 .. Length( list_of_images1 ) ], i -> IsEqualForMorphisms( L, list_of_images1[i], list_of_images2[i] ) );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( FpAlg_k,
      function( FpAlg_k, fp_algebra_morphism1, fp_algebra_morphism2 )
        local S, T, nrgens, L, list_of_images1, list_of_images2, diffs, GB, reds;
        
        S := Source( fp_algebra_morphism1 );
        T := Target( fp_algebra_morphism1 );
        
        nrgens := DefiningSeptupleOfFinitelyPresentedAlgebra( S )[3];
        
        L := DefiningSeptupleOfFinitelyPresentedAlgebra( T )[1];
        
        list_of_images1 := ListOfImages( fp_algebra_morphism1 );
        list_of_images2 := ListOfImages( fp_algebra_morphism2 );
        
        diffs := List( [ 1 .. nrgens ], i -> SubtractionForMorphisms( L, list_of_images1[i], list_of_images2[i] ) );
        
        GB := GroebnerBasisOfDefiningRelations( T );
        
        reds := List( diffs, diff -> ReductionOfMorphism( L, diff, GB ) );
        
        return ForAll( reds, red -> IsZeroForMorphisms( L, red ) );
        
    end );
    
    ##
    AddIsWellDefinedForObjects( FpAlg_k,
      function( FpAlg_k, fp_algebra )
        local k, datum;
        
        k := CoefficientsRing( FpAlg_k );
        
        datum := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra );
        
        return IsPathCategory( UnderlyingCategory( datum[1] ) ) and
               HasCommutativeRingOfLinearCategory( datum[1] ) and
               IsIdenticalObj( k, CommutativeRingOfLinearCategory( datum[1] ) ) and
               IsIdenticalObj( CapCategory( datum[2] ), datum[1] ) and
               Length( datum[4] ) = datum[3] and
               ForAll( datum[4], gen -> IsIdenticalObj( CapCategory( gen ), datum[1] ) ) and
               Length( datum[6] ) = datum[5] and
               ForAll( datum[6], rel -> IsIdenticalObj( CapCategory( rel ), datum[1] ) ) and
               Length( datum[7] ) = datum[3];
        
    end );
    
    ##
    AddIsWellDefinedForMorphisms( FpAlg_k,
      function( FpAlg_k, fp_algebra_morphism )
        local S, T, datumS, datumT, list_of_images, L, o, functor_on_mors, image_of_source_relations, GB, reds, bool, obstruction;
        
        S := Source( fp_algebra_morphism );
        T := Target( fp_algebra_morphism );
        
        datumS := DefiningSeptupleOfFinitelyPresentedAlgebra( S );
        datumT := DefiningSeptupleOfFinitelyPresentedAlgebra( T );
        
        list_of_images := ListOfImages( fp_algebra_morphism );
        
        if not Length( list_of_images ) = datumS[3] then
            return false;
        elif not ForAll( list_of_images, image -> IsIdenticalObj( CapCategory( image ), datumT[1] ) ) then
            return false;
        fi;
        
        L := datumT[1];
        
        o := datumT[2];
        
        functor_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, fp_algebra_morphism )[2][2];
        
        image_of_source_relations := List( datumS[6], rel -> functor_on_mors( o, rel, o ) );
        
        GB := GroebnerBasisOfDefiningRelations( T );
        
        reds := List( image_of_source_relations, image -> ReductionOfMorphism( L, image, GB ) );
        
        reds := Filtered( reds, red -> not IsZeroForMorphisms( L, red ) );
        
        bool := IsEmpty( reds );
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        obstruction := ValueOption( "obstruction" );
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        if not bool and not obstruction = fail then
            Add( obstruction, Pair( reds, "IsWellDefinedForMorphisms" ) );
            return true;
        fi;
        
        return bool;
        
    end );
    
    ##
    AddIdentityMorphism( FpAlg_k,
      function( FpAlg_k, fp_algebra )
        
        return MorphismConstructor( FpAlg_k,
                       fp_algebra,
                       DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra )[4],
                       fp_algebra );
        
    end );
    
    ##
    AddPreCompose( FpAlg_k,
      function( FpAlg_k, pre_morphism, post_morphism )
        local target, o, post_functor_on_mors, L, GB, images;
        
        target := Target( post_morphism );
        
        o := DefiningSeptupleOfFinitelyPresentedAlgebra( target )[2];
        
        post_functor_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, post_morphism )[2][2];
        
        L := AssociatedLinearClosureOfPathCategory( target );
        
        GB := GroebnerBasisOfDefiningRelations( target );
        
        images := List( ListOfImages( pre_morphism ), image -> post_functor_on_mors( o, image, o ) );
        
        images := List( images, image -> ReductionOfMorphism( L, image, GB ) );
        
        return MorphismConstructor( FpAlg_k,
                       Source( pre_morphism ),
                       images,
                       target );
        
    end );
    
    ##
    AddDirectProduct( FpAlg_k,
      function( FpAlg_k, diagram )
        local l, data, nrsgens, nrgens, var, nmgens, B, L, o, gens, ambient,
              idem, orth_idem, central_idem, GB, sum, nrsrels, ambients, mors, functors_on_mors, rels;
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> DefiningSeptupleOfFinitelyPresentedAlgebra( diagram[m] ) );
        
        nrsgens := List( [ 1 .. l ], m -> data[m][3] );
        
        nrgens := Sum( nrsgens ) + l;
        
        var := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "variable_name", "a" );
        
        nmgens := ParseListOfIndeterminates( [ Concatenation( var, "1..", String( nrgens ) ) ] );
        
        B := UnderlyingCategoryOfMatrices( FpAlg_k );
        
        L := CreateAmbientLinearClosureOfFpAlgebra( B, nrgens, var );
        
        o := SetOfObjects( L )[1];
        
        gens := List( nmgens, name -> L.(name) );
        
        ambient := ObjectConstructor( FpAlg_k,
                           NTuple( 7,
                                   L,
                                   o,
                                   nrgens,
                                   gens,
                                   0,
                                   CapJitTypedExpression( [ ], cat -> CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( L ) ) ),
                                   nmgens ) );
        
        gens := List( [ 1 .. l ], m -> gens{[ m + Sum( nrsgens{[ 1 .. m - 1 ]} ) .. m + Sum( nrsgens{[ 1 .. m ]} ) ]} );
        
        ## e_m⋅e_m = e_m
        idem := List( [ 1 .. l ], m ->
                      SubtractionForMorphisms( L,
                              PreCompose( L, gens[m][nrsgens[m] + 1], gens[m][nrsgens[m] + 1] ),
                              gens[m][nrsgens[m] + 1] ) );
        
        ## e_m⋅e_n = 0 for m ≠ n
        orth_idem := List( [ 1 .. l ], m ->
                           List( Concatenation( [ 1 .. m - 1 ], [ m + 1 .. l ] ), n ->
                                 PreCompose( L, gens[m][nrsgens[m] + 1], gens[n][nrsgens[n] + 1] ) ) );
        
        orth_idem := Concatenation( orth_idem );
        
        ## e_m⋅a = a = a⋅e_m for a in the m-the factor
        central_idem := List( [ 1 .. l ], m ->
                              List( [ 1 .. nrsgens[m] ], i ->
                                    [ SubtractionForMorphisms( L,
                                            PreCompose( L, gens[m][nrsgens[m] + 1], gens[m][i] ),
                                            gens[m][i] ),
                                      SubtractionForMorphisms( L,
                                            PreCompose( L, gens[m][i], gens[m][nrsgens[m] + 1] ),
                                            gens[m][i] ) ] ) );
        
        central_idem := Concatenation( Concatenation( central_idem ) );
        
        GB := ReducedGroebnerBasis( L, Concatenation( idem, orth_idem, central_idem ) );
        
        sum := SubtractionForMorphisms( L,
                       IdentityMorphism( L, o ),
                       SumOfMorphisms( o, List( [ 1 .. l ], m -> gens[m][nrsgens[m] + 1] ), o ) );
        
        nrsrels := List( [ 1 .. l ], m -> data[m][5] );
        
        ambients := List( [ 1 .. l ], m -> AmbientAlgebra( diagram[m] ) );
        
        mors := List( [ 1 .. l ], m -> MorphismConstructor( FpAlg_k, ambients[m], gens[m]{[ 1 .. nrsgens[m] ]}, ambient ) );
        
        functors_on_mors := List( [ 1 .. l ], m -> AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mors[m] )[2][2] );
        
        rels := List( [ 1 .. l ], m ->
                      List( data[m][6], rel ->
                            PreCompose( L,
                                    functors_on_mors[m]( o, rel, o ),
                                    gens[m][nrsgens[m] + 1] ) ) ); ## project into the m-th factor
        
        rels := Concatenation( rels );
        
        ## get rid of the unnecessary central idempotents in the various summands,
        ## for the relations of the result to resemble the relations of the factors
        rels := List( rels, rel -> ReductionOfMorphism( L, rel, GB ) );
        
        return ObjectConstructor( FpAlg_k,
                       NTuple( 7,
                               L,
                               o,
                               nrgens,
                               Concatenation( gens ),
                               Sum( nrsrels ) + 2 * nrgens + (l - 1)^2,
                               Concatenation( rels, idem, orth_idem, central_idem, [ sum ] ),
                               nmgens ) );
        
    end );
    
    ##
    AddProjectionInFactorOfDirectProductWithGivenDirectProduct( FpAlg_k,
      function( FpAlg_k, diagram, p, product )
        local l, nrsgens, target, datum, L, o, gens, id, zero, func, images;
        
        l := Length( diagram );
        
        nrsgens := List( [ 1 .. l ], m -> DefiningSeptupleOfFinitelyPresentedAlgebra( diagram[m] )[3] );
        
        target := diagram[p];
        
        datum := DefiningSeptupleOfFinitelyPresentedAlgebra( target );
        
        L := datum[1];
        o := datum[2];
        gens := datum[4];
        
        id := IdentityMorphism( L, o );
        zero := ZeroMorphism( L, o, o );
        
        func :=
          function( m )
            
            if m = p then
                return Concatenation( gens, [ id ] );
            fi;
            
            return ListWithIdenticalEntries( nrsgens[m] + 1, zero );
            
        end;
        
        images := List( [ 1 .. l ], func );

        images := Concatenation( images );
        
        return MorphismConstructor( FpAlg_k,
                       product,
                       images,
                       target );
        
    end );
    
    ##
    AddUniversalMorphismIntoDirectProductWithGivenDirectProduct( FpAlg_k,
      function( FpAlg_k, diagram, source, test_morphisms, product )
        local l, data, nrsgens, datum, L, gens, idem, orth_idem, central_idem, GB,
              o, ambient, ambients, mors, functors_on_mors, images, nrgens_source;
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> DefiningSeptupleOfFinitelyPresentedAlgebra( diagram[m] ) );
        
        nrsgens := List( [ 1 .. l ], m -> data[m][3] );
        
        datum := DefiningSeptupleOfFinitelyPresentedAlgebra( product );
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, datum[3] = Sum( nrsgens ) + l );
        
        L := datum[1];
        
        gens := datum[4];
        
        gens := List( [ 1 .. l ], m -> gens{[ m + Sum( nrsgens{[ 1 .. m - 1 ]} ) .. m + Sum( nrsgens{[ 1 .. m ]} ) ]} );
        
        ## e_m⋅e_m = e_m
        idem := List( [ 1 .. l ], m ->
                      SubtractionForMorphisms( L,
                              PreCompose( L, gens[m][nrsgens[m] + 1], gens[m][nrsgens[m] + 1] ),
                              gens[m][nrsgens[m] + 1] ) );
        
        ## e_m⋅e_n = 0 for m ≠ n
        orth_idem := List( [ 1 .. l ], m ->
                           List( Concatenation( [ 1 .. m - 1 ], [ m + 1 .. l ] ), n ->
                                 PreCompose( L, gens[m][nrsgens[m] + 1], gens[n][nrsgens[n] + 1] ) ) );
        
        orth_idem := Concatenation( orth_idem );
        
        ## e_m⋅a = a = a⋅e_m for a in the m-the factor
        central_idem := List( [ 1 .. l ], m ->
                              List( [ 1 .. nrsgens[m] ], i ->
                                    [ SubtractionForMorphisms( L,
                                            PreCompose( L, gens[m][nrsgens[m] + 1], gens[m][i] ),
                                            gens[m][i] ),
                                      SubtractionForMorphisms( L,
                                            PreCompose( L, gens[m][i], gens[m][nrsgens[m] + 1] ),
                                            gens[m][i] ) ] ) );
        
        central_idem := Concatenation( Concatenation( central_idem ) );
        
        GB := ReducedGroebnerBasis( L, Concatenation( idem, orth_idem, central_idem ) );
        
        o := datum[2];
        
        ambient := AmbientAlgebra( product );
        
        ambients := List( [ 1 .. l ], m -> AmbientAlgebra( diagram[m] ) );
        
        mors := List( [ 1 .. l ], m -> MorphismConstructor( FpAlg_k, ambients[m], gens[m]{[ 1 .. nrsgens[m] ]}, ambient ) );
        
        functors_on_mors := List( [ 1 .. l ], m -> AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mors[m] )[2][2] );
        
        images := List( [ 1 .. l ], m ->
                        List( ListOfImages( test_morphisms[m] ), image ->
                              PreCompose( L,
                                      functors_on_mors[m]( o, image, o ),
                                      gens[m][nrsgens[m] + 1] ) ) ); ## project into the m-th factor
        
        nrgens_source := DefiningSeptupleOfFinitelyPresentedAlgebra( source )[3];
        
        images := List( [ 1 .. nrgens_source ], i -> SumOfMorphisms( o, List( [ 1 .. l ], m -> images[m][i] ), o ) );
        
        ## get rid of the unnecessary central idempotents in the various summands,
        ## for the images in the result to resemble the relations of the factors
        images := List( images, image -> ReductionOfMorphism( L, image, GB ) );
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       images,
                       product );
        
    end );
    
    ##
    AddCoproduct( FpAlg_k,
      function( FpAlg_k, diagram )
        local l, data, nrsgens, nrgens, ambients, var, nmgens, B, L, o, gens,
              ambient, mors, functors_on_mors, nrsrels, rels;
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> DefiningSeptupleOfFinitelyPresentedAlgebra( diagram[m] ) );
        
        nrsgens := List( [ 1 .. l ], m -> data[m][3] );
        
        nrgens := Sum( nrsgens );
        
        var := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "variable_name", "a" );
        
        nmgens := ParseListOfIndeterminates( [ Concatenation( var, "1..", String( nrgens ) ) ] );
        
        B := UnderlyingCategoryOfMatrices( FpAlg_k );
        
        L := CreateAmbientLinearClosureOfFpAlgebra( B, nrgens, var );
        
        o := SetOfObjects( L )[1];
        
        gens := List( nmgens, name -> L.(name) );
        
        ambient := ObjectConstructor( FpAlg_k,
                           NTuple( 7,
                                   L,
                                   o,
                                   nrgens,
                                   gens,
                                   0,
                                   CapJitTypedExpression( [ ], cat -> CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( L ) ) ),
                                   nmgens ) );
        
        gens := List( [ 1 .. l ], m -> gens{[ 1 + Sum( nrsgens{[ 1 .. m - 1 ]} ) .. Sum( nrsgens{[ 1 .. m ]} ) ]} );
        
        ambients := List( [ 1 .. l ], m -> AmbientAlgebra( diagram[m] ) );
        
        mors := List( [ 1 .. l ], m -> MorphismConstructor( FpAlg_k, ambients[m], gens[m], ambient ) );
        
        functors_on_mors := List( [ 1 .. l ], m -> AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mors[m] )[2][2] );
        
        nrsrels := List( [ 1 .. l ], m -> data[m][5] );
        
        rels := List( [ 1 .. l ], m ->
                      List( data[m][6], rel -> functors_on_mors[m]( o, rel, o ) ) );
        
        rels := Concatenation( rels );
        
        return ObjectConstructor( FpAlg_k,
                       NTuple( 7,
                               L,
                               o,
                               nrgens,
                               Concatenation( gens ),
                               Sum( nrsrels ),
                               rels,
                               nmgens ) );
        
    end );
    
    ##
    AddInjectionOfCofactorOfCoproductWithGivenCoproduct( FpAlg_k,
      function( FpAlg_k, diagram, p, coproduct )
        local l, data, nrsgens, gens, images;
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> DefiningSeptupleOfFinitelyPresentedAlgebra( diagram[m] ) );
        
        nrsgens := List( [ 1 .. l ], m -> data[m][3] );
        
        gens := DefiningSeptupleOfFinitelyPresentedAlgebra( coproduct )[4];
        
        images := gens{[ 1 + Sum( nrsgens{[ 1 .. p - 1 ]} ) .. Sum( nrsgens{[ 1 .. p ]} ) ]};
        
        return MorphismConstructor( FpAlg_k,
                       diagram[p],
                       images,
                       coproduct );
        
    end );
    
    ##
    AddUniversalMorphismFromCoproductWithGivenCoproduct( FpAlg_k,
      function( FpAlg_k, diagram, target, test_morphisms, coproduct )
        local l, images;
        
        l := Length( diagram );
        
        images := List( [ 1 .. l ], m -> ListOfImages( test_morphisms[m] ) );
        
        return MorphismConstructor( FpAlg_k,
                       coproduct,
                       Concatenation( images ),
                       target );
        
    end );
    
    ##
    AddTensorUnit( FpAlg_k,
      function( FpAlg_k )
        
        return InitialObject( FpAlg_k );
        
    end );
    
    ##
    AddTensorProductOnObjects( FpAlg_k,
      function( FpAlg_k, fp_algebra1, fp_algebra2 )
        local datum1, datum2, nrgens1, nrgens2, nrgens, ambient1, ambient2,
              var, nmgens, B, L, o, gens, gens1, gens2, ambient,
              mor1, mor2, functor1_on_mors, functor2_on_mors, nrrels, rels1, rels2, rels, mixed;
        
        datum1 := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra1 );
        datum2 := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra2 );
        
        nrgens1 := datum1[3];
        nrgens2 := datum2[3];
        
        nrgens := nrgens1 + nrgens2;
        
        ambient1 := AmbientAlgebra( fp_algebra1 );
        ambient2 := AmbientAlgebra( fp_algebra2 );
        
        var := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "variable_name", "a" );
        
        nmgens := ParseListOfIndeterminates( [ Concatenation( var, "1..", String( nrgens ) ) ] );
        
        B := UnderlyingCategoryOfMatrices( FpAlg_k );
        
        L := CreateAmbientLinearClosureOfFpAlgebra( B, nrgens, var );
        
        o := SetOfObjects( L )[1];
        
        gens := List( nmgens, name -> L.(name) );
        
        ambient := ObjectConstructor( FpAlg_k,
                           NTuple( 7,
                                   L,
                                   o,
                                   nrgens,
                                   gens,
                                   0,
                                   CapJitTypedExpression( [ ], cat -> CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( L ) ) ),
                                   nmgens ) );
        
        gens1 := gens{[ 1 .. nrgens1 ]};
        gens2 := gens{[ nrgens1 + 1 .. nrgens ]};
        
        mor1 := MorphismConstructor( FpAlg_k, ambient1, gens1, ambient );
        mor2 := MorphismConstructor( FpAlg_k, ambient2, gens2, ambient );
        
        functor1_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor1 )[2][2];
        functor2_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor2 )[2][2];
        
        nrrels := datum1[5] + datum2[5];
        
        rels1 := List( datum1[6], rel -> functor1_on_mors( o, rel, o ) );
        rels2 := List( datum2[6], rel -> functor2_on_mors( o, rel, o ) );
        
        rels := Concatenation( rels1, rels2 );
        
        mixed := List( [ 1 .. nrgens1 ], i ->
                       List( [ 1 .. nrgens2 ], j ->
                             SubtractionForMorphisms( L,
                                     PreCompose( L, gens1[i], gens2[j] ),
                                     PreCompose( L, gens2[j], gens1[i] ) ) ) );
        
        mixed := Concatenation( mixed );
        
        return ObjectConstructor( FpAlg_k,
                       NTuple( 7,
                               L,
                               o,
                               nrgens,
                               gens,
                               nrrels + nrgens1 * nrgens2,
                               Concatenation( rels, mixed ),
                               nmgens ) );
        
    end );
    
    ##
    AddTensorProductOnMorphismsWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, fp_algebra_morphism1, fp_algebra_morphism2, target )
        local target1, target2, ambient_target1, ambient_target2, ngens1, ngens2,
              ambient_target, datum, ngens, gens, gens1, gens2, mor1, mor2,
              functor1_on_mors, functor2_on_mors, o, list_of_images1, list_of_images2,
              list_of_images;
        
        target1 := Target( fp_algebra_morphism1 );
        target2 := Target( fp_algebra_morphism2 );
        
        ambient_target1 := AmbientAlgebra( target1 );
        ambient_target2 := AmbientAlgebra( target2 );
        
        ngens1 := DefiningSeptupleOfFinitelyPresentedAlgebra( ambient_target1 )[3];
        ngens2 := DefiningSeptupleOfFinitelyPresentedAlgebra( ambient_target2 )[3];
        
        ambient_target := AmbientAlgebra( target );
        
        datum := DefiningSeptupleOfFinitelyPresentedAlgebra( ambient_target );
        
        ngens := datum[3];
        gens := datum[4];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, ngens = ngens1 + ngens2 );
        
        gens1 := gens{[ 1 .. ngens1 ]};
        gens2 := gens{[ ngens1 + 1 .. ngens ]};
        
        mor1 := MorphismConstructor( FpAlg_k,
                        ambient_target1,
                        gens1,
                        ambient_target );
        
        mor2 := MorphismConstructor( FpAlg_k,
                        ambient_target2,
                        gens2,
                        ambient_target );
        
        functor1_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor1 )[2][2];
        functor2_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor2 )[2][2];
        
        o := datum[2];
        
        list_of_images1 := ListOfImages( fp_algebra_morphism1 );
        list_of_images2 := ListOfImages( fp_algebra_morphism2 );
        
        list_of_images := Concatenation(
                                  List( list_of_images1, image -> functor1_on_mors( o, image, o ) ),
                                  List( list_of_images2, image -> functor2_on_mors( o, image, o ) ) );
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       list_of_images,
                       target );
        
    end );
    
    ##
    AddLeftUnitorWithGivenTensorProduct( FpAlg_k,
      function( FpAlg_k, fp_algebra, source )
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra )[4],
                       fp_algebra );
        
    end );
    
    ##
    AddLeftUnitorInverseWithGivenTensorProduct( FpAlg_k,
      function( FpAlg_k, fp_algebra, target )
        
        return MorphismConstructor( FpAlg_k,
                       fp_algebra,
                       DefiningSeptupleOfFinitelyPresentedAlgebra( target )[4],
                       target );
        
    end );
    
    ##
    AddRightUnitorWithGivenTensorProduct( FpAlg_k,
      function( FpAlg_k, fp_algebra, source )
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra )[4],
                       fp_algebra );
        
    end );
    
    ##
    AddRightUnitorInverseWithGivenTensorProduct( FpAlg_k,
      function( FpAlg_k, fp_algebra, target )
        
        return MorphismConstructor( FpAlg_k,
                       fp_algebra,
                       DefiningSeptupleOfFinitelyPresentedAlgebra( target )[4],
                       target );
        
    end );
    
    ##
    AddAssociatorLeftToRightWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, fp_algebra1, fp_algebra2, fp_algebra3, target )
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       DefiningSeptupleOfFinitelyPresentedAlgebra( target )[4],
                       target );
        
    end );
    
    ##
    AddAssociatorRightToLeftWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, fp_algebra1, fp_algebra2, fp_algebra3, target )
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       DefiningSeptupleOfFinitelyPresentedAlgebra( target )[4],
                       target );
        
    end );
    
    ##
    AddBraidingWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, fp_algebra1, fp_algebra2, target )
        local nrgens1, nrgens2, datum, nrgens, gens;
        
        nrgens1 := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra1 )[3];
        nrgens2 := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra2 )[3];
        
        datum := DefiningSeptupleOfFinitelyPresentedAlgebra( target );
        
        nrgens := datum[3];
        gens := datum[4];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, nrgens = nrgens1 + nrgens2 );
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       Concatenation( gens{[ nrgens2 + 1 .. nrgens ]}, gens{[ 1 .. nrgens2 ]} ),
                       target );
        
    end );
    
    ##
    AddBraidingInverseWithGivenTensorProducts( FpAlg_k,
      function( FpAlg_k, source, fp_algebra1, fp_algebra2, target )
        local nrgens1, nrgens2, datum, nrgens, gens;
        
        nrgens1 := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra1 )[3];
        nrgens2 := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra2 )[3];
        
        datum := DefiningSeptupleOfFinitelyPresentedAlgebra( target );
        
        nrgens := datum[3];
        gens := datum[4];
        
        #% CAP_JIT_DROP_NEXT_STATEMENT
        Assert( 0, nrgens = nrgens1 + nrgens2 );
        
        return MorphismConstructor( FpAlg_k,
                       source,
                       Concatenation( gens{[ nrgens1 + 1 .. nrgens ]}, gens{[ 1 .. nrgens1 ]} ),
                       target );
        
    end );
    
    ##
    AddCoequalizer( FpAlg_k,
      function( FpAlg_k, target, diagram )
        local datum, L, l, data, rels, all_rels;
        
        ## if the diagram is empty there is no source
        
        datum := DefiningSeptupleOfFinitelyPresentedAlgebra( target );
        
        L := datum[1];
        
        l := Length( diagram );
        
        data := List( [ 1 .. l ], m -> ListOfImages( diagram[m] ) );
        
        rels := Concatenation( List( [ 1 .. l - 1 ], m -> data[m] - data[m + 1] ) );
        
        all_rels := Concatenation( rels, datum[6] );
        
        all_rels := Filtered( all_rels, rel -> not IsZeroForMorphisms( L, rel ) );
        
        return ObjectConstructor( FpAlg_k,
                       NTuple( 7,
                               datum[1],
                               datum[2],
                               datum[3],
                               datum[4],
                               Length( all_rels ),
                               all_rels,
                               datum[7] ) );
        
    end );
    
    ##
    AddProjectionOntoCoequalizerWithGivenCoequalizer( FpAlg_k,
      function( FpAlg_k, target, diagram, coequalizer )
        
        return MorphismConstructor( FpAlg_k,
                       target,
                       DefiningSeptupleOfFinitelyPresentedAlgebra( coequalizer )[4],
                       coequalizer );
        
    end );
    
    ##
    AddUniversalMorphismFromCoequalizerWithGivenCoequalizer( FpAlg_k,
      function( FpAlg_k, target, diagram, T, test_morphisms, coequalizer )
        
        return MorphismConstructor( FpAlg_k,
                       coequalizer,
                       ListOfImages( test_morphisms ),
                       T );
        
    end );
    
    if CAP_NAMED_ARGUMENTS.FinalizeCategory then
        Finalize( FpAlg_k );
    fi;
    
    return FpAlg_k;
    
end ) );

##
InstallMethod( CategoryOfFpAlgebras,
        "for a homalg ring",
        [ IsHomalgRing and IsCommutative ],
        
  function( k )
    
    return CategoryOfFpAlgebras( CategoryOfRows( k ) );
    
end );

##
InstallMethod( CoefficientsRing,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    
    return CoefficientsRing( CapCategory( fp_algebra ) );
    
end );

##
InstallMethod( NrGenerators,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    
    return DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra )[3];
    
end );

##
InstallMethod( Generators,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    
    return DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra )[4];
    
end );

##
InstallMethod( AssociatedLinearClosureOfPathCategory,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    
    return DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra )[1];
    
end );

##
InstallMethod( DefiningRelations,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    
    return DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra )[6];
    
end );

##
InstallMethod( AssociatedQuotientCategoryOfLinearClosureOfPathCategory,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    local FpAlg_k;
    
    FpAlg_k := CapCategory( fp_algebra );
    
    return QuotientCategory( AssociatedLinearClosureOfPathCategory( fp_algebra ), DefiningRelations( fp_algebra )
                   : range_of_HomStructure := UnderlyingCategoryOfMatrices( FpAlg_k ) );
    
end );

##
InstallMethod( GroebnerBasisOfDefiningRelations,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    
    ## using GroebnerBasisOfDefiningRelations( AssociatedQuotientCategoryOfLinearClosureOfPathCategory( fp_algebra ) )
    ## would trigger the more expensive HasFiniteNumberOfMacaulayMorphisms
    return ReducedGroebnerBasis( AssociatedLinearClosureOfPathCategory( fp_algebra ), DefiningRelations( fp_algebra ) );
    
end );

##
InstallMethod( Dimension,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    local k, quotient;
    
    k := CommutativeRingOfLinearCategory( AssociatedLinearClosureOfPathCategory( fp_algebra ) );
    
    if not ( HasIsFieldForHomalg( k ) and IsFieldForHomalg( k ) ) then
        Print( "WARNING: the underlying commutative ring `k` is either not a field or not yet marked as a field\n" );
    fi;
    
    quotient := AssociatedQuotientCategoryOfLinearClosureOfPathCategory( fp_algebra );
    
    if HasIsEquippedWithHomomorphismStructure( quotient ) and IsEquippedWithHomomorphismStructure( quotient ) and
       HasRangeCategoryOfHomomorphismStructure( quotient ) and
       MissingOperationsForConstructivenessOfCategory( quotient, "IsEquippedWithHomomorphismStructure" ) = [ ]  then
        
        ## there are finitely many Macaulay morphisms
        return Dimension( quotient );
        
    else
        
        ## there are infinitely many Macaulay morphisms
        return infinity;
        
    fi;
    
end );

##
InstallOtherMethodForCompilerForCAP( AmbientAlgebra,
        "for a category of finitely presented algebras and an algebra therein",
        [ IsCategoryOfFpAlgebras, IsObjectInCategoryOfFpAlgebras ],
        
  function( FpAlg_k, fp_algebra )
    local datum;
    
    datum := DefiningSeptupleOfFinitelyPresentedAlgebra( fp_algebra );
    
    return ObjectConstructor( FpAlg_k,
                   NTuple( 7,
                           datum[1],
                           datum[2],
                           datum[3],
                           datum[4],
                           0,
                           CapJitTypedExpression( [ ], cat -> CapJitDataTypeOfListOf( CapJitDataTypeOfMorphismOfCategory( datum[1] ) ) ),
                           datum[7] ) );
    
end );

##
InstallMethod( AmbientAlgebra,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    
    return AmbientAlgebra( CapCategory( fp_algebra ), fp_algebra );
    
end );

##
InstallMethod( \/,
        "for a linear category and a category of finitely presented algebras",
        [ IsCapCategory and IsLinearCategoryOverCommutativeRing, IsCategoryOfFpAlgebras ],
        
  function( fp_linear_category_on_one_object, FpAlg_k )
    local k, L, relations, object, generators, get_labels, fp_algebra;
    
    Assert( 0, IsLinearClosure( fp_linear_category_on_one_object ) or IsQuotientCategory( fp_linear_category_on_one_object ) );
    
    k := CommutativeRingOfLinearCategory( fp_linear_category_on_one_object );
    
    if IsLinearClosure( fp_linear_category_on_one_object ) then
        L := fp_linear_category_on_one_object;
        relations := [ ];
    else
        Assert( 0, HasAmbientCategory( fp_linear_category_on_one_object ) and HasDefiningRelations( fp_linear_category_on_one_object ) );
        L := AmbientCategory( fp_linear_category_on_one_object );
        relations := DefiningRelations( fp_linear_category_on_one_object );
    fi;
    
    object := SetOfObjects( L )[1];
    
    generators := SetOfGeneratingMorphisms( L );
    
    get_labels :=
      function( gen )
        local coef, supp, g;
        
        coef := CoefficientsList( gen );
        supp := SupportMorphisms( gen );
        
        Assert( 0, Length( coef ) = 1 and coef[1] in k and IsOne( coef[1] ) );
        Assert( 0, Length( supp ) = 1 );
        
        return MorphismLabel( supp[1] );
        
    end;
    
    fp_algebra := ObjectConstructor( FpAlg_k,
                          NTuple( 7,
                                  L,
                                  object,
                                  Length( generators ),
                                  generators,
                                  Length( relations ),
                                  relations,
                                  List( generators, get_labels ) ) );
    
    if HasRangeCategoryOfHomomorphismStructure( fp_linear_category_on_one_object ) and
       IsIdenticalObj( RangeCategoryOfHomomorphismStructure( fp_linear_category_on_one_object ), UnderlyingCategoryOfMatrices( FpAlg_k ) ) then
        
        SetAssociatedQuotientCategoryOfLinearClosureOfPathCategory( fp_algebra, fp_linear_category_on_one_object );
        
    fi;
    
    return fp_algebra;
    
end );

##
InstallOtherMethod( \/,
        "for a for a finitely presented algebra and a list",
        [ IsObjectInCategoryOfFpAlgebras, IsList ],
        
  function( A, relations )
    local FpAlg_k, L, k, object, generators, get_labels;
    
    FpAlg_k := CapCategory( A );
    
    L := AssociatedLinearClosureOfPathCategory( A );
    
    Assert( 0, Length( DefiningRelations( A ) ) = 0 );
    
    k := CommutativeRingOfLinearCategory( L );
    
    object := SetOfObjects( L )[1];
    
    generators := SetOfGeneratingMorphisms( L );
    
    get_labels :=
      function( gen )
        local coef, supp, g;
        
        coef := CoefficientsList( gen );
        supp := SupportMorphisms( gen );
        
        Assert( 0, Length( coef ) = 1 and coef[1] in k and IsOne( coef[1] ) );
        Assert( 0, Length( supp ) = 1 );
        
        return MorphismLabel( supp[1] );
        
    end;
    
    return ObjectConstructor( FpAlg_k,
                   NTuple( 7,
                           L,
                           object,
                           Length( generators ),
                           generators,
                           Length( relations ),
                           relations,
                           List( generators, get_labels ) ) );
    
end );

##
InstallMethod( \.,
        "for a finitely presented algebra and a positive integer",
        [ IsObjectInCategoryOfFpAlgebras, IsPosInt ],
        
  function( fp_algebra, string_as_int )
    local name;
    
    name := NameRNam( string_as_int );
    
    ## never use AssociatedQuotientCategoryOfLinearClosureOfPathCategory below since it
    ## will trigger a GB computation followed by a HasFiniteNumberOfMacaulayMorphisms/MacaulayMorphisms:
    return AssociatedLinearClosureOfPathCategory( fp_algebra ).(name);
    
end );

##
InstallMethodForCompilerForCAP( AssociatedFunctorOfLinearClosuresOfPathCategoriesData,
        "for a category of finitely presented algebras and a finitely presented algebra morphism therein",
        [ IsCategoryOfFpAlgebras, IsMorphismInCategoryOfFpAlgebras ],
        
  function( FpAlg_k, fp_algebra_morphism )
    local S, T, path_cat, image_of_unique_object, images_of_generating_morphism;
    
    S := DefiningSeptupleOfFinitelyPresentedAlgebra( Source( fp_algebra_morphism ) )[1];
    T := DefiningSeptupleOfFinitelyPresentedAlgebra( Target( fp_algebra_morphism ) )[1];
    
    path_cat := UnderlyingCategory( S );
    
    image_of_unique_object := SetOfObjects( T );
    images_of_generating_morphism := ListOfImages( fp_algebra_morphism );
    
    return ExtendFunctorToAlgebroidData(
                   S,
                   ExtendFunctorToFpCategoryData(
                           path_cat,
                           ## quiver_of_S → T
                           Pair( obj_in_quiver_S -> image_of_unique_object[obj_in_quiver_S],
                                 mor_in_quiver_S -> images_of_generating_morphism[mor_in_quiver_S] ),
                           T )[2],
                   T );
    
end );

##
InstallMethodForCompilerForCAP( EvaluateFpAlgebraMorphism,
        "for a category of finitely presented algebras, a morphism therein, a linear category, an object therein, and a list of endomorphisms thereof",
        [ IsCategoryOfFpAlgebras, IsMorphismInCategoryOfFpAlgebras, IsCapCategory, IsCapCategoryObject, IsList ],
        
  function( FpAlg_k, fp_algebra_morphism, V, rep_obj, rep_mors )
    local nr_gens_source, L, images;
    
    nr_gens_source := DefiningSeptupleOfFinitelyPresentedAlgebra( Source( fp_algebra_morphism ) )[3];
    
    L := DefiningSeptupleOfFinitelyPresentedAlgebra( Target( fp_algebra_morphism ) )[1];
    
    images := ListOfImages( fp_algebra_morphism );
    
    return List( [ 1 .. nr_gens_source ], i -> EvaluateLinearClosureMorphism( L, images[i], V, rep_obj, rep_mors ) );
    
end );

##
InstallMethod( Counit,
        "for a finitely presented algebra and a list",
        [ IsObjectInCategoryOfFpAlgebras, IsList ],
        
  function( fp_algebra, counit_on_generators )
    local FpAlg_k, U, id;
    
    FpAlg_k := CapCategory( fp_algebra );
    
    U := TensorUnit( FpAlg_k );
    
    id := U.id_o;
    
    return MorphismConstructor( FpAlg_k,
                   fp_algebra,
                   List( counit_on_generators, r -> r * id ),
                   U );
    
end );

##
InstallMethod( Comultiplication,
        "for a finitely presented algebra and a list",
        [ IsObjectInCategoryOfFpAlgebras, IsList ],
        
  function( fp_algebra, list_of_images_of_comult )
    local FpAlg_k, fp_algebra_square, nrgens, nrgens2, Q, basis, d, basis_pairs, normalize_input, gens, gens1, gens2,
          ambient, ambient_square, mor1, mor2, functor1_on_mors, functor2_on_mors, o_square;
    
    FpAlg_k := CapCategory( fp_algebra );
    
    fp_algebra_square := TensorProductOnObjects( FpAlg_k, fp_algebra, fp_algebra );
    
    nrgens := NrGenerators( fp_algebra );
    
    nrgens2 := NrGenerators( fp_algebra_square );
    
    Assert( 0, 2 * nrgens = nrgens2 );
    
    if ForAny( list_of_images_of_comult, image -> IsList( image ) and ForAny( image, IsRingElement ) ) then
        
        Q := AssociatedQuotientCategoryOfLinearClosureOfPathCategory( fp_algebra );
        
        Assert( 0, CanCompute( Q, "BasisOfExternalHom" ) );
        
        basis := List( BasisOfExternalHom( Q.o, Q.o ), MorphismDatum );
        
        d := Length( basis );
        
        ## must be compatible with corresponding line in method LinearCategoryOnOneObjectAsInternalMonoid (or \/ above it)
        basis_pairs := List( basis, l ->
                             List( basis, r ->
                                   Pair( l, r ) ) );
        
        basis_pairs := Concatenation( basis_pairs );
        
        normalize_input :=
          function( image )
            if IsList( image ) and Length( image ) = d^2 and ForAll( image, IsRingElement ) then
                return List( [ 1 .. d^2 ], i -> Pair( image[i] * basis_pairs[i][1], basis_pairs[i][2] ) );
            else
                return image;
            fi;
        end;
        
        list_of_images_of_comult := List( list_of_images_of_comult, normalize_input );
        
    fi;
    
    Assert( 0, ForAll( list_of_images_of_comult, list -> ForAll( list, pair -> IsList( pair ) and Length( pair ) = 2 and ForAll( pair, IsLinearClosureMorphism ) ) ) );
    
    gens := Generators( fp_algebra_square );
    
    gens1 := gens{[ 1 .. nrgens ]};
    gens2 := gens{[ nrgens + 1 .. nrgens2 ]};
    
    ambient := AmbientAlgebra( fp_algebra );
    ambient_square := AmbientAlgebra( fp_algebra_square );
    
    mor1 := MorphismConstructor( FpAlg_k, ambient, gens1, ambient_square );
    mor2 := MorphismConstructor( FpAlg_k, ambient, gens2, ambient_square );
    
    functor1_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor1 )[2][2];
    functor2_on_mors := AssociatedFunctorOfLinearClosuresOfPathCategoriesData( FpAlg_k, mor2 )[2][2];
    
    o_square := SetOfObjects( AssociatedLinearClosureOfPathCategory( fp_algebra_square ) )[1];
    
    return MorphismConstructor( FpAlg_k,
                   fp_algebra,
                   List( list_of_images_of_comult, list ->
                         Sum( list, pair ->
                              functor1_on_mors( o_square, pair[1], o_square ) * functor2_on_mors( o_square, pair[2], o_square ) ) ),
                   fp_algebra_square );
    
end );

####################################
#
# View, Print, Display and LaTeX methods:
#
####################################

##
InstallMethod( DisplayString,
        "for a finitely presented algebra",
        [ IsObjectInCategoryOfFpAlgebras ],
        
  function( fp_algebra )
    local k, datum, gens, q, str, rels;
    
    k := CoefficientsRing( CapCategory( fp_algebra ) );
    
    datum := ObjectDatum( fp_algebra );
    
    if datum[3] > 0 then
        gens := Concatenation( "<", JoinStringsWithSeparator( datum[7] ), ">" );
    else
        gens := "";
    fi;
    
    q := UnderlyingQuiver( datum[1] );
    
    if datum[5] > 3 then
        str := ", ...";
    else
        str := "";
    fi;
    
    rels := datum[6];
    
    rels := rels{[ 1 .. Minimum( 3, datum[5] ) ]};
    
    rels := Concatenation( " / [ ", JoinStringsWithSeparator( List( rels, rel -> CAP_INTERNAL_EXTRACT_STRING_OF_PATH( q, rel ) ), ", " ), str, " ]" );
    
    return Concatenation( RingName( k ), gens, rels, "\n" );
    
end );

##
InstallMethod( DisplayString,
        "for a finitely presented algebra morphism",
        [ IsMorphismInCategoryOfFpAlgebras ],
        
  function( fp_algebra_morphism )
    local q, images;
    
    q := UnderlyingQuiver( AssociatedLinearClosureOfPathCategory( Source( fp_algebra_morphism ) ) );
    
    images := MorphismDatum( fp_algebra_morphism );
    
    images := Concatenation( "[ ", JoinStringsWithSeparator( List( images, image -> CAP_INTERNAL_EXTRACT_STRING_OF_PATH( q, image ) ), ", " ), " ]\n" );
    
    return Concatenation(
                   DisplayString( Target( fp_algebra_morphism ) ),
                   " ^\n |\n",
                   images,
                   " |\n",
                   DisplayString( Source( fp_algebra_morphism ) ) );
    
end );
