# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Declarations
#

#! @Chapter Algebroids from data tables

####################################
#
#! @Section GAP categories
#
####################################

#! @Description
#!  The &GAP; category of objects in an algebroid from data tables.
DeclareCategory( "IsAlgebroidFromDataTables",
        IsCapCategory );

#! @Description
#!  The &GAP; category of cells in an algebroid from data tables.
DeclareCategory( "IsCellInAlgebroidFromDataTables",
        IsCapCategoryCell );

#! @Description
#!  The &GAP; category of algebroids from data tables.
DeclareCategory( "IsObjectInAlgebroidFromDataTables",
        IsCellInAlgebroidFromDataTables and
        IsCapCategoryObject );

#! @Description
#!  The &GAP; category of morphisms in an algebroid from data tables.
DeclareCategory( "IsMorphismInAlgebroidFromDataTables",
        IsCellInAlgebroidFromDataTables and
        IsCapCategoryMorphism );

####################################
#
#! @Section Constructors
#
####################################

#! @Description
#!  Construct an enrichted algebroid $A$ out of the <A>data_tables</A> consisting of $7$ entries:
#!  * <A>data_tables</A>[1] is the commutative ring $k$ over which $A$ is linear.
#!  * <A>data_tables</A>[2] is the underlying quiver or a string that can be used to constructe a CAP quiver. Suppose the number of objects is <C>nr_objs</C> and
#!    the number of morphisms is <C>nr_mors</C>.
#!  * <A>data_tables</A>[3]: an array $L$ containing <C>nr_objs</C> rows and <C>nr_objs</C> columns.
#!    The entry $L[i][j]$ is the list of the indices of the basis elements of $\mathrm{Hom}_{A}(v_i,v_j)$ where $v_i$ and $v_j$ are the $i$'th resp. $j$'th objects.
#!  * <A>data_tables</A>[4]: an array $L$ containing <C>nr_objs</C> rows and <C>nr_mors</C> columns.
#!    The entry $L[i][j]$ contains the matrices of the $k$-linear maps $\mathrm{Hom}_{A}(v_i,m_j)$ where $u_i$ and $m_j$ are the $i$'th object and the $j$'th generating morphism.
#!  * <A>data_tables</A>[5]: an array $L$ containing <C>nr_objs</C> rows and <C>nr_mors</C> columns.
#!    The entry $L[i][j]$ contains the matrices of the $k$-linear maps $\mathrm{Hom}_{A}(m_j,v_i)$ where $u_i$ and $m_j$ are the $i$'th object and the $j$'th generating morphism.
#! @Arguments data_tables
#! @Returns a &CAP; category
DeclareOperation( "AlgebroidFromDataTables", [ IsDenseList ] );
#! @InsertChunk AlgebroidFromDataTables

####################################
#
#! @Section Attributes
#
####################################

#! @Description
#!  The arguments are an algebroid $A$ and a list <A>I</A> of morphisms in $A$.
#!  The output is the quotient category $A/I$ of $A$ modulo the two-sided ideal of morphisms generated by <A>I</A>.
#! @Arguments A, I
#! @Returns a record
DeclareOperation( "QuotientCategory",
        [ IsAlgebroidFromDataTables, IsDenseList ] );

#! @Description
#!  The data tables used to define $A$.
#! @Arguments A
#! @Returns a record
DeclareAttribute( "CategoryDatum",
        IsAlgebroidFromDataTables );

#! @Description
#!  The argument is an algebroid <A>A</A>.
#!  The output is a list of lists $L$ where $L[i][j]$ is the basis of the external hom $\mathrm{Hom}_B(u,v)$ where $u$ and $v$ are $i$'th resp. $j$'th objects in $A$.
#! @Arguments A
#! @Returns a list of lists
DeclareAttribute( "BasesElements", IsAlgebroidFromDataTables );

CapJitAddTypeSignature( "BasesElements", [ IsAlgebroidFromDataTables ],
  function ( input_types )
    
    return CapJitDataTypeOfListOf(
              CapJitDataTypeOfListOf(
                CapJitDataTypeOfListOf(
                  CapJitDataTypeOfMorphismOfCategory( input_types[1].category ) ) ) );
    
end );

#! @Description
#!  The argument is an algebroid <A>A</A>.
#!  The output is a list of lists $L$ where $L[i][j]$ is the decomposition indices of the basis elements of $\mathrm{Hom}_B(u,v)$ where $u$ and $v$ are $i$'th resp. $j$'th objects in $A$.
#!  In other words, it is the third entry in the underlying defining data tables.
#! @Arguments A
#! @Returns a list of lists
DeclareAttribute( "DecompositionIndicesOfBasesElements", IsAlgebroidFromDataTables );

CapJitAddTypeSignature( "DecompositionIndicesOfBasesElements", [ IsAlgebroidFromDataTables ],
  function ( input_types )
    
    return CapJitDataTypeOfListOf(
              CapJitDataTypeOfListOf(
                CapJitDataTypeOfListOf(
                  CapJitDataTypeOfListOf( IsInt ) ) ) );
    
end );

#! @Description
#!  The argument is an algebroid <A>A</A>.
#!  The output is a list of lists $L$ where $L[i][j]$ is the labels of the basis elements of $\mathrm{Hom}_B(u,v)$ where $u$ and $v$ are $i$'th resp. $j$'th objects in $A$.
#! @Arguments A
#! @Returns a list of lists
DeclareAttribute( "LabelsOfBasesElements", IsAlgebroidFromDataTables );

#! @Description
#!  The argument is an algebroid <A>A</A>.
#!  The output is a list of lists $L$ where $L[i][j]$ is the latex strings of the basis elements of $\mathrm{Hom}_B(u,v)$ where $u$ and $v$ are $i$'th resp. $j$'th objects in $A$.
#! @Arguments A
#! @Returns a list of lists
DeclareAttribute( "LaTeXStringsOfBasesElements", IsAlgebroidFromDataTables );

DeclareAttribute( "HomomorphismStructureOnObjectsRanks", IsAlgebroidFromDataTables );

CapJitAddTypeSignature( "HomomorphismStructureOnObjectsRanks", [ IsAlgebroidFromDataTables ],
  function ( input_types )
    
    return CapJitDataTypeOfListOf(
              CapJitDataTypeOfListOf( IsInt ) );
    
end );

DeclareAttribute( "HomomorphismStructureOnMorphismsMatrices", IsAlgebroidFromDataTables );

CapJitAddTypeSignature( "HomomorphismStructureOnMorphismsMatrices", [ IsAlgebroidFromDataTables ],
  function ( input_types )
    local ring;
    
    ring := CommutativeRingOfLinearCategory( input_types[1].category );
    
    return CapJitDataTypeOfListOf(
              CapJitDataTypeOfListOf(
                  CapJitDataTypeOfListOf(
                      CapJitDataTypeOfListOf(
                          CapJitDataTypeOfListOf(
                              CapJitDataTypeOfListOf(
                                rec( filter := IsHomalgMatrix, ring := ring ) ) ) ) ) ) );

    
end );

#! @Description
#!  The arguments are an algebroid <A>A</A> and a non-negative integer <A>i</A>.
#!  The output is a generating set for $\mathfrak{m}^i$ where $\mathfrak{m}$ is
#!  the ideal generated by all generating morphisms in <A>A</A>.
#! @Arguments A, i
#! @Returns a list
KeyDependentOperation( "PowerOfArrowIdeal", IsAlgebroidFromDataTables, IsInt, ReturnTrue );

####################################
#
#! @Section Properties
#
####################################

#! @Description
#!  The arguments are an algebroid <A>A</A> linear over a field $k$.
#!  This output is <C>true</C> iff the following two conditions hold:
#!  (1) the union of all identity morphisms and all generating morphism
#!  remain linear independent in the quotient category $C/\mathfrak{m}^2$;
#!  (2) $\mathfrak{m}^i=0$ for some $i\in\mathbb{N}$,
#!  where $\mathfrak{m}^i=$<C>PowerOfArrowIdeal</C>(<A>A</A>,$i$).
#! @Arguments A, i
#! @Returns a list
DeclareProperty( "IsAdmissibleAlgebroid", IsAlgebroidFromDataTables );
#! @InsertChunk AdmissibleAlgebroidFromDataTables

####################################
#
#! @Section Operations
#
####################################

#! @Description
#!  The arguments are an algebroid <A>A</A> and a string <A>optional_string</A>.
#!  This operation assigns the objects of <A>A</A> to global variables.
#!  Names of the variables are the concatenation of the labels of the objects of <A>A</A> with <A>optional_string</A>.
#!  The default value of <A>optional_string</A> is the empty string.
#! @Arguments A [, optional_string]
#! @Returns nothing
DeclareOperation( "AssignSetOfObjects",
        [ IsAlgebroidFromDataTables, IsString ] );

#! @Description
#!  The arguments are an algebroid <A>A</A> and a string <A>optional_string</A>.
#!  This operation assigns the generating morphisms of <A>A</A> to global variables.
#!  Names of the variables are the concatenation of the labels of the generating morphisms of <A>A</A> with <A>optional_string</A>.
#!  The default value of <A>optional_string</A> is the empty string.
#! @Arguments A [, optional_string]
#! @Returns nothing
DeclareOperation( "AssignSetOfGeneratingMorphisms",
        [ IsAlgebroidFromDataTables, IsString ] );

#! @Description
#!  The argument is an object <A>v</A> in an algebroid <A>A</A>.
#!  The output is the index of <A>v</A> in <C>SetOfObjects</C>(<A>A</A>).
#! @Arguments v
#! @Returns an integer
DeclareAttribute( "ObjectIndex", IsObjectInAlgebroidFromDataTables );

CapJitAddTypeSignature( "ObjectIndex", [ IsObjectInAlgebroidFromDataTables ], IsInt );

#! @Description
#!  The argument is a morphism <A>alpha</A> in an algebroid <A>A</A>.
#!  The output is the list of coefficients of <A>alpha</A> with respect to the basis of external hom $\mathrm{Hom}_B(u,v)$ where $u$ and $v$ are source resp. target of <A>alpha</A>.
#! @Arguments alpha
#! @Returns a &CAP; category morphism
DeclareAttribute( "CoefficientsList", IsMorphismInAlgebroidFromDataTables );

CapJitAddTypeSignature( "CoefficientsList", [ IsMorphismInAlgebroidFromDataTables ], function ( input_types )
    
    return CapJitDataTypeOfListOf( CapJitDataTypeOfElementOfRing( CategoryDatum( input_types[1].category )[1] ) );
    
end );

#! @Description
#!  The argument is a morphism <A>alpha</A> in an algebroid <A>A</A>.
#!  The output is the indices of the non-zero entries of <C>CoefficientsList</C>(<A>alpha</A>).
#! @Arguments alpha
#! @Returns a &CAP; category morphism
DeclareAttribute( "IndicesOfSupportMorphisms", IsMorphismInAlgebroidFromDataTables );

CapJitAddTypeSignature( "IndicesOfSupportMorphisms", [ IsMorphismInAlgebroidFromDataTables ], function ( input_types )
    
    return CapJitDataTypeOfListOf( IsInt );
    
end );

#! @Description
#!  The argument is a morphism <A>alpha</A> in an algebroid <A>A</A>.
#!  The output is the list of elements in <C>CoefficientsList</C>(<A>alpha</A>) that correspond to <C>IndicesOfSupportMorphisms</C>(<A>alpha</A>).
#! @Arguments alpha
#! @Returns a &CAP; category morphism
DeclareAttribute( "CoefficientsOfSupportMorphisms", IsMorphismInAlgebroidFromDataTables );

#! @Description
#!  The argument is a morphism <A>alpha</A> from <A>u</A> to <A>v</A> in an algebroid <A>A</A>.
#!  The output is the list of elements in <C>BasisOfExternalHom</C>(<A>u,v</A>) that correspond to <C>IndicesOfSupportMorphisms</C>(<A>alpha</A>).
#! @Arguments alpha
#! @Returns a &CAP; category morphism
DeclareAttribute( "SupportMorphisms", IsMorphismInAlgebroidFromDataTables );

#! @Description
#!  The argument is a morphism <A>alpha</A> in an algebroid $A$ (over a commutative ring $k$).
#!  The output is a list of pairs $L=[[c_1,l_1],..,[c_n,l_n]]$ where for each $i=1,\dots,n$,
#!  $c_i$ is a non-zero element in $k$ and $l_i$ is either a list containing an identity morphism or a list of (precomposable) generating morphisms such that
#!  <A>alpha</A> = $c_1\cdot\mathrm{PreCompose}(l_1)+..+c_n\cdot\mathrm{PreCompose}(l_n)$.
#! @Arguments alpha
#! @Returns a list of pairs
DeclareAttribute( "DecompositionOfMorphismInAlgebroid",
        IsMorphismInAlgebroidFromDataTables );

#! @Description
#!  The argument is a morphism <A>alpha</A> in an algebroid $A$ (over a commutative ring $k$).
#!  The output is a list of pairs $L=[[c_1,l_1],..,[c_n,l_n]]$ where for each $i=1,\dots,n$,
#!  $c_i$ is a non-zero element in $k$ and $l_i$ is either the empty-list or a list of **indices** of (precomposable) generating morphisms.
#!  The output can be used to compute <C>DecompositionOfMorphismInAlgebroid</C>(<A>alpha</A>).
#! @Arguments alpha
#! @Returns a list of pairs
DeclareAttribute( "DecompositionIndicesOfMorphismInAlgebroid",
        IsMorphismInAlgebroidFromDataTables );

#! @Description
#!  The argument is an algebroid <A>A</A>.
#!  The ouput is the opposite algebroid $A^{\mathrm{op}}$ constructed as an algebroid from data tables.
#! @Arguments A
#! @Returns a &CAP; category
DeclareAttribute( "OppositeAlgebroid",
        IsAlgebroidFromDataTables );

#! @Description
#!  The arguments are two algebroids <A>A</A> and <A>B</A>.
#!  The output is the tensor product algebroid <A>A</A>$\otimes$<A>B</A>.
#! @Arguments A, B
#! @Returns a &CAP; category
DeclareOperation( "TensorProductOfAlgebroids",
            [ IsAlgebroidFromDataTables, IsAlgebroidFromDataTables ] );

#! @Description
#!  Delegates to <C>TensorProductOfAlgebroids</C>(<A>A</A>,<A>B</A>).
#! @Arguments A, B
#! @Returns a &CAP; category
DeclareOperation( "\*",
            [ IsAlgebroidFromDataTables, IsAlgebroidFromDataTables ] );

#! @Description
#!  The arguments are two objects <A>a</A>, <A>b</A> and a tensor product algebroid <A>T</A>$=A\otimes B$ where <A>a</A> and <A>b</A> belong to $A$ resp. $B$.
#!  The output is the object $a\otimes b$ in <A>T</A>.
#! @Arguments a, b, T
#! @Returns a &CAP; category object
DeclareOperation( "ElementaryTensor",
            [ IsObjectInAlgebroidFromDataTables, IsObjectInAlgebroidFromDataTables, IsAlgebroidFromDataTables ] );

#! @Description
#!  The arguments are two morphisms <A>f</A>, <A>g</A> and a tensor product algebroid <A>T</A>$=A\otimes B$ where <A>f</A> and <A>g</A> belong to $A$ resp. $B$.
#!  The output is the morphism $f\otimes g$ in <A>T</A>.
#! @Arguments f, g, T
#! @Returns a &CAP; category morphism
DeclareOperation( "ElementaryTensor",
            [ IsMorphismInAlgebroidFromDataTables, IsMorphismInAlgebroidFromDataTables, IsAlgebroidFromDataTables ] );

