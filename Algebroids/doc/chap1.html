<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Algebroids) - Chapter 1: Examples</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1_mj.html">[MathJax on]</a></p>
<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>
<div class="ChapSects"><a href="chap1.html#X7A489A5D79DA9E5C">1 <span class="Heading">Examples</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X8438D5FE783DD7CB">1.1 <span class="Heading">The natural numbers as a f.g. monoid</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X80029DD883DEA86D">1.2 <span class="Heading">The integers as f.g. monoid</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X81661ACF85C8BD8D">1.3 <span class="Heading">A f.p. category</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X8101C3D985253352">1.4 <span class="Heading">The full subcategory of the simplicial category truncated in degree 2</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7B8327EC7AC3E634">1.5 <span class="Heading">Algebroids</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X813B1A1C7E283B80">1.6 <span class="Heading">Bialgebroids</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X868B56CD7EE75283">1.7 <span class="Heading">Hopf algebra generated by group-like elements</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7B04AAC77CDF3568">1.8 <span class="Heading">Hopf algebra generated by a primitive element</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X8193250583CB118F">1.9 <span class="Heading">A non-counitary coalgebra</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7B9F1F17869C5429">1.10 <span class="Heading">Sweedlers 4-dimensional Hopf algebra</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X86A2AE6E7C297595">1.11 <span class="Heading">Homomorphism structure</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7C0C87E4856062AF">1.12 <span class="Heading">Algebroids over the integers</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7C0BEF04853A376E">1.13 <span class="Heading">Unitors</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7B34D0E6854E90C8">1.14 <span class="Heading">Associators</span></a>
</span>
</div>
</div>

<h3>1 <span class="Heading">Examples</span></h3>

<p><a id="X8438D5FE783DD7CB" name="X8438D5FE783DD7CB"></a></p>

<h4>1.1 <span class="Heading">The natural numbers as a f.g. monoid</span></h4>

<p>Create a right quiver <span class="Math">q</span> with a single vertix <span class="Math">o</span> and a single arrow <span class="Math">m</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(o)[m:o-&gt;o]" );</span>
q(o)[m:o-&gt;o]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o := q.o;</span>
(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := q.m;</span>
(m)
</pre></div>

<p>Create a monoid from <span class="Math">q</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(o)[m:o-&gt;o]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative( N );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.o;</span>
&lt;(o)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.m;</span>
(o)-[(m)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( N );</span>
[ &lt;(o)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( N );</span>
[ (o)-[(m)]-&gt;(o) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( N, N.o, N.o );</span>
[ (o)-[(m)]-&gt;(o) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectInFpCategory( N, o ) = N.o;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.o = o / N;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMorphism( N.o );</span>
(o)-[(o)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MorphismInFpCategory( N, m ) = N.m;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N.m = m / N;</span>
true
</pre></div>

<p>We can compute in the algebroids. For instance we can form compositions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( N.m, N.m );</span>
(o)-[(m*m)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">unit := Unit( N );</span>
Functor from FreeCategory( RightQuiver( "*(1)[]" ) ) -&gt;
FreeCategory( RightQuiver( "q(o)[m:o-&gt;o]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mul := Multiplication( N );</span>
Functor from
FreeCategory( RightQuiver( "qxq(oo)[om:oo-&gt;oo,mo:oo-&gt;oo]" ) ) / relations -&gt;
FreeCategory( RightQuiver( "q(o)[m:o-&gt;o]" ) )
</pre></div>

<p><a id="X80029DD883DEA86D" name="X80029DD883DEA86D"></a></p>

<h4>1.2 <span class="Heading">The integers as f.g. monoid</span></h4>

<p>Create a right quiver <span class="Math">q</span> with a single vertix <span class="Math">o</span> and two arrows <span class="Math">m</span>, <span class="Math">i</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(o)[m:o-&gt;o,i:o-&gt;o]" );</span>
q(o)[m:o-&gt;o,i:o-&gt;o]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o := q.o;</span>
(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := q.m;</span>
(m)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := q.i;</span>
(i)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := [ [ m * i, o ], [ i * m, o ] ];</span>
[ [ (m*i), (o) ], [ (i*m), (o) ] ]
</pre></div>

<p>Create a monoid from <span class="Math">q</span> and the list <span class="Math">L</span> of relations.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZ := Category( q, L );</span>
FreeCategory( RightQuiver( "q(o)[m:o-&gt;o,i:o-&gt;o]" ) ) / [ m*i = o, i*m = o ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative( ZZ );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZ.o;</span>
&lt;(o)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( ZZ.o );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := ZZ.m;</span>
(o)-[(m)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := ZZ.i;</span>
(o)-[(i)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( ZZ );</span>
[ &lt;(o)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( ZZ );</span>
[ (o)-[(m)]-&gt;(o), (o)-[(i)]-&gt;(o) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( ZZ, ZZ.o, ZZ.o );</span>
[ (o)-[(m)]-&gt;(o), (o)-[(i)]-&gt;(o) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectInFpCategory( ZZ, o ) = ZZ.o;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZ.o = o / ZZ;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMorphism( ZZ.o );</span>
(o)-[(o)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MorphismInFpCategory( ZZ, q.m ) = ZZ.m;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZ.m = q.m / ZZ;</span>
true
</pre></div>

<p>We can compute in the algebroids. For instance we can form compositions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m2 := PreCompose( [ m, i, m, m, i, m, i, m ] );</span>
(o)-[(m*m)]-&gt;(o)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">unit := Unit( ZZ );</span>
Functor from FreeCategory( RightQuiver( "*(1)[]" ) ) -&gt;
FreeCategory( RightQuiver( "q(o)[m:o-&gt;o,i:o-&gt;o]" ) ) / [ m*i = o, i*m = o ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mul := Multiplication( ZZ );</span>
Functor from
FreeCategory( RightQuiver(
  "qxq(oo)[om:oo-&gt;oo,oi:oo-&gt;oo,mo:oo-&gt;oo,io:oo-&gt;oo]" ) ) / relations -&gt;
FreeCategory( RightQuiver( "q(o)[m:o-&gt;o,i:o-&gt;o]" ) ) / [ m*i = o, i*m = o ]
</pre></div>

<p><a id="X81661ACF85C8BD8D" name="X81661ACF85C8BD8D"></a></p>

<h4>1.3 <span class="Heading">A f.p. category</span></h4>

<p>Create a left quiver <span class="Math">ql</span> with 3 vertices u,v,w and 4 edges a,b,c,d.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ql := LeftQuiver( "ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" );</span>
ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]
</pre></div>

<p>Create a right quiver <span class="Math">qr</span> with 3 vertices u,v,w and 4 edges a,b,c,d.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qr := RightQuiver( "qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" );</span>
qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]
</pre></div>

<p>Create f.p. categories from these quivers.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cl := FreeCategory( ql );</span>
FreeCategory( LeftQuiver( "ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cr := FreeCategory( qr );</span>
FreeCategory( RightQuiver( "qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cl.u;</span>
&lt;(u)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cr.u;</span>
&lt;(u)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cl.a;</span>
(v)&lt;-[(a)]-(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cr.a;</span>
(u)-[(a)]-&gt;(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( Cl );</span>
[ &lt;(u)&gt;, &lt;(v)&gt;, &lt;(w)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Cl );</span>
[ (v)&lt;-[(a)]-(u), (u)&lt;-[(b)]-(v), (u)&lt;-[(c)]-(v), (w)&lt;-[(d)]-(v) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Cl, Cl.u, Cl.v );</span>
[ (v)&lt;-[(a)]-(u) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( Cr );</span>
[ &lt;(u)&gt;, &lt;(v)&gt;, &lt;(w)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Cr );</span>
[ (u)-[(a)]-&gt;(v), (v)-[(b)]-&gt;(u), (v)-[(c)]-&gt;(u), (v)-[(d)]-&gt;(w) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Cr, Cr.u, Cr.v );</span>
[ (u)-[(a)]-&gt;(v) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectInFpCategory( Cl, ql.u ) = Cl.u;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cl.u = ql.u / Cl;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MorphismInFpCategory( Cl, ql.a ) = Cl.a;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cl.a = ql.a / Cl;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMorphism( Cl.u );</span>
(u)&lt;-[(u)]-(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMorphism( Cr.u );</span>
(u)-[(u)]-&gt;(u)
</pre></div>

<p>We can compute in the algebroids. For instance we can form compositions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( Cl.a, Cl.d );</span>
(w)&lt;-[(d*a)]-(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( Cr.a, Cr.d );</span>
(u)-[(a*d)]-&gt;(w)
</pre></div>

<p>We can construct quotient categories</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q:= RightQuiver( "q(1)[a:1-&gt;1]" );</span>
q(1)[a:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fq := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := Fq / [ [ Fq.a^3, Fq.a^2 ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingQuiverAlgebra( C );</span>
(Q * q) / [ 1*(a*a*a) - 1*(a*a) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( C );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := C / [ [ C.a^9, C.1 ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) /
[ a*a*a = a*a, a*a = 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingQuiverAlgebra( D );</span>
(Q * q) / [ 1*(a) - 1*(1) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( D );</span>
1
</pre></div>

<p><a id="X8101C3D985253352" name="X8101C3D985253352"></a></p>

<h4>1.4 <span class="Heading">The full subcategory of the simplicial category truncated in degree 2</span></h4>

<p>The full subcategory of the simplicial category <span class="Math">\Delta</span> on the objects <span class="Math">[0], [1], [2]</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "Algebroids" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta2 := SimplicialCategoryTruncatedInDegree( 2 );</span>
FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelationsOfFpCategory( Delta2 );</span>
[ [ (s*id), (C0) ], [ (t*id), (C0) ],
  [ (ps*is), (C1) ], [ (pt*it), (C1) ],
  [ (is*id), (it*id) ], [ (pt*is), (id*t) ],
  [ (ps*it), (id*s) ], [ (s*pt), (t*ps) ],
  [ (s*mu), (s*ps) ], [ (t*mu), (t*pt) ],
  [ (mu*is), (C1) ], [ (mu*it), (C1) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( Delta2 );</span>
31
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta2_op := OppositeFiniteCategory( Delta2 );</span>
Opposite( FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIdenticalObj( OppositeFiniteCategory( Delta2_op ), Delta2 );</span>
true
</pre></div>

<p><a id="X7B8327EC7AC3E634" name="X7B8327EC7AC3E634"></a></p>

<h4>1.5 <span class="Heading">Algebroids</span></h4>

<p>Create a left quiver <span class="Math">ql</span> with 3 vertices u,v,w and 4 edges a,b,c,d.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ql := LeftQuiver( "ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" );</span>
ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]
</pre></div>

<p>Create a right quiver <span class="Math">qr</span> with 3 vertices u,v,w and 4 edges a,b,c,d.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qr := RightQuiver( "qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" );</span>
qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]
</pre></div>

<p>Create algebroids from these quivers over <span class="Math">\mathbb{Q}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al := Algebroid( Q, ql );</span>
Algebroid( Q, FreeCategory(
LeftQuiver( "ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">algebra_Al := UnderlyingQuiverAlgebra( Al );</span>
Q * ql
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar := Algebroid( Q, qr );</span>
Algebroid( Q, FreeCategory(
RightQuiver( "qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">algebra_Ar := UnderlyingQuiverAlgebra( Ar );</span>
Q * qr
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.u;</span>
&lt;(u)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.u;</span>
&lt;(u)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.a;</span>
(v)&lt;-[1*(a)]-(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.a;</span>
(u)-[1*(a)]-&gt;(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( Al );</span>
[ &lt;(u)&gt;, &lt;(v)&gt;, &lt;(w)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Al );</span>
[ (v)&lt;-[1*(a)]-(u), (u)&lt;-[1*(b)]-(v), (u)&lt;-[1*(c)]-(v), (w)&lt;-[1*(d)]-(v) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Al, Al.u, Al.v );</span>
[ (v)&lt;-[1*(a)]-(u) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( Ar );</span>
[ &lt;(u)&gt;, &lt;(v)&gt;, &lt;(w)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Ar );</span>
[ (u)-[1*(a)]-&gt;(v), (v)-[1*(b)]-&gt;(u), (v)-[1*(c)]-&gt;(u), (v)-[1*(d)]-&gt;(w) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Ar, Ar.u, Ar.v );</span>
[ (u)-[1*(a)]-&gt;(v) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CommutativeRingOfLinearCategory( Al ) = Q;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectInAlgebroid( Al, ql.u ) = Al.u;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.u = ql.u / Al;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MorphismInAlgebroid( Al, algebra_Al.a ) = Al.a;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.a = algebra_Al.a / Al;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMorphism( Al.u ) = algebra_Al.u / Al;</span>
true
</pre></div>

<p>We can compute in the algebroids. For instance we can form compositions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( Al.a, Al.d );</span>
(w)&lt;-[1*(d*a)]-(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( Ar.a, Ar.d );</span>
(u)-[1*(a*d)]-&gt;(w)
</pre></div>

<p>We also have addition and subtraction of morphisms and scalar multiplication with elements from the ground ring <span class="Math">\mathbb{Q}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.b+Al.c;</span>
(u)&lt;-[1*(c) + 1*(b)]-(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.b+Ar.c;</span>
(v)-[1*(c) + 1*(b)]-&gt;(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.b-Al.c;</span>
(u)&lt;-[-1*(c) + 1*(b)]-(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.b-Ar.c;</span>
(v)-[-1*(c) + 1*(b)]-&gt;(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.d - Al.d;</span>
(w)&lt;-[0]-(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.d - Ar.d;</span>
(v)-[0]-&gt;(w)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">1/2 * Al.d;</span>
(w)&lt;-[1/2*(d)]-(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">1/2 * Ar.d;</span>
(v)-[1/2*(d)]-&gt;(w)
</pre></div>

<p>We can construct quotient categories</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q:= RightQuiver( "q(1)[a:1-&gt;1]" );</span>
q(1)[a:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fq := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := Q[Fq];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingQuiverAlgebra( A );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := A / [ 2*A.a^3 - A.a^2  ];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingQuiverAlgebra( B );</span>
(Q * q) / [ 2*(a*a*a) - 1*(a*a) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension( B );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := B / [ B.a^2 + 2*B.a ];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingQuiverAlgebra( C );</span>
(Q * q) / [ 2*(a*a*a) - 1*(a*a), 1*(a*a) + 2*(a) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension( C );</span>
1
</pre></div>

<p><a id="X813B1A1C7E283B80" name="X813B1A1C7E283B80"></a></p>

<h4>1.6 <span class="Heading">Bialgebroids</span></h4>

<p>Create a right quiver <span class="Math">q</span> with two vertices <span class="Math">u</span> and <span class="Math">v</span> and two edges <span class="Math">a</span> and <span class="Math">b</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(u,v)[a:u-&gt;v,b:v-&gt;u]" );</span>
q(u,v)[a:u-&gt;v,b:v-&gt;u]
</pre></div>

<p>Create the path algebra <span class="Math">\mathbb{Q}q</span> of <span class="Math">q</span> over <span class="Math">\mathbb{Q}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(u,v)[a:u-&gt;v,b:v-&gt;u]" );</span>
q(u,v)[a:u-&gt;v,b:v-&gt;u]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
</pre></div>

<p>Form a quotient of <span class="Math">\mathbb{Q}q</span> by the relations <span class="Math">ab - u</span> and <span class="Math">ba - v</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq, [ Qq.a * Qq.b - Qq.u, Qq.b * Qq.a - Qq.v ] );</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(u,v)[a:u-&gt;v,b:v-&gt;u]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelationsOfAlgebroid( B );</span>
[ (u)-[1*(a*b) - 1*(u)]-&gt;(u), (v)-[1*(b*a) - 1*(v)]-&gt;(v) ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(B);</span>
false
</pre></div>

<p>Next we want to define a counit and a comultiplication on <span class="Math">B</span> to make it a bialgebroid. The following record will be used to define the counit of <span class="Math">B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := rec( a := 1, b := 1 );</span>
rec( a := 1, b := 1 )
</pre></div>

<p>We compute the tensor product <span class="Math">B \otimes_\mathbb{Q} B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := B^2;</span>
Algebroid( Q, FreeCategory( RightQuiver( "qxq(uu,uv,vu,vv)[\
ua:uu-&gt;uv,ub:uv-&gt;uu,va:vu-&gt;vv,vb:vv-&gt;vu,\
au:uu-&gt;vu,av:uv-&gt;vv,bu:vu-&gt;uu,bv:vv-&gt;uv]" ) ) ) / relations
</pre></div>

<p>The following record will be used to define the comultiplication <span class="Math">B \to B \otimes_{\mathbb{Q}} B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult:= rec( a := PreCompose(B2.au, B2.va), b:= PreCompose(B2.bv, B2.ub) );</span>
rec( a := (uu)-[{ 1*(ua*av) }]-&gt;(vv), b := (vv)-[{ 1*(vb*bu) }]-&gt;(uu) )
</pre></div>

<p>We use the records counit and comult to equip <span class="Math">B</span> with the induced morphisms <span class="Math">B \to \mathbb{Q}</span> and <span class="Math">B \to B \otimes_{\mathbb{Q}} B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( B, counit, comult );</span>
Bialgebroid( Q, FreeCategory( RightQuiver( "q(u,v)[a:u-&gt;v,b:v-&gt;u]" ) ) )
/ relations
</pre></div>

<p>We extract comultiplication and counit from <span class="Math">B</span>. They are now functors.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( B );</span>
Functor from Bialgebroid( Q, FreeCategory(
RightQuiver( "q(u,v)[a:u-&gt;v,b:v-&gt;u]" ) ) ) / relations
-&gt;
Algebra( Q, FreeCategory( RightQuiver( "*(1)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( B );</span>
Functor from Bialgebroid( Q, FreeCategory(
RightQuiver( "q(u,v)[a:u-&gt;v,b:v-&gt;u]" ) ) ) / relations
-&gt;
Algebroid( Q, FreeCategory(
RightQuiver( "qxq(uu,uv,vu,vv)[ua:uu-&gt;uv,ub:uv-&gt;uu,va:vu-&gt;vv,vb:vv-&gt;vu,\
au:uu-&gt;vu,av:uv-&gt;vv,bu:vu-&gt;uu,bv:vv-&gt;uv]" ) ) ) / relations
</pre></div>

<p>Apply comultiplication and counit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.u );</span>
&lt;(1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.v );</span>
&lt;(1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, IdentityMorphism( B.u ) );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, IdentityMorphism( B.v ) );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.a );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.b );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.u );</span>
&lt;(uu)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.v );</span>
&lt;(vv)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, IdentityMorphism( B.u ) );</span>
(uu)-[{ 1*(uu) }]-&gt;(uu)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, IdentityMorphism( B.v ) );</span>
(vv)-[{ 1*(vv) }]-&gt;(vv)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.a );</span>
(uu)-[{ 1*(ua*av) }]-&gt;(vv)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.b );</span>
(vv)-[{ 1*(vb*bu) }]-&gt;(uu)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCoassociative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCocommutative(B);</span>
true
</pre></div>

<p><a id="X868B56CD7EE75283" name="X868B56CD7EE75283"></a></p>

<h4>1.7 <span class="Heading">Hopf algebra generated by group-like elements</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" );</span>
q(1)[g:1-&gt;1,h:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq, [ Qq.h * Qq.g - Qq.1, Qq.g * Qq.h - Qq.1 ] );</span>
Algebra( Q, FreeCategory( RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := B^2;</span>
Algebra( Q, FreeCategory( RightQuiver(
"qxq(1x1)[1xg:1x1-&gt;1x1,1xh:1x1-&gt;1x1,gx1:1x1-&gt;1x1,hx1:1x1-&gt;1x1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit_rec := rec( g := 1, h := 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult_rec := rec( g := PreCompose( B2.1xg, B2.gx1 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   h := PreCompose( B2.1xh, B2.hx1 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( B, counit_rec, comult_rec );</span>
Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( B );</span>
Functor from
Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" ) ) )
/ relations
-&gt;
Algebra( Q, FreeCategory( RightQuiver( "*(1)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( B );</span>
Functor from
Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" ) ) )
/ relations
-&gt;
Algebra( Q, FreeCategory( RightQuiver(
"qxq(1x1)[1xg:1x1-&gt;1x1,1xh:1x1-&gt;1x1,gx1:1x1-&gt;1x1,hx1:1x1-&gt;1x1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode_rec := rec( g := B.h, h := B.g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddAntipode(B, antipode_rec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B;</span>
HopfAlgebra( Q, FreeCategory( RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Antipode(B);</span>
Contravariant functor from
HopfAlgebra( Q, FreeCategory( RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" ) ) )
/ relations
-&gt;
HopfAlgebra( Q, Fr eeCategory( RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.g );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCounitary(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCocommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHopfAlgebroid(B);</span>
true
</pre></div>

<p><a id="X7B04AAC77CDF3568" name="X7B04AAC77CDF3568"></a></p>

<h4>1.8 <span class="Heading">Hopf algebra generated by a primitive element</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Hopf algebra generated by a primitive element</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[t:1-&gt;1]" );</span>
q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq );</span>
Algebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q = UnderlyingAlgebra( B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := B^2;</span>
Algebra( Q, FreeCategory(
RightQuiver( "qxq(1x1)[1xt:1x1-&gt;1x1,tx1:1x1-&gt;1x1]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0 := B^0;</span>
Algebra( Q, FreeCategory( RightQuiver( "*(1)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit_rec := rec( t := 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult_rec := rec( t := B2.1xt + B2.tx1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( B, counit_rec, comult_rec );</span>
Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode_rec := rec( t:= -B.t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddAntipode( B, antipode_rec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( B );</span>
Functor from Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
-&gt;
Algebra( Q, FreeCategory( RightQuiver( "*(1)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( B );</span>
Functor from Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
-&gt;
Algebra( Q, FreeCategory(
RightQuiver( "qxq(1x1)[1xt:1x1-&gt;1x1,tx1:1x1-&gt;1x1]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">idB := IdentityFunctor( B );</span>
Identity functor of Algebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.t );</span>
(1x1)-[{ 1*(tx1) + 1*(1xt) }]-&gt;(1x1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.t );</span>
(1)-[0]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCounitary(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCocommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHopfAlgebroid(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB := CategoryOfAlgebroidsObject(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCoassociative( BB );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCounitary( BB );</span>
true
</pre></div>

<p><a id="X8193250583CB118F" name="X8193250583CB118F"></a></p>

<h4>1.9 <span class="Heading">A non-counitary coalgebra</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[t:1-&gt;1]" );</span>
q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq );</span>
Algebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := B^2;</span>
Algebra( Q, FreeCategory(
RightQuiver( "qxq(1x1)[1xt:1x1-&gt;1x1,tx1:1x1-&gt;1x1]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0 := B^0;</span>
Algebra( Q, FreeCategory( RightQuiver( "*(1)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit_rec := rec( t := 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult_rec := rec( t := B2.1xt );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( B, counit_rec, comult_rec );</span>
Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode_rec := rec( t:= -B.t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddAntipode(B, antipode_rec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( B );</span>
Functor from Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
-&gt;
Algebra( Q, FreeCategory( RightQuiver( "*(1)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( B );</span>
Functor from Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
-&gt;
Algebra( Q, FreeCategory(
RightQuiver( "qxq(1x1)[1xt:1x1-&gt;1x1,tx1:1x1-&gt;1x1]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCoassociative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCounitary(B);</span>
false
</pre></div>

<p><a id="X7B9F1F17869C5429" name="X7B9F1F17869C5429"></a></p>

<h4>1.10 <span class="Heading">Sweedlers 4-dimensional Hopf algebra</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[x:1-&gt;1,g:1-&gt;1]" );</span>
q(1)[x:1-&gt;1,g:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Algebroid( Qq, [ Qq.g * Qq.g - Qq.1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Qq.x * Qq.x,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Qq.x * Qq.g + Qq.g * Qq.x,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    ] );</span>
Algebra( Q, FreeCategory( RightQuiver( "q(1)[x:1-&gt;1,g:1-&gt;1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H2 := H^2;</span>
Algebra( Q, FreeCategory( RightQuiver(
"qxq(1x1)[1xx:1x1-&gt;1x1,1xg:1x1-&gt;1x1,xx1:1x1-&gt;1x1,gx1:1x1-&gt;1x1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit_rec := rec( x := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   g := 1</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult_rec := rec( g := PreCompose(H2.gx1, H2.1xg),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   x := H2.1xx + PreCompose(H2.xx1, H2.1xg)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( H, counit_rec, comult_rec );</span>
Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[x:1-&gt;1,g:1-&gt;1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( H );</span>
Functor from
Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[x:1-&gt;1,g:1-&gt;1]" ) ) )
/ relations
-&gt;
Algebra( Q, FreeCategory( RightQuiver( "*(1)[]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( H );</span>
Functor from
Bialgebra( Q, FreeCategory( RightQuiver( "q(1)[x:1-&gt;1,g:1-&gt;1]" ) ) )
/ relations
-&gt;
Algebra( Q, FreeCategory( RightQuiver(
"qxq(1x1)[1xx:1x1-&gt;1x1,1xg:1x1-&gt;1x1,xx1:1x1-&gt;1x1,gx1:1x1-&gt;1x1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode_rec := rec( g:= H.g,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     x := - PreCompose( H.x, H.g )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddAntipode(H, antipode_rec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode := Antipode( H );</span>
Contravariant functor from
HopfAlgebra( Q, FreeCategory( RightQuiver( "q(1)[x:1-&gt;1,g:1-&gt;1]" ) ) )
/ relations
-&gt;
HopfAlgebra( Q, FreeCategory( RightQuiver( "q(1)[x:1-&gt;1,g:1-&gt;1]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(H);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor(antipode, H.g);</span>
(1)-[{ 1*(g) }]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor(antipode, H.x);</span>
(1)-[{ -1*(x*g) }]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ApplyFunctor( antipode, H.x ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        -PreCompose( H.x, H.g ) );</span>
true
</pre></div>

<p>Verify that the antipode of <span class="Math">H</span> has order 4.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor( antipode, H.g ), H.g );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor( antipode, H.x ), H.x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( [ antipode, antipode ] ), H.x ), H.x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( [ antipode, antipode, antipode ] ), H.x ), H.x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( [ antipode, antipode, antipode, antipode ] ), H.x ), H.x );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCocommutative(H);</span>
false
</pre></div>

<p><a id="X86A2AE6E7C297595" name="X86A2AE6E7C297595"></a></p>

<h4>1.11 <span class="Heading">Homomorphism structure</span></h4>

<p>We perform simple computations with the Homomorphism structure of the Beilison quiver of the projective space of dimension 3.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(4)[\</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">x0:1-&gt;2,x1:1-&gt;2,x2:1-&gt;2,x3:1-&gt;2,\</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">y0:2-&gt;3,y1:2-&gt;3,y2:2-&gt;3,y3:2-&gt;3,\</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">z0:3-&gt;4,z1:3-&gt;4,z2:3-&gt;4,z3:3-&gt;4]" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beilinson_P3 := F /</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                [ [ PreCompose( F.x0, F.y1 ), PreCompose( F.x1, F.y0 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.x0, F.y2 ), PreCompose( F.x2, F.y0 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.x0, F.y3 ), PreCompose( F.x3, F.y0 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.x1, F.y2 ), PreCompose( F.x2, F.y1 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.x1, F.y3 ), PreCompose( F.x3, F.y1 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.x2, F.y3 ), PreCompose( F.x3, F.y2 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.y0, F.z1 ), PreCompose( F.y1, F.z0 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.y0, F.z2 ), PreCompose( F.y2, F.z0 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.y0, F.z3 ), PreCompose( F.y3, F.z0 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.y1, F.z2 ), PreCompose( F.y2, F.z1 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.y1, F.z3 ), PreCompose( F.y3, F.z1 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  [ PreCompose( F.y2, F.z3 ), PreCompose( F.y3, F.z2 ) ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Beilinson_P3 := Q[beilinson_P3];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">objs := SetOfObjects( Beilinson_P3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( objs ) = 4;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maps := SetOfGeneratingMorphisms( Beilinson_P3.1, Beilinson_P3.2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maps = SetOfGeneratingMorphisms( Beilinson_P3, 1, 2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( maps ) = 4;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( [ 0 .. 3 ], k -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        RankOfObject( HomomorphismStructureOnObjects( objs[1], objs[1 + k] ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        = Binomial( 4 + k - 1, k )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := Beilinson_P3.x0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := ( Beilinson_P3.z1 + Beilinson_P3.z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( [ alpha, (Beilinson_P3.y1 - Beilinson_P3.y3), beta ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sol := SolveLinearSystemInAbCategory(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               [ [ alpha ] ], [ [ beta ] ], [ gamma ] )[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( [ alpha, sol, beta ] ), gamma );</span>
true
</pre></div>

<p><a id="X7C0C87E4856062AF" name="X7C0C87E4856062AF"></a></p>

<h4>1.12 <span class="Heading">Algebroids over the integers</span></h4>

<p>We create an algebroid over <span class="Math">\mathbb{Q}</span> and its descent to <span class="Math">\mathbb{Z}</span> defined by basis paths.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(4)[a:1-&gt;2,b:1-&gt;3,c:3-&gt;4,d:2-&gt;4]" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := Qq / [ Qq.a * Qq.d - Qq.b * Qq.c];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_Q := Algebroid( Qq );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_Z := DescentToZDefinedByBasisPaths( A_Q );;</span>
</pre></div>

<p>We demonstrate the practical difference between the two algebroids by trying to solve one and the same linear system.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := 2 * A_Q.a;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( A_Q.4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( A_Q.b, A_Q.c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sol := SolveLinearSystemInAbCategory( [ [ alpha ] ], [ [ id ] ], [ gamma ] );</span>
[ (2)-[{ 1/2*(d) }]-&gt;(4) ]
</pre></div>

<p>Thus, a solution exists over the rationals.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := 2 * A_Z.a;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( A_Z.4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( A_Z.b, A_Z.c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sol := MereExistenceOfSolutionOfLinearSystemInAbCategory(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               [ [ alpha ] ], [ [ id ] ], [ gamma ] );</span>
false
</pre></div>

<p>No solution exists over the integers.</p>

<p><a id="X7C0BEF04853A376E" name="X7C0BEF04853A376E"></a></p>

<h4>1.13 <span class="Heading">Unitors</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := LeftQuiver( "ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Q, q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0 := B^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lu := LeftUnitorAsFunctor(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ru := RightUnitorAsFunctor(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lui := LeftUnitorInverseAsFunctor(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rui := RightUnitorInverseAsFunctor(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Range(lu)) = B;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Range(ru)) = B;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Source(lu)) = TensorProductOnObjects( B0, B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Source(ru)) = TensorProductOnObjects( B, B0 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Source(lui)) = B;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Source(rui)) = B;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Range(lui)) = TensorProductOnObjects( B0, B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Range(rui)) = TensorProductOnObjects( B, B0 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Concatenation( [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( SetOfObjects(B),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   o -&gt; ApplyFunctor( PreCompose(lui, lu), o) = o and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   ApplyFunctor( PreCompose(rui, ru), o) = o ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( SetOfGeneratingMorphisms(B),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   m -&gt; ApplyFunctor( PreCompose(lui, lu), m) = m and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   ApplyFunctor( PreCompose(rui, ru), m) = m ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( SetOfObjects(B^0 * B),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   o -&gt; ApplyFunctor( PreCompose(lu, lui), o) = o ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( SetOfGeneratingMorphisms(B^0 * B),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   m -&gt; ApplyFunctor( PreCompose(lu, lui), m) = m)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">and_function := function(x,y) return x and y; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Iterated( l, and_function );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Consider B as an object in the category of algebroids over Q</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">BB := CategoryOfAlgebroidsObject(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB2 := TensorProductOnObjects(BB, BB);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB0 := TensorUnit( CapCategory( BB ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ru_as_functor := RightUnitor( BB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lu_as_functor := LeftUnitor( BB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rui_as_functor := RightUnitorInverse( BB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lui_as_functor := LeftUnitorInverse( BB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( ru_as_functor, rui_as_functor ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( TensorProductOnObjects( BB,  BB0 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lu_as_functor, lui_as_functor ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( TensorProductOnObjects( BB0,  BB ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( rui_as_functor, ru_as_functor ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( BB ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lui_as_functor, lu_as_functor ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( BB ) );</span>
true
</pre></div>

<p><a id="X7B34D0E6854E90C8" name="X7B34D0E6854E90C8"></a></p>

<h4>1.14 <span class="Heading">Associators</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[t:1-&gt;1]" );</span>
q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq );</span>
Algebra( Q, FreeCategory( RightQuiver( "q(1)[t:1-&gt;1]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_ltr := AssociatorLeftToRightWithGivenTensorProductsAsFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   (B*B)*B, B, B, B, B*(B*B) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_rtl := AssociatorRightToLeftWithGivenTensorProductsAsFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   B*(B*B), B, B, B, (B*B)*B );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source(ass_ltr) = Range(ass_rtl);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Range(ass_ltr) = Source(ass_rtl);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Consider B as an object in the category of algebroids over Q</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">BB := CategoryOfAlgebroidsObject(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB2 := TensorProductOnObjects(BB, BB);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB0 := TensorUnit( CapCategory( BB ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_ltr_as_morphism := AssociatorLeftToRight(BB,BB,BB);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_rtl_as_morphism := AssociatorRightToLeft(BB,BB,BB);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        PreCompose( ass_ltr_as_morphism, ass_rtl_as_morphism ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( Source( ass_ltr_as_morphism ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        PreCompose( ass_rtl_as_morphism, ass_ltr_as_morphism ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( Source( ass_rtl_as_morphism ) ) );</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
