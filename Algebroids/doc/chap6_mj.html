<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (Algebroids) - Chapter 6: Algebroids from data tables</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap6.html">[MathJax off]</a></p>
<p><a id="X85561B8E7F007C4B" name="X85561B8E7F007C4B"></a></p>
<div class="ChapSects"><a href="chap6_mj.html#X85561B8E7F007C4B">6 <span class="Heading">Algebroids from data tables</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X871597447BB998A1">6.1 <span class="Heading">Properties</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X83174B7E84624406">6.1-1 IsAdmissibleAlgebroid</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7C701DBF7BAE649A">6.2 <span class="Heading">Attributes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8559D56E79671079">6.2-1 DataTablesOfCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X798BC51985D1B96A">6.2-2 IsomorphismOntoAlgebroidFromDataTables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X868436FA86F03050">6.2-3 IsomorphismFromAlgebroidFromDataTables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7A5EEA5480FF24B1">6.2-4 QuotientCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8690CB5985363556">6.2-5 EnhancedDataTables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7B41B84383DC82AB">6.2-6 SetOfObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X783C66B57E2E4F09">6.2-7 SetOfGeneratingMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X842B337D7B0BEC56">6.2-8 SetOfBasesOfExternalHoms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7BA120267C85DB18">6.2-9 PowerOfArrowIdeal</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7DE8E16C7C2D387B">6.3 <span class="Heading">Operations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X821DFF538376FFC6">6.3-1 AssignSetOfObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7CC9D637849C77D1">6.3-2 AssignSetOfGeneratingMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X78C2D22B7EC1CC45">6.3-3 CreateObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7981BDB984CC3F08">6.3-4 ObjectIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8084F7247D83B465">6.3-5 CreateMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X81028F5A8593F39E">6.3-6 MorphismCoefficients</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X80F86CC77B1E3713">6.3-7 MorphismSupport</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7D00675E8470FF43">6.3-8 DecompositionOfMorphismInAlgebroid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X78F3294482D413A3">6.3-9 OppositeAlgebroid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7DD9A91578D68E0A">6.3-10 TensorProductOfAlgebroids</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X816FDB3783C17B55"><code>6.3-11 \*</code></a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X826BDBCC7C3FB09A">6.3-12 ElementaryTensor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8093CB917A51EC36">6.3-13 ElementaryTensor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X789C404380EAC9CF">6.3-14 AlgebroidAsObjectInPreSheavesCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7CA3344780309FE5">6.3-15 AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X86EC0F0A78ECBC10">6.4 <span class="Heading">Constructors</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X86B92ADE844B2633">6.4-1 AlgebroidFromDataTables</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7D03633A7D98026B">6.5 <span class="Heading">GAP categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X791ADDC27D32A418">6.5-1 IsAlgebroidFromDataTablesObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X871C3D3C7B92DA8C">6.5-2 IsCellInAlgebroidFromDataTables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8517A59E7E8477C0">6.5-3 IsAlgebroidFromDataTables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X86CF900382BD9C83">6.5-4 IsAlgebroidFromDataTablesMorphism</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">Algebroids from data tables</span></h3>

<p><a id="X871597447BB998A1" name="X871597447BB998A1"></a></p>

<h4>6.1 <span class="Heading">Properties</span></h4>

<p><a id="X83174B7E84624406" name="X83174B7E84624406"></a></p>

<h5>6.1-1 IsAdmissibleAlgebroid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAdmissibleAlgebroid</code>( <var class="Arg">B</var>, <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are an algebroid <var class="Arg">B</var> linear over a field <span class="SimpleMath">\(k\)</span>. This output is <code class="code">true</code> iff the following two conditions hold: (1) the union of all identity morphisms and all generating morphism remain linear independent in the quotient category <span class="SimpleMath">\(C/\mathfrak{m}^2\)</span>; (2) <span class="SimpleMath">\(\mathfrak{m}^i=0\)</span> for some <span class="SimpleMath">\(i\in\mathbb{N}\)</span>, where <span class="SimpleMath">\(\mathfrak{m}^i=\)</span><code class="code">PowerOfArrowIdeal</code>(<var class="Arg">B</var>,<span class="SimpleMath">\(i\)</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "Algebroids" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(0,1,2)[x:0-&gt;1,y:1-&gt;2,z:0-&gt;2]" );</span>
q(0,1,2)[x:0-&gt;1,y:1-&gt;2,z:0-&gt;2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(0,1,2)[x:0-&gt;1,y:1-&gt;2,z:0-&gt;2]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kF := k[F];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(0,1,2)[x:0-&gt;1,y:1-&gt;2,z:0-&gt;2]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := kF / [ kF.xy - kF.z ];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(0,1,2)[x:0-&gt;1,y:1-&gt;2,z:0-&gt;2]" ) ) )
/ relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := AlgebroidFromDataTables( A );</span>
Q-algebroid( {0,1,2}[x:0-≻1,y:1-≻2,z:0-≻2] ) defined by 3 objects
and 3 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAdmissibleAlgebroid( B );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(*)[x:*-&gt;*,y:*-&gt;*]" );</span>
q(*)[x:*-&gt;*,y:*-&gt;*]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(*)[x:*-&gt;*,y:*-&gt;*]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kF := k[F];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(*)[x:*-&gt;*,y:*-&gt;*]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := kF / [ kF.xy - kF.yx, kF.x^3, kF.y^3 ];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(*)[x:*-&gt;*,y:*-&gt;*]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := AlgebroidFromDataTables( A );</span>
Q-algebroid( {*}[x:*-≻*,y:*-≻*] ) defined by 1 object and 2 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAdmissibleAlgebroid( B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := kF / [ kF.xy - kF.yx, kF.x^3 - kF.x, kF.y^3 ];</span>
Algebra( Q, FreeCategory( RightQuiver( "q(*)[x:*-&gt;*,y:*-&gt;*]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := AlgebroidFromDataTables( A );</span>
Q-algebroid( {*}[x:*-≻*,y:*-≻*] ) defined by 1 object and 2 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAdmissibleAlgebroid( B );</span>
false
</pre></div>

<p><a id="X7C701DBF7BAE649A" name="X7C701DBF7BAE649A"></a></p>

<h4>6.2 <span class="Heading">Attributes</span></h4>

<p><a id="X8559D56E79671079" name="X8559D56E79671079"></a></p>

<h5>6.2-1 DataTablesOfCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DataTablesOfCategory</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p>The argument is a <span class="SimpleMath">\(k\)</span>-algebroid <var class="Arg">A</var> defined by a finite dimensional quiver-algebra. This operation extracts a data-tables record from <var class="Arg">A</var> which can be used to construct an algebroid <span class="SimpleMath">\(B\)</span>, that is isomorphic to <var class="Arg">A</var>.</p>

<p><a id="X798BC51985D1B96A" name="X798BC51985D1B96A"></a></p>

<h5>6.2-2 IsomorphismOntoAlgebroidFromDataTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismOntoAlgebroidFromDataTables</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p>The arguments is a <span class="SimpleMath">\(k\)</span>-algebroid <span class="SimpleMath">\(A\)</span> defined by a finite dimensional quiver-algebra. The output is an isomorphism functor from <var class="Arg">A</var> onto the isomorphic <span class="SimpleMath">\(k\)</span>-algebroid <span class="SimpleMath">\(B:=\)</span><code class="code">AlgebroidFromDataTables</code>(<code class="code">DataTablesOfCategory</code>(<var class="Arg">A</var>)).</p>

<p><a id="X868436FA86F03050" name="X868436FA86F03050"></a></p>

<h5>6.2-3 IsomorphismFromAlgebroidFromDataTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismFromAlgebroidFromDataTables</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p>The arguments is a <span class="SimpleMath">\(k\)</span>-algebroid <span class="SimpleMath">\(A\)</span> defined by a finite dimensional quiver-algebra. The output is an isomorphism functor Onto <var class="Arg">A</var> from the isomorphic <span class="SimpleMath">\(k\)</span>-algebroid <span class="SimpleMath">\(B:=\)</span><code class="code">AlgebroidFromDataTables</code>(<code class="code">DataTablesOfCategory</code>(<var class="Arg">A</var>)).</p>

<p><a id="X7A5EEA5480FF24B1" name="X7A5EEA5480FF24B1"></a></p>

<h5>6.2-4 QuotientCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuotientCategory</code>( <var class="Arg">B</var>, <var class="Arg">I</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>The arguments are an algebroid <span class="SimpleMath">\(B\)</span> and a list <var class="Arg">I</var> of morphisms in <span class="SimpleMath">\(B\)</span>. The output is the quotient category <span class="SimpleMath">\(B/I\)</span> of <span class="SimpleMath">\(B\)</span> modulo the two-sided ideal of morphisms generated by <var class="Arg">I</var>.</p>

<p><a id="X8690CB5985363556" name="X8690CB5985363556"></a></p>

<h5>6.2-5 EnhancedDataTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EnhancedDataTables</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>The data tables used to define <span class="SimpleMath">\(B\)</span> enhanced with further key values.</p>

<p><a id="X7B41B84383DC82AB" name="X7B41B84383DC82AB"></a></p>

<h5>6.2-6 SetOfObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOfObjects</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of <strong class="pkg">CAP</strong> category objects</p>

<p>The argument is an algebroid <var class="Arg">B</var>. The output is the finite set of objects of <var class="Arg">B</var>.</p>

<p><a id="X783C66B57E2E4F09" name="X783C66B57E2E4F09"></a></p>

<h5>6.2-7 SetOfGeneratingMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOfGeneratingMorphisms</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of a <strong class="pkg">CAP</strong> category morphisms</p>

<p>The argument is an algebroid <var class="Arg">B</var>. The output is the finite set of generating morphisms of <var class="Arg">B</var>.</p>

<p><a id="X842B337D7B0BEC56" name="X842B337D7B0BEC56"></a></p>

<h5>6.2-8 SetOfBasesOfExternalHoms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOfBasesOfExternalHoms</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of lists</p>

<p>The argument is an algebroid <var class="Arg">B</var>. The output is a list of lists <span class="SimpleMath">\(L\)</span> where <span class="SimpleMath">\(L[i][j]\)</span> is the basis of the external hom <span class="SimpleMath">\(\mathrm{Hom}_B(u,v)\)</span> where <span class="SimpleMath">\(u\)</span> and <span class="SimpleMath">\(v\)</span> are <span class="SimpleMath">\(i\)</span>'th resp. <span class="SimpleMath">\(j\)</span>'th objects in <span class="SimpleMath">\(B\)</span>.</p>

<p><a id="X7BA120267C85DB18" name="X7BA120267C85DB18"></a></p>

<h5>6.2-9 PowerOfArrowIdeal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PowerOfArrowIdeal</code>( <var class="Arg">B</var>, <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are an algebroid <var class="Arg">B</var> and a non-negative integer <var class="Arg">i</var>. The output is a generating set for <span class="SimpleMath">\(\mathfrak{m}^i\)</span> where <span class="SimpleMath">\(\mathfrak{m}\)</span> is the ideal generated by all generating morphisms in <var class="Arg">B</var>.</p>

<p><a id="X7DE8E16C7C2D387B" name="X7DE8E16C7C2D387B"></a></p>

<h4>6.3 <span class="Heading">Operations</span></h4>

<p><a id="X821DFF538376FFC6" name="X821DFF538376FFC6"></a></p>

<h5>6.3-1 AssignSetOfObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssignSetOfObjects</code>( <var class="Arg">B</var>[, <var class="Arg">optional_string</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>The arguments are an algebroid <var class="Arg">B</var> and a string <var class="Arg">optional_string</var>. This operation assigns the objects of <var class="Arg">B</var> to global variables. Names of the variables are the concatenation of the labels of the objects of <var class="Arg">B</var> with <var class="Arg">optional_string</var>. The default value of <var class="Arg">optional_string</var> is the empty string.</p>

<p><a id="X7CC9D637849C77D1" name="X7CC9D637849C77D1"></a></p>

<h5>6.3-2 AssignSetOfGeneratingMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssignSetOfGeneratingMorphisms</code>( <var class="Arg">B</var>[, <var class="Arg">optional_string</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>The arguments are an algebroid <var class="Arg">B</var> and a string <var class="Arg">optional_string</var>. This operation assigns the generating morphisms of <var class="Arg">B</var> to global variables. Names of the variables are the concatenation of the labels of the generating morphisms of <var class="Arg">B</var> with <var class="Arg">optional_string</var>. The default value of <var class="Arg">optional_string</var> is the empty string.</p>

<p><a id="X78C2D22B7EC1CC45" name="X78C2D22B7EC1CC45"></a></p>

<h5>6.3-3 CreateObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreateObject</code>( <var class="Arg">B</var>, <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category object</p>

<p>The arguments are an algebroid <var class="Arg">B</var> and an integer <var class="Arg">i</var>. The output is the <var class="Arg">i</var>'th object in <code class="code">SetOfObjects</code>(<var class="Arg">B</var>).</p>

<p><a id="X7981BDB984CC3F08" name="X7981BDB984CC3F08"></a></p>

<h5>6.3-4 ObjectIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectIndex</code>( <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an integer</p>

<p>The argument is an object <var class="Arg">v</var> in an algebroid <var class="Arg">B</var>. The output is the index of <var class="Arg">v</var> in <code class="code">SetOfObjects</code>(<var class="Arg">B</var>).</p>

<p><a id="X8084F7247D83B465" name="X8084F7247D83B465"></a></p>

<h5>6.3-5 CreateMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreateMorphism</code>( <var class="Arg">B</var>, <var class="Arg">u</var>, <var class="Arg">coeffs</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category morphism</p>

<p>The arguments are an algebroid <var class="Arg">B</var> (over a commutative ring <span class="SimpleMath">\(k\)</span>), two objects <var class="Arg">u,v</var> in <var class="Arg">B</var> and list <var class="Arg">coeffs</var> of elements in <span class="SimpleMath">\(k\)</span> of length <span class="SimpleMath">\(\mathrm{dim}_k~\mathrm{Hom}_{B}(u,v)\)</span>. The output is the <span class="SimpleMath">\(k\)</span>-linear combination of the basis elements of <span class="SimpleMath">\(\mathrm{Hom}_B(u,v)\)</span> with the coefficients-list <var class="Arg">coeffs</var>.</p>

<p><a id="X81028F5A8593F39E" name="X81028F5A8593F39E"></a></p>

<h5>6.3-6 MorphismCoefficients</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismCoefficients</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category morphism</p>

<p>The argument is a morphism <var class="Arg">alpha</var> in an algebroid <var class="Arg">B</var>. The output is the list of coefficients of <var class="Arg">alpha</var> with respect to the basis of external hom <span class="SimpleMath">\(\mathrm{Hom}_B(u,v)\)</span> where <span class="SimpleMath">\(u\)</span> and <span class="SimpleMath">\(v\)</span> are source resp. range of <var class="Arg">alpha</var>.</p>

<p><a id="X80F86CC77B1E3713" name="X80F86CC77B1E3713"></a></p>

<h5>6.3-7 MorphismSupport</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismSupport</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category morphism</p>

<p>The argument is a morphism <var class="Arg">alpha</var> in an algebroid <var class="Arg">B</var>. The output is the list of indices of the nonzero entries of <code class="code">MorphismCoefficients</code>(<var class="Arg">alpha</var>).</p>

<p><a id="X7D00675E8470FF43" name="X7D00675E8470FF43"></a></p>

<h5>6.3-8 DecompositionOfMorphismInAlgebroid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionOfMorphismInAlgebroid</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of pairs</p>

<p>The argument is a morphism <var class="Arg">alpha</var> in an algebroid <span class="SimpleMath">\(B\)</span> (over a commutative ring <span class="SimpleMath">\(k\)</span>). The output is a list of pairs <span class="SimpleMath">\(L=[[c_1,l_1],..,[c_n,l_n]]\)</span> where for each <span class="SimpleMath">\(i=1,\dots,n\)</span>, <span class="SimpleMath">\(c_i\)</span> is a non-zero element in <span class="SimpleMath">\(k\)</span> and <span class="SimpleMath">\(l_i\)</span> is either a list containing an identity morphism or a list of (precomposable) generating morphisms such that <var class="Arg">alpha</var> = <span class="SimpleMath">\(c_1\cdot\mathrm{PreCompose}(l_1)+..+c_n\cdot\mathrm{PreCompose}(l_n)\)</span>.</p>

<p><a id="X78F3294482D413A3" name="X78F3294482D413A3"></a></p>

<h5>6.3-9 OppositeAlgebroid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OppositeAlgebroid</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>The argument is an algebroid <var class="Arg">B</var>. The ouput is the opposite algebroid <span class="SimpleMath">\(B^{\mathrm{op}}\)</span> constructed as an algebroid from data tables.</p>

<p><a id="X7DD9A91578D68E0A" name="X7DD9A91578D68E0A"></a></p>

<h5>6.3-10 TensorProductOfAlgebroids</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TensorProductOfAlgebroids</code>( <var class="Arg">A</var>, <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>The arguments are two algebroids <var class="Arg">A</var> and <var class="Arg">B</var>. The output is the tensor product algebroid <var class="Arg">A</var><span class="SimpleMath">\(\otimes\)</span><var class="Arg">B</var>.</p>

<p><a id="X816FDB3783C17B55" name="X816FDB3783C17B55"></a></p>

<h5><code>6.3-11 \*</code></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \*</code>( <var class="Arg">A</var>, <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>Delegates to <code class="code">TensorProductOfAlgebroids</code>(<var class="Arg">A</var>,<var class="Arg">B</var>).</p>

<p><a id="X826BDBCC7C3FB09A" name="X826BDBCC7C3FB09A"></a></p>

<h5>6.3-12 ElementaryTensor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryTensor</code>( <var class="Arg">a</var>, <var class="Arg">b</var>, <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category object</p>

<p>The arguments are two objects <var class="Arg">a</var>, <var class="Arg">b</var> and a tensor product algebroid <var class="Arg">T</var><span class="SimpleMath">\(=A\otimes B\)</span> where <var class="Arg">a</var> and <var class="Arg">b</var> belong to <span class="SimpleMath">\(A\)</span> resp. <span class="SimpleMath">\(B\)</span>. The output is the object <span class="SimpleMath">\(a\otimes b\)</span> in <var class="Arg">T</var>.</p>

<p><a id="X8093CB917A51EC36" name="X8093CB917A51EC36"></a></p>

<h5>6.3-13 ElementaryTensor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryTensor</code>( <var class="Arg">f</var>, <var class="Arg">g</var>, <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category morphism</p>

<p>The arguments are two morphisms <var class="Arg">f</var>, <var class="Arg">g</var> and a tensor product algebroid <var class="Arg">T</var><span class="SimpleMath">\(=A\otimes B\)</span> where <var class="Arg">f</var> and <var class="Arg">g</var> belong to <span class="SimpleMath">\(A\)</span> resp. <span class="SimpleMath">\(B\)</span>. The output is the morphism <span class="SimpleMath">\(f\otimes g\)</span> in <var class="Arg">T</var>.</p>

<p><a id="X789C404380EAC9CF" name="X789C404380EAC9CF"></a></p>

<h5>6.3-14 AlgebroidAsObjectInPreSheavesCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AlgebroidAsObjectInPreSheavesCategory</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category morphism</p>

<p>The argument is an algebroid <span class="SimpleMath">\(B\)</span> over a commutative ring <span class="SimpleMath">\(k\)</span>. The output is the presheaf object <span class="SimpleMath">\(F_{B}\in \mathrm{PSh}(B^{\mathrm{op}}\otimes B)\)</span> which maps an object <span class="SimpleMath">\(u^{\mathrm{op}}\otimes t \in B^{\mathrm{op}}\otimes B\)</span> to <span class="SimpleMath">\(\mathrm{Hom}_B(t,u) \in k\mbox{-}\mathrm{rows}\)</span> and maps a morphism <span class="SimpleMath">\(g^{\mathrm{op}}\otimes f : v^{\mathrm{op}}\otimes s \to u^{\mathrm{op}}\otimes t \in B^{\mathrm{op}}\otimes B\)</span> to <span class="SimpleMath">\(f\bullet(-)\bullet g =\mathrm{Hom}_B(f,g): \mathrm{Hom}_B(t,u) \to \mathrm{Hom}_B(s,v) \in k\mbox{-}\mathrm{rows}\)</span>.</p>

<p><a id="X7CA3344780309FE5" name="X7CA3344780309FE5"></a></p>

<h5>6.3-15 AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category morphism</p>

<p>The argument is a morphism <span class="SimpleMath">\(\alpha: t \to u\)</span> in an algebroid <span class="SimpleMath">\(B\)</span> over a commutative ring <span class="SimpleMath">\(k\)</span>. The output is the morphism <span class="SimpleMath">\(\lambda_{\alpha}:P_{u^{\mathrm{op}}\otimes t} \to F_{B}\)</span> where <span class="SimpleMath">\(P_{u^{\mathrm{op}}\otimes t}\)</span> is the image of <span class="SimpleMath">\(u^{\mathrm{op}}\otimes t\)</span> under the Yoneda embdding <span class="SimpleMath">\(B^{\mathrm{op}}\otimes B \hookrightarrow \mathrm{PSh}(B^{\mathrm{op}}\otimes B)\)</span>; and <span class="SimpleMath">\(\lambda_{\alpha}\)</span> the image of <span class="SimpleMath">\(\alpha\)</span> under the natural isomorphism <span class="SimpleMath">\(\mathrm{Hom}_{B}(t,u) = F_{B}(u^{\mathrm{op}}\otimes t) \simeq \mathrm{Hom}_{\mathrm{PSh}(B^{\mathrm{op}}\otimes B)}(P_{u^{\mathrm{op}}\otimes t},F_{B})\)</span>.</p>

<p><a id="X86EC0F0A78ECBC10" name="X86EC0F0A78ECBC10"></a></p>

<h4>6.4 <span class="Heading">Constructors</span></h4>

<p><a id="X86B92ADE844B2633" name="X86B92ADE844B2633"></a></p>

<h5>6.4-1 AlgebroidFromDataTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AlgebroidFromDataTables</code>( <var class="Arg">data_tables</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>Construct an enrichted algebroid <span class="SimpleMath">\(B\)</span> out of the <var class="Arg">data_tables</var> consisting of values to the keys:</p>


<ul>
<li><p><var class="Arg">coefficients_ring</var>: the commutative ring <span class="SimpleMath">\(k\)</span> over which <span class="SimpleMath">\(B\)</span> is linear.</p>

</li>
<li><p><var class="Arg">nr_objs</var>: the number of objects of <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">labels_objs</var>: list of strings representing the names of the objects of <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">nr_gmors</var>: the number of generating morphisms of <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">labels_gmors</var>: list of strings representing the names of the generating morphisms of <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">nr_bases_elms</var>: the sum of dimensions of all hom-spaces in <span class="SimpleMath">\(B\)</span>, i.e., <span class="SimpleMath">\(\Sigma_{u,v\in B}~\mathrm{dim}_{k}~\mathrm{Hom}(u,v)\)</span>, i.e., the dimension over <span class="SimpleMath">\(k\)</span> of the endomorphism algebra of <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">indices_objs</var>: the indices of the identity morphisms in the list-of-all-bases-elements in <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">indices_gmors</var>: the indices of the generating morphisms in the list-of-all-bases-elements in <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">sources_gmors</var>: the indices of sources of the generating morphisms in the list of objects of <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">ranges_gmors</var>: the indices of ranges of the generating morphisms in the list of objects of <span class="SimpleMath">\(B\)</span>.</p>

</li>
<li><p><var class="Arg">bases_elms_comps</var>: a list of length <var class="Arg">nr_bases_elms</var> of lists of elements in <var class="Arg">[-1,-2,..,-nr_objs]</var> or <var class="Arg">[1,2,..,nr_gmors]</var>. The <span class="SimpleMath">\(i\)</span>'th entry identifies the <span class="SimpleMath">\(i\)</span>'th element of list-of-all-bases-elements as an identity morphism or as a precomposition of generating morphisms.</p>

</li>
<li><p><var class="Arg">indices_of_bases_elms</var>: a list <span class="SimpleMath">\(L\)</span> of length <var class="Arg">nr_objs</var> of lists each of length <var class="Arg">nr_objs</var> where the entry <span class="SimpleMath">\(L[i][j]\)</span> is the list of indices of the basis elements of <span class="SimpleMath">\(\mathrm{Hom}_{B}(u_j,u_i)\)</span> in the list-of-all-bases-elements in <span class="SimpleMath">\(B\)</span> where <span class="SimpleMath">\(u_i\)</span> and <span class="SimpleMath">\(u_j\)</span> are the <span class="SimpleMath">\(i\)</span>'th resp. <span class="SimpleMath">\(j\)</span>'th objects.</p>

</li>
<li><p><var class="Arg">hom_structure_gmors_objs</var>: a list <span class="SimpleMath">\(L\)</span> of length <var class="Arg">nr_objs</var> of lists of length <var class="Arg">nr_gmors</var> where the entry <span class="SimpleMath">\(L[i][j]\)</span> is the list of entries of the matrix of the <span class="SimpleMath">\(k\)</span>-linear map <span class="SimpleMath">\(\mathrm{Hom}_{B}(m_j,u_i)\)</span> where <span class="SimpleMath">\(u_i\)</span> and <span class="SimpleMath">\(m_j\)</span> are the <span class="SimpleMath">\(i\)</span>'th object and the <span class="SimpleMath">\(j\)</span>'th generating morphism.</p>

</li>
<li><p><var class="Arg">hom_structure_objs_gmors</var>: a list <span class="SimpleMath">\(L\)</span> of length <var class="Arg">nr_objs</var> of lists of length <var class="Arg">nr_gmors</var> where the entry <span class="SimpleMath">\(L[i][j]\)</span> is the list of entries of the matrix of the <span class="SimpleMath">\(k\)</span>-linear map <span class="SimpleMath">\(\mathrm{Hom}_{B}(u_i,m_j)\)</span> where <span class="SimpleMath">\(u_i\)</span> and <span class="SimpleMath">\(m_j\)</span> are the <span class="SimpleMath">\(i\)</span>'th object and the <span class="SimpleMath">\(j\)</span>'th generating morphism.</p>

</li>
</ul>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "Algebroids" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(0,1,2,3)[a:0-&gt;1,b:1-&gt;3,c:0-&gt;2,d:2-&gt;3,e:3-&gt;3]" );</span>
q(0,1,2,3)[a:0-&gt;1,b:1-&gt;3,c:0-&gt;2,d:2-&gt;3,e:3-&gt;3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := HomalgFieldOfRationals();</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(0,1,2,3)[a:0-&gt;1,b:1-&gt;3,c:0-&gt;2,d:2-&gt;3,e:3-&gt;3]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kF := k[F];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(0,1,2,3)[a:0-&gt;1,b:1-&gt;3,c:0-&gt;2,d:2-&gt;3,
e:3-&gt;3]" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := kF / [ kF.e^3 ];</span>
Algebroid( Q, FreeCategory( RightQuiver( "q(0,1,2,3)[a:0-&gt;1,b:1-&gt;3,c:0-&gt;2,d:2-&gt;3,
e:3-&gt;3]" ) ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">data_tables := DataTablesOfCategory( A );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := AlgebroidFromDataTables( data_tables );; # alternatively,</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := AlgebroidFromDataTables( A );</span>
Q-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,c:0-≻2,d:2-≻3,e:3-≻3] ) defined by
4 objects and 5 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignSetOfObjects( B, "V_" );</span>
#I  MakeReadWriteGlobal: V_0 already read-write
#I  MakeReadWriteGlobal: V_1 already read-write
#I  MakeReadWriteGlobal: V_2 already read-write
#I  MakeReadWriteGlobal: V_3 already read-write
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignSetOfGeneratingMorphisms( B );</span>
#I  MakeReadWriteGlobal: a already read-write
#I  MakeReadWriteGlobal: b already read-write
#I  MakeReadWriteGlobal: c already read-write
#I  MakeReadWriteGlobal: d already read-write
#I  MakeReadWriteGlobal: e already read-write
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( B );</span>
[ &lt;(0)&gt;, &lt;(1)&gt;, &lt;(2)&gt;, &lt;(3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B.("0");</span>
&lt;(0)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V_0;</span>
&lt;(0)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( B.("0"), V_0 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CreateObject( B, 1 ) = B.("0");</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( B );</span>
[ &lt;1*a:(0) -≻ (1)&gt;, &lt;1*b:(1) -≻ (3)&gt;,
  &lt;1*c:(0) -≻ (2)&gt;, &lt;1*d:(2) -≻ (3)&gt;,
  &lt;1*e:(3) -≻ (3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( B.("a"), a );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( [ "V_0", "V_1", "V_2", "V_3" ], MakeReadWriteGlobal );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( [ "a", "b", "c", "d", "e" ], MakeReadWriteGlobal );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( B.("0"), B.("3") );</span>
&lt;A row module over Q of rank 6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom_03 := BasisOfExternalHom( B.("0"), B.("3") );</span>
[ &lt;1*a•b:(0) -≻ (3)&gt;, &lt;1*c•d:(0) -≻ (3)&gt;,
  &lt;1*a•b•e:(0) -≻ (3)&gt;, &lt;1*c•d•e:(0) -≻ (3)&gt;,
  &lt;1*a•b•e^2:(0) -≻ (3)&gt;, &lt;1*c•d•e^2:(0) -≻ (3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := 2*hom_03[1] + 3*hom_03[6];</span>
&lt;2*a•b + 3*c•d•e^2:(0) -≻ (3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LaTeXOutput( alpha );</span>
"{0}-\\left({2\\cdot {a}{b} + 3\\cdot {c}{d}{e}^{2}}\\right)\\rightarrow{3}"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha = CreateMorphism( B, B.("0"), [2, 0, 0, 0, 0, 3 ], B.("3") );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionOfMorphismInAlgebroid( alpha );</span>
[ [ 2, [ &lt;1*a:(0) -≻ (1)&gt;, &lt;1*b:(1) -≻ (3)&gt; ] ],
  [ 3, [ &lt;1*c:(0) -≻ (2)&gt;, &lt;1*d:(2) -≻ (3)&gt;,
         &lt;1*e:(3) -≻ (3)&gt;, &lt;1*e:(3) -≻ (3)&gt; ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B.("a•b•e");</span>
&lt;1*a•b•e:(0) -≻ (3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B.("abe");</span>
&lt;1*a•b•e:(0) -≻ (3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( B.("a"), B.("b") ) = B.("ab");</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := IsomorphismOntoAlgebroidFromDataTables( A );</span>
Isomorphism functor onto algebroid from data tables
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := IsomorphismFromAlgebroidFromDataTables( A );</span>
Isomorphism functor from algebroid from data tables
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( PreCompose( V, U ), alpha ) = alpha;</span>
true
#@if ValueOption( "no_precompiled_code" ) &lt;&gt; true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := ExtendFunctorToAdditiveClosures( V );</span>
Extension of Isomorphism functor from algebroid from data tables to
additive closures
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddC_B := SourceOfFunctor( V );</span>
Additive closure( Q-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,c:0-≻2,d:2-≻3,e:3-≻3] )
defined by 4 objects and 5 generating morphisms )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddC_B!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddC_A := RangeOfFunctor( V );</span>
Additive closure( Algebroid( Q, FreeCategory( RightQuiver( "q(0,1,2,3)[a:0-&gt;1,
b:1-&gt;3,c:0-&gt;2,d:2-&gt;3,e:3-&gt;3]" ) ) ) / relations )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddC_A!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o1 :=  RandomObject( AddC_B, [ [ 20 ], [ 1 ] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o2 :=  RandomObject( AddC_B, [ [ 20 ], [ 1 ] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V_o1 := V( o1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V_o2 := V( o2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1 := Sum( BasisOfExternalHom( o1, o2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2 := Sum( BasisOfExternalHom( V_o1, V_o2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V( s1 ) = s2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := RandomMorphism( o1, o2, 20 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := RandomMorphism( o1, o2, 20 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V_f := V( f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V_g := V( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1 := UnderlyingMatrix( HomStructure( f, g ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m2 := UnderlyingMatrix( HomStructure( V_f, V_g ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1 = m2;</span>
true
#@fi
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( B );</span>
PreSheaves( Q-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,c:0-≻2,d:2-≻3,e:3-≻3] )
defined by 4 objects and 5 generating morphisms, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y := YonedaEmbeddingOfSourceCategory( PSh );</span>
Yoneda embedding functor
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Y(B.("3")), PSh.("3") );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( Y(alpha), 2 * PSh.("a•b") + 3 * PSh.("c•d•e^2") );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( Y(alpha), 2 * PSh.("a•b") + 3 * PSh.("c•d•e^2") );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory( B.("e") );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( t );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B_op := OppositeAlgebroid( B );</span>
Q-algebroid( {0,1,2,3}[a:1-≻0,b:3-≻1,c:2-≻0,d:3-≻2,e:3-≻3] ) defined by
4 objects and 5 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B_op.("ba");</span>
&lt;1*b•a:(3) -≻ (0)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddC_B := AdditiveClosure( B );</span>
Additive closure( Q-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,c:0-≻2,d:2-≻3,e:3-≻3] )
defined by 4 objects and 5 generating morphisms )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := DirectSum( List( SetOfObjects( B ), o -&gt; o / AddC_B ) );</span>
&lt;An object in Additive closure( Q-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,c:0-≻2,
d:2-≻3,e:3-≻3] ) defined by 4 objects and 5 generating morphisms ) defined
by 4 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphism( T, T, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := RandomMorphism( T, T, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := RandomMorphism( T, T, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( PreCompose( [ u, v, w ] ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      = PreCompose( HomStructure( v ), HomStructure( u, w ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB := TensorProductOfAlgebroids( B, B );</span>
Q-algebroid( {0⊗0,0⊗1,0⊗2,..,3⊗1,3⊗2,3⊗3}[id(0)⊗a:0⊗0-≻0⊗1,id(0)⊗b:0⊗1-≻0⊗3
,id(0)⊗c:0⊗0-≻0⊗2,..,e⊗id(1):3⊗1-≻3⊗1,e⊗id(2):3⊗2-≻3⊗2,e⊗id(3):3⊗3-≻3⊗3] )
defined by 16 objects and 40 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryTensor( B.0, B.1 );</span>
&lt;(0⊗1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryTensor( B.a, B.b );</span>
&lt;1*a⊗b:(0⊗1) -≻ (1⊗3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryTensor( B.0, B.b );</span>
&lt;1*id(0)⊗b:(0⊗1) -≻ (0⊗3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryTensor( B.a, B.1 );</span>
&lt;1*a⊗id(1):(0⊗1) -≻ (1⊗1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3x3 := BB.("3⊗3");</span>
&lt;(3⊗3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphism( 3x3, 3x3, 15 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := RandomMorphism( 3x3, 3x3, 15 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := RandomMorphism( 3x3, 3x3, 15 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( PreCompose( [ u, v, w ] ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      = PreCompose( HomStructure( v ), HomStructure( u, w ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ideal := [ B.("ab") - B.("cd"), 2*B.("be") ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qB := B / ideal;</span>
QuotientCategory( Q-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,c:0-≻2,d:2-≻3,e:3-≻3] )
defined by 4 objects and 5 generating morphisms, 2-sided ideal generated
by 2 morphisms )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qB.0;</span>
&lt;(0)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RangeCategoryOfHomomorphismStructure( qB );</span>
Rows( Q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( qB.("cde") );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := RandomMorphism( qB, 20 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">1/2 * HomStructure( Source( f ), Range( f ), 2*HomStructure( f ) ) = f;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ideal := List( [ B.0, B.1, B.2 ], IdentityMorphism );</span>
[ &lt;1*id(0):(0) -≻ (0)&gt;, &lt;1*id(1):(1) -≻ (1)&gt;, &lt;1*id(2):(2) -≻ (2)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qB := B / ideal;</span>
QuotientCategory( Q-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,c:0-≻2,d:2-≻3,e:3-≻3] )
defined by 4 objects and 5 generating morphisms, 2-sided ideal generated
by 3 morphisms )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( [ qB.("0"), qB.("1"), qB.("2") ], IsZeroForObjects );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( qB.("3") );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">data_tables_2 := DataTablesOfCategory( qB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := AlgebroidFromDataTables( data_tables_2 );; # or alternatively</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := AlgebroidFromDataTables( qB );</span>
Q-algebroid( {3}[e:3-≻3] ) defined by 1 object and 1 generating morphism
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BasisOfExternalHom( D.3, D.3 );</span>
[ &lt;1*id(3):(3) -≻ (3)&gt;, &lt;1*e:(3) -≻ (3)&gt;, &lt;1*e^2:(3) -≻ (3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">data_tables_Z := ShallowCopy( data_tables );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">data_tables_Z!.coefficients_ring := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := AlgebroidFromDataTables( data_tables_Z );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RangeCategoryOfHomomorphismStructure( C );</span>
Rows( Z )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ideal := [ C.("ab") - C.("cd"), 2*C.("be") ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qC := C / ideal;</span>
QuotientCategory( Z-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,c:0-≻2,d:2-≻3,e:3-≻3] )
defined by 4 objects and 5 generating morphisms, 2-sided ideal generated by
2 morphisms )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RangeCategoryOfHomomorphismStructure( qC );</span>
Freyd( Rows( Z ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( qC.("cde") );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( 2*qC.("cde") );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddC_qC := AdditiveClosure( qC );</span>
Additive closure( QuotientCategory( Z-algebroid( {0,1,2,3}[a:0-≻1,b:1-≻3,
c:0-≻2,d:2-≻3,e:3-≻3] ) defined by 4 objects and 5 generating morphisms,
2-sided ideal generated by 2 morphisms ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RandomObject( AddC_qC, [[10],[1]] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphism( T, T, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := RandomMorphism( T, T, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := RandomMorphism( T, T, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( PreCompose( [ u, v, w ] ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      = PreCompose( HomStructure( v ), HomStructure( u, w ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( T, T, 2 * HomStructure( u ) ) = 2 * u;</span>
true
</pre></div>

<p><a id="X7D03633A7D98026B" name="X7D03633A7D98026B"></a></p>

<h4>6.5 <span class="Heading">GAP categories</span></h4>

<p><a id="X791ADDC27D32A418" name="X791ADDC27D32A418"></a></p>

<h5>6.5-1 IsAlgebroidFromDataTablesObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAlgebroidFromDataTablesObject</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of algebroids from data tables.</p>

<p><a id="X871C3D3C7B92DA8C" name="X871C3D3C7B92DA8C"></a></p>

<h5>6.5-2 IsCellInAlgebroidFromDataTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCellInAlgebroidFromDataTables</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of cells in an algebroid from data tables.</p>

<p><a id="X8517A59E7E8477C0" name="X8517A59E7E8477C0"></a></p>

<h5>6.5-3 IsAlgebroidFromDataTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAlgebroidFromDataTables</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of objects in an algebroid from data tables.</p>

<p><a id="X86CF900382BD9C83" name="X86CF900382BD9C83"></a></p>

<h5>6.5-4 IsAlgebroidFromDataTablesMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAlgebroidFromDataTablesMorphism</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of morphisms in an algebroid from data tables.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
