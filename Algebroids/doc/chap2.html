<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Algebroids) - Chapter 2: Finitely presented categories generated by enhanced quivers</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X861185FF7B4DCDFA" name="X861185FF7B4DCDFA"></a></p>
<div class="ChapSects"><a href="chap2.html#X861185FF7B4DCDFA">2 <span class="Heading">Finitely presented categories generated by enhanced quivers</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X871597447BB998A1">2.1 <span class="Heading">Properties</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X78E993C47DABFD1D">2.1-1 IsFinitelyPresentedCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X79B6CC3F7CC7749E">2.1-2 IsCommutative</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X84DFB4037AE10198">2.1-3 IsCounitary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D9CBEC58569ABFD">2.1-4 IsCoassociative</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7C701DBF7BAE649A">2.2 <span class="Heading">Attributes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D9198698398DF58">2.2-1 UnderlyingQuiver</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C9F9FC387908CB0">2.2-2 UnderlyingQuiverAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X85ECF1BD78493AE7">2.2-3 Size</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A6349F07EEB71EB">2.2-4 BasisPathsByVertexIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X82ED544480531F02">2.2-5 BasisMorphismsByVertexIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X85C28F1F7EFFCBD1">2.2-6 HomStructureOnBasisPaths</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8305207280C37C22">2.2-7 SetOfObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X83CE7FF47DA3F930">2.2-8 AssignSetOfObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X819E990D7BA5297E">2.2-9 SetOfGeneratingMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X872A32A0812DD3BD">2.2-10 SetOfGeneratingMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F70DA5B7F411DCA">2.2-11 SetOfGeneratingMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X83BE5E4985B1C3B4">2.2-12 SetOfGeneratingMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A4AA4397D0D4931">2.2-13 AssignSetOfGeneratingMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8051BD72857D190A">2.2-14 RelationsOfFpCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7FAA33DC872AEB4E">2.2-15 OppositeFpCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X861C64B57D06C972">2.2-16 Antipode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7AC45EE384D7677E">2.2-17 UnderlyingVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X85F9738A7E275A1A">2.2-18 UnderlyingQuiverAlgebraElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X78186C6081EB4FDB">2.2-19 UnderlyingAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X86C1C7237CA622C6">2.2-20 Parity</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7DFCB06D87404D4C">2.2-21 POW</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8336B2B57D160A41">2.2-22 NerveTruncatedInDegree2AsFunctor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X865644DA7A507FBB">2.2-23 YonedaFibrationAsNaturalTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X862D49ED796CA1DE">2.2-24 YonedaProjectionAsNaturalEpimorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X865CDAC97884FB7B">2.2-25 YonedaCompositionAsNaturalEpimorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X818D3E9480B21648">2.2-26 TruthMorphismOfTrueToSieveFunctor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7FF43076876F1372">2.2-27 SieveFunctor</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7DE8E16C7C2D387B">2.3 <span class="Heading">Operations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X854DFAED82305BDA">2.3-1 TrivialCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80E7B9BC8257615C"><code>2.3-2 \*</code></a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X83E46DDE78558CB7">2.3-3 ElementaryTensor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X823BC7F7839FC278">2.3-4 ElementaryTensor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X85645984879F87F9">2.3-5 ElementaryTensor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E37F76C84884F6E">2.3-6 QuiverVertexAsIdentityPath</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X86EC0F0A78ECBC10">2.4 <span class="Heading">Constructors</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C3141E47EB4F59D">2.4-1 FreeCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X854DC75A79DA46C4">2.4-2 ObjectInFpCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8420403685872077">2.4-3 MorphismInFpCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X86468CE97B1801F5"><code>2.4-4 \/</code></a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8126317783DFCEFE">2.5 <span class="Heading">Global functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7EE6F6C487FF8941">2.5-1 SimplicialCategoryTruncatedInDegree</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7D03633A7D98026B">2.6 <span class="Heading">GAP categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X815F0DAE7F450AB2">2.6-1 IsFpCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X81BD58AB7AFC2E94">2.6-2 IsMonoidAsCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7FFF25607DBCFB2B">2.6-3 IsCellInFpCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B9CF6887BC71EA3">2.6-4 IsObjectInFpCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X84DCB40484FA2BC7">2.6-5 IsMorphismInFpCategory</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">Finitely presented categories generated by enhanced quivers</span></h3>

<p><a id="X871597447BB998A1" name="X871597447BB998A1"></a></p>

<h4>2.1 <span class="Heading">Properties</span></h4>

<p><a id="X78E993C47DABFD1D" name="X78E993C47DABFD1D"></a></p>

<h5>2.1-1 IsFinitelyPresentedCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFinitelyPresentedCategory</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>Is the category <var class="Arg">C</var> finitely presented. This property is true by construction for finitely presented categories generated by finite quivers.</p>

<p><a id="X79B6CC3F7CC7749E" name="X79B6CC3F7CC7749E"></a></p>

<h5>2.1-2 IsCommutative</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCommutative</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: true or false</p>

<p>Check whether the finitely presented category <var class="Arg">C</var> is commutative.</p>

<p><a id="X84DFB4037AE10198" name="X84DFB4037AE10198"></a></p>

<h5>2.1-3 IsCounitary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCounitary</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: true or false</p>

<p>Check whether <var class="Arg">B</var> is counitary.</p>

<p><a id="X7D9CBEC58569ABFD" name="X7D9CBEC58569ABFD"></a></p>

<h5>2.1-4 IsCoassociative</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCoassociative</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: true or false</p>

<p>Check whether <var class="Arg">B</var> is coassociative.</p>

<p><a id="X7C701DBF7BAE649A" name="X7C701DBF7BAE649A"></a></p>

<h4>2.2 <span class="Heading">Attributes</span></h4>

<p><a id="X7D9198698398DF58" name="X7D9198698398DF58"></a></p>

<h5>2.2-1 UnderlyingQuiver</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingQuiver</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">QPA</strong> quiver</p>

<p>The quiver underlying the finitely presented category <var class="Arg">C</var>.</p>

<p><a id="X7C9F9FC387908CB0" name="X7C9F9FC387908CB0"></a></p>

<h5>2.2-2 UnderlyingQuiverAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingQuiverAlgebra</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">QPA</strong> path algebra</p>

<p>The quiver algebra (=path algebra with relations) underlying the finitely presented category <var class="Arg">C</var>.</p>

<p><a id="X85ECF1BD78493AE7" name="X85ECF1BD78493AE7"></a></p>

<h5>2.2-3 Size</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a nonnegative integer</p>

<p>The number of morphisms in the finitely presented category <var class="Arg">C</var>.</p>

<p><a id="X7A6349F07EEB71EB" name="X7A6349F07EEB71EB"></a></p>

<h5>2.2-4 BasisPathsByVertexIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BasisPathsByVertexIndex</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a matrix of basis paths of a <strong class="pkg">QPA</strong> path algebra</p>

<p>The matrix of basis paths of the canonical basis of the quiver algebra (=path algebra with relations) underlying the f.p. category <var class="Arg">C</var>, indexed by the vertex indices of source and target of the path.</p>

<p><a id="X82ED544480531F02" name="X82ED544480531F02"></a></p>

<h5>2.2-5 BasisMorphismsByVertexIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BasisMorphismsByVertexIndex</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a matrix of basis morphisms</p>

<p>The matrix of basis morphisms of the canonical basis of the quiver algebra (=path algebra with relations) underlying the f.p. category <var class="Arg">C</var>, indexed by the vertex indices of source and target of the morphism.</p>

<p><a id="X85C28F1F7EFFCBD1" name="X85C28F1F7EFFCBD1"></a></p>

<h5>2.2-6 HomStructureOnBasisPaths</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomStructureOnBasisPaths</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a six-dimensional matrix of matrices</p>

<p>The hom structure on basis paths of the canonical basis of the quiver algebra (=path algebra with relations) underlying the f.p. category <var class="Arg">C</var>: <code class="code">HomStructureOnBasisPaths( </code><var class="Arg">A</var><code class="code"> )[ v_index ][ w_index ][ v'_index ][ w'_index ][ basis_path_1_index ][ basis_path_2_index ] = [ Hom(v,w) -&gt; Hom(v',w'): x -&gt; basis_path_1 * x * basis_path_2 ]</code> for <code class="code">basis_path_1: v' -&gt; v</code> and <code class="code">basis_path_2: w -&gt; w'</code>.</p>

<p><a id="X8305207280C37C22" name="X8305207280C37C22"></a></p>

<h5>2.2-7 SetOfObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOfObjects</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The finite set of objects of the finitely presented category <var class="Arg">C</var>.</p>

<p><a id="X83CE7FF47DA3F930" name="X83CE7FF47DA3F930"></a></p>

<h5>2.2-8 AssignSetOfObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssignSetOfObjects</code>( <var class="Arg">C</var>, <var class="Arg">label</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>Assigns the objects of the finitely presented category <var class="Arg">C</var> to global variables. Names of the variables are the concatenation of <var class="Arg">label</var> with the names of the defining vertices.</p>

<p><a id="X819E990D7BA5297E" name="X819E990D7BA5297E"></a></p>

<h5>2.2-9 SetOfGeneratingMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOfGeneratingMorphisms</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The finite set of morphisms generating the finitely presented category <var class="Arg">C</var>.</p>

<p><a id="X872A32A0812DD3BD" name="X872A32A0812DD3BD"></a></p>

<h5>2.2-10 SetOfGeneratingMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOfGeneratingMorphisms</code>( <var class="Arg">C</var>, <var class="Arg">obj_1</var>, <var class="Arg">obj_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The subset of the generating morphisms that start at <var class="Arg">obj_1</var> and ends at <var class="Arg">obj_2</var>.</p>

<p><a id="X7F70DA5B7F411DCA" name="X7F70DA5B7F411DCA"></a></p>

<h5>2.2-11 SetOfGeneratingMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOfGeneratingMorphisms</code>( <var class="Arg">obj_1</var>, <var class="Arg">obj_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The subset of the generating morphisms that start at <var class="Arg">obj_1</var> and ends at <var class="Arg">obj_2</var>.</p>

<p><a id="X83BE5E4985B1C3B4" name="X83BE5E4985B1C3B4"></a></p>

<h5>2.2-12 SetOfGeneratingMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOfGeneratingMorphisms</code>( <var class="Arg">C</var>, <var class="Arg">i</var>, <var class="Arg">j</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Delegates to <code class="code">SetOfGeneratingMorphisms</code>( <var class="Arg">C</var>, <code class="code">SetOfObjects</code>(<var class="Arg">C</var>)[<var class="Arg">i</var>], <code class="code">SetOfObjects</code>(<var class="Arg">C</var>)[<var class="Arg">j</var>] ).</p>

<p><a id="X7A4AA4397D0D4931" name="X7A4AA4397D0D4931"></a></p>

<h5>2.2-13 AssignSetOfGeneratingMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssignSetOfGeneratingMorphisms</code>( <var class="Arg">C</var>, <var class="Arg">label</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>Assigns the generating morphisms of the finitely presented category <var class="Arg">C</var> to global variables. Names of the variables are the concatenation of <var class="Arg">label</var> with the names of the defining arrows.</p>

<p><a id="X8051BD72857D190A" name="X8051BD72857D190A"></a></p>

<h5>2.2-14 RelationsOfFpCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RelationsOfFpCategory</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">QPA</strong> path algebra</p>

<p>The relations of the finitely presented category <var class="Arg">C</var> corresponding to <code class="code">RelationsOfAlgebra( UnderlyingQuiverAlgebra( <var class="Arg">C</var> ) )</code>.</p>

<p><a id="X7FAA33DC872AEB4E" name="X7FAA33DC872AEB4E"></a></p>

<h5>2.2-15 OppositeFpCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OppositeFpCategory</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>The finitely presented category defined by the opposite of the underlying quiver with relations.</p>

<p><a id="X861C64B57D06C972" name="X861C64B57D06C972"></a></p>

<h5>2.2-16 Antipode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Antipode</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p>The antipode of the Hopf finitely presented category <var class="Arg">B</var>.</p>

<p><a id="X7AC45EE384D7677E" name="X7AC45EE384D7677E"></a></p>

<h5>2.2-17 UnderlyingVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingVertex</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a vertex in a <strong class="pkg">QPA</strong> quiver</p>

<p>The vertex of the quiver underlying the object <var class="Arg">obj</var> in a finitely presented category.</p>

<p><a id="X85F9738A7E275A1A" name="X85F9738A7E275A1A"></a></p>

<h5>2.2-18 UnderlyingQuiverAlgebraElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingQuiverAlgebraElement</code>( <var class="Arg">mor</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an element in a <strong class="pkg">QPA</strong> path algebra</p>

<p>The quiver algebra element underlying the morphism <var class="Arg">mor</var> in a finitely presented category.</p>

<p><a id="X78186C6081EB4FDB" name="X78186C6081EB4FDB"></a></p>

<h5>2.2-19 UnderlyingAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingAlgebra</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a ring</p>

<p>The underlying algebra of the finitely presented category <var class="Arg">C</var>.</p>

<p><a id="X86C1C7237CA622C6" name="X86C1C7237CA622C6"></a></p>

<h5>2.2-20 Parity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Parity</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a string ("left" or "right")</p>

<p>The parity of the finitely presented category <var class="Arg">C</var>.</p>

<p><a id="X7DFCB06D87404D4C" name="X7DFCB06D87404D4C"></a></p>

<h5>2.2-21 POW</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; POW</code>( <var class="Arg">C</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>The <var class="Arg">n</var>-th power of the finitely presented category <var class="Arg">C</var>. Admissible values for <var class="Arg">n</var> are <span class="Math">0,1,2</span>.</p>

<p><a id="X8336B2B57D160A41" name="X8336B2B57D160A41"></a></p>

<h5>2.2-22 NerveTruncatedInDegree2AsFunctor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NerveTruncatedInDegree2AsFunctor</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p>The input is a finitely presented category <var class="Arg">C</var> equipped with a homomorphism structure with values in the skeletal category <code class="code">SkeletalFinSets</code> of finite sets. The output is the nerve of <var class="Arg">B</var> truncated in degree <span class="Math">2</span>, as a presheaf on <code class="code">SimplicialCategoryTruncatedInDegree</code>(<span class="Math">2</span>) with values in <code class="code">SkeletalFinSets</code>.</p>

<p>We compute the nerve of the full subcategory of the simplicial category <span class="Math">\Delta</span> on the objects <span class="Math">[0], [1], [2]</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta2 := SimplicialCategoryTruncatedInDegree( 2 );</span>
FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelationsOfFpCategory( Delta2 );</span>
[ [ (s*id), (C0) ], [ (t*id), (C0) ],
  [ (ps*is), (C1) ], [ (pt*it), (C1) ],
  [ (is*id), (it*id) ], [ (pt*is), (id*t) ],
  [ (ps*it), (id*s) ], [ (s*pt), (t*ps) ],
  [ (s*mu), (s*ps) ], [ (t*mu), (t*pt) ],
  [ (mu*is), (C1) ], [ (mu*it), (C1) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( Delta2 );</span>
31
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := NerveTruncatedInDegree2AsFunctor( Delta2 );</span>
Functor from FreeCategory( RightQuiver(
  "Delta_op(C0,C1,C2)[id:C0-&gt;C1,s:C1-&gt;C0,t:C1-&gt;C0,
                      is:C1-&gt;C2,it:C1-&gt;C2,
                      ps:C2-&gt;C1,pt:C2-&gt;C1,mu:C2-&gt;C1]" ) ) / relations
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta2op := SourceOfFunctor( N );</span>
FreeCategory( RightQuiver(
  "Delta_op(C0,C1,C2)[id:C0-&gt;C1,s:C1-&gt;C0,t:C1-&gt;C0,
                      is:C1-&gt;C2,it:C1-&gt;C2,
                      ps:C2-&gt;C1,pt:C2-&gt;C1,mu:C2-&gt;C1]" ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N( Delta2op.C0 );</span>
|3|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N( Delta2op.C0 ) );</span>
{ 0, 1, 2 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N( Delta2op.C1 );</span>
|31|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N( Delta2op.C1 ) );</span>
{ 0,..., 30 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N( Delta2op.C2 );</span>
|393|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N( Delta2op.C2 ) );</span>
{ 0,..., 392 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N( Delta2op.id );</span>
|3| → |31|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N( Delta2op.id ) );</span>
{ 0, 1, 2 } ⱶ[ 0, 5, 21 ]→ { 0,..., 30 }
</pre></div>

<p><a id="X865644DA7A507FBB" name="X865644DA7A507FBB"></a></p>

<h5>2.2-23 YonedaFibrationAsNaturalTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YonedaFibrationAsNaturalTransformation</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> natural transformation</p>

<p>The input is a finitely presented category <var class="Arg">B</var>. The output is a natural morphism. Its source is the functor <span class="Math">B \to H, c \mapsto \sqcup_{a\in B} \mathrm{Hom}(a,c), \psi \mapsto \sqcup_{a\in B} \mathrm{Hom}(a,\psi)</span>. Its targe is the constant functor of <span class="Math">0</span>-cells <span class="Math">B \to H, c \mapsto B_0, \psi \mapsto \mathrm{id}_{B_0}</span>.</p>

<p><a id="X862D49ED796CA1DE" name="X862D49ED796CA1DE"></a></p>

<h5>2.2-24 YonedaProjectionAsNaturalEpimorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YonedaProjectionAsNaturalEpimorphism</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> natural transformation</p>

<p>The input is a finitely presented category <var class="Arg">B</var>. The output is a natural epimorphism. Its source is the functor <span class="Math">B \to H, c \mapsto \sqcup_{a,b\in B} \mathrm{Hom}(a,b) \times \mathrm{Hom}(b,c), \psi \mapsto \sqcup_{a,b\in B} \mathrm{Hom}(1_a,1_b) \times \mathrm{Hom}(b,\psi)</span>. Its target is the functor <span class="Math">B \to H, c \mapsto \sqcup_{a\in B} \mathrm{Hom}(a,c), \psi \mapsto \sqcup_{a\in B} \mathrm{Hom}(a,\psi)</span>.</p>

<p><a id="X865CDAC97884FB7B" name="X865CDAC97884FB7B"></a></p>

<h5>2.2-25 YonedaCompositionAsNaturalEpimorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YonedaCompositionAsNaturalEpimorphism</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> natural transformation</p>

<p>The input is a finitely presented category <var class="Arg">B</var>. The output is a natural epimorphism. Its source is the functor <span class="Math">B \to H, c \mapsto \sqcup_{a,b\in B} \mathrm{Hom}(a,b) \times \mathrm{Hom}(b,c), \psi \mapsto \sqcup_{a,b\in B} \mathrm{Hom}(1_a,1_b) \times \mathrm{Hom}(b,\psi)</span>. Its target is the functor <span class="Math">B \to H, c \mapsto \sqcup_{a\in B} \mathrm{Hom}(a,c), \psi \mapsto \sqcup_{a\in B} \mathrm{Hom}(a,\psi)</span>.</p>

<p>We compute the Yoneda composition natural epimorphism of the full subcategory of the simplicial category <span class="Math">\Delta</span> on the objects <span class="Math">[0], [1], [2]</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Delta2 := SimplicialCategoryTruncatedInDegree( 2 );</span>
FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelationsOfFpCategory( Delta2 );</span>
[ [ (s*id), (C0) ], [ (t*id), (C0) ],
  [ (ps*is), (C1) ], [ (pt*it), (C1) ],
  [ (is*id), (it*id) ], [ (pt*is), (id*t) ],
  [ (ps*it), (id*s) ], [ (s*pt), (t*ps) ],
  [ (s*mu), (s*ps) ], [ (t*mu), (t*pt) ],
  [ (mu*is), (C1) ], [ (mu*it), (C1) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( Delta2 );</span>
31
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ymu := YonedaCompositionAsNaturalEpimorphism( Delta2 );</span>
Natural transformation from
Functor from FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations -&gt;
SkeletalFinSets
-&gt;
Functor from FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations -&gt;
SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ymu := YonedaProjectionAsNaturalEpimorphism( Delta2 );</span>
Natural transformation from
Functor from FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations -&gt;
SkeletalFinSets
-&gt;
Functor from FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations -&gt;
SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ys := YonedaFibrationAsNaturalTransformation( Delta2 );</span>
Natural transformation from
Functor from FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations -&gt;
SkeletalFinSets
-&gt;
Functor from FreeCategory( RightQuiver(
  "Delta(C0,C1,C2)[id:C1-&gt;C0,s:C0-&gt;C1,t:C0-&gt;C1,
                   is:C2-&gt;C1,it:C2-&gt;C1,
                   ps:C1-&gt;C2,pt:C1-&gt;C2,mu:C1-&gt;C2]" ) ) / relations -&gt;
SkeletalFinSets
</pre></div>

<p><a id="X818D3E9480B21648" name="X818D3E9480B21648"></a></p>

<h5>2.2-26 TruthMorphismOfTrueToSieveFunctor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TruthMorphismOfTrueToSieveFunctor</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p>Return the truth morphism of true from terminal functor to the functor of sieves from <code class="code">OppositeFpCategory</code>( <var class="Arg">B</var> ) to <code class="code">RangeCategoryOfHomomorphismStructure</code>( <var class="Arg">B</var> ).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[a:1-&gt;1]" );</span>
q(1)[a:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fq := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M0 := Fq / [ [ Fq.a^3, Fq.1 ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S0 := SieveFunctor( M0 );</span>
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = 1 ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M0op := AsCapCategory( Source( S0 ) );</span>
FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S0( M0op.1 );</span>
|2|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S0( M0op.1 ) );</span>
{ 0, 1 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S0( M0op.a );</span>
|2| → |2|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S0( M0op.a ) );</span>
{ 0, 1 } ⱶ[ 0, 1 ]→ { 0, 1 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M1 := Fq / [ [ Fq.a^3, Fq.a ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1 := SieveFunctor( M1 );</span>
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M1op := AsCapCategory( Source( S1 ) );</span>
FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1( M1op.1 );</span>
|3|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S1( M1op.1 ) );</span>
{ 0, 1, 2 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1( M1op.a );</span>
|3| → |3|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S1( M1op.a ) );</span>
{ 0, 1, 2 } ⱶ[ 0, 2, 2 ]→ { 0, 1, 2 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M2 := Fq / [ [ Fq.a^3, Fq.a^2 ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2 := SieveFunctor( M2 );</span>
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M2op := AsCapCategory( Source( S2 ) );</span>
FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2( M2op.1 );</span>
|4|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S2( M2op.1 ) );</span>
{ 0 ,..., 3 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2( M2op.a );</span>
|4| → |4|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S2( M2op.a ) );</span>
{ 0,..., 3 } ⱶ[ 0, 2, 3, 3 ]→ { 0,..., 3 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eta2 := TruthMorphismOfTrueToSieveFunctor( M2 );</span>
Natural transformation from
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
-&gt;
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eta2( M2op.1 );</span>
|1| → |4|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( eta2( M2op.1 ) );</span>
{ 0 } ⱶ[ 3 ]→ { 0,..., 3 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota2 := EmbeddingOfSieveFunctor( M2 );</span>
Natural transformation from
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
-&gt;
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota2( M2op.1 );</span>
|4| → |8|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( iota2( M2op.1 ) );</span>
{ 0,..., 3 } ⱶ[ 0, 4, 6, 7 ]→ { 0,..., 7 }
</pre></div>

<p><a id="X7FF43076876F1372" name="X7FF43076876F1372"></a></p>

<h5>2.2-27 SieveFunctor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SieveFunctor</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> functor</p>

<p>Return the functor of sieves from <code class="code">OppositeFpCategory</code>( <var class="Arg">B</var> ) to <code class="code">RangeCategoryOfHomomorphismStructure</code>( <var class="Arg">B</var> ).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[a:1-&gt;1]" );</span>
q(1)[a:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fq := FreeCategory( q );</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M0 := Fq / [ [ Fq.a^3, Fq.1 ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S0 := SieveFunctor( M0 );</span>
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = 1 ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M0op := AsCapCategory( Source( S0 ) );</span>
FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S0( M0op.1 );</span>
|2|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S0( M0op.1 ) );</span>
{ 0, 1 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S0( M0op.a );</span>
|2| → |2|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S0( M0op.a ) );</span>
{ 0, 1 } ⱶ[ 0, 1 ]→ { 0, 1 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M1 := Fq / [ [ Fq.a^3, Fq.a ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1 := SieveFunctor( M1 );</span>
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M1op := AsCapCategory( Source( S1 ) );</span>
FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1( M1op.1 );</span>
|3|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S1( M1op.1 ) );</span>
{ 0, 1, 2 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1( M1op.a );</span>
|3| → |3|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S1( M1op.a ) );</span>
{ 0, 1, 2 } ⱶ[ 0, 2, 2 ]→ { 0, 1, 2 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M2 := Fq / [ [ Fq.a^3, Fq.a^2 ] ];</span>
FreeCategory( RightQuiver( "q(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2 := SieveFunctor( M2 );</span>
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M2op := AsCapCategory( Source( S2 ) );</span>
FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2( M2op.1 );</span>
|4|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S2( M2op.1 ) );</span>
{ 0 ,..., 3 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2( M2op.a );</span>
|4| → |4|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S2( M2op.a ) );</span>
{ 0,..., 3 } ⱶ[ 0, 2, 3, 3 ]→ { 0,..., 3 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eta2 := TruthMorphismOfTrueToSieveFunctor( M2 );</span>
Natural transformation from
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
-&gt;
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eta2( M2op.1 );</span>
|1| → |4|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( eta2( M2op.1 ) );</span>
{ 0 } ⱶ[ 3 ]→ { 0,..., 3 }
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota2 := EmbeddingOfSieveFunctor( M2 );</span>
Natural transformation from
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
-&gt;
Functor from FreeCategory( RightQuiver( "q_op(1)[a:1-&gt;1]" ) ) / [ a*a*a = a*a ]
-&gt; SkeletalFinSets
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota2( M2op.1 );</span>
|4| → |8|
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( iota2( M2op.1 ) );</span>
{ 0,..., 3 } ⱶ[ 0, 4, 6, 7 ]→ { 0,..., 7 }
</pre></div>

<p><a id="X7DE8E16C7C2D387B" name="X7DE8E16C7C2D387B"></a></p>

<h4>2.3 <span class="Heading">Operations</span></h4>

<p><a id="X854DFAED82305BDA" name="X854DFAED82305BDA"></a></p>

<h5>2.3-1 TrivialCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialCategory</code>( <var class="Arg">str</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X80E7B9BC8257615C" name="X80E7B9BC8257615C"></a></p>

<h5><code>2.3-2 \*</code></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \*</code>( <var class="Arg">C</var>, <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X83E46DDE78558CB7" name="X83E46DDE78558CB7"></a></p>

<h5>2.3-3 ElementaryTensor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryTensor</code>( <var class="Arg">a</var>, <var class="Arg">b</var>, <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism in a <strong class="pkg">CAP</strong> category</p>

<p>Given an object <var class="Arg">a</var> in a finitely presented category A and an object <var class="Arg">b</var> in a finitely presented category B and the tensor product <var class="Arg">T</var> of A and B, return the tensor product of a and b in T.</p>

<p><a id="X823BC7F7839FC278" name="X823BC7F7839FC278"></a></p>

<h5>2.3-4 ElementaryTensor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryTensor</code>( <var class="Arg">a</var>, <var class="Arg">g</var>, <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism in a <strong class="pkg">CAP</strong> category</p>

<p>Given an object <var class="Arg">a</var> in a finitely presented category A and a morphism <var class="Arg">g</var> in a finitely presented category B and the tensor product <var class="Arg">T</var> of A and B, return the tensor product of a and g in T.</p>

<p><a id="X85645984879F87F9" name="X85645984879F87F9"></a></p>

<h5>2.3-5 ElementaryTensor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryTensor</code>( <var class="Arg">f</var>, <var class="Arg">b</var>, <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism in a <strong class="pkg">CAP</strong> category</p>

<p>Given a morphism <var class="Arg">f</var> in a finitely presented category A and an object <var class="Arg">b</var> in a finitely presented category B and the tensor product <var class="Arg">T</var> of A and B, return the tensor product of f and b in T.</p>

<p><a id="X7E37F76C84884F6E" name="X7E37F76C84884F6E"></a></p>

<h5>2.3-6 QuiverVertexAsIdentityPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuiverVertexAsIdentityPath</code>( <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a path</p>

<p>Simply returns <var class="Arg">vertex</var>, but with the semantics of being an identity path.</p>

<p><a id="X86EC0F0A78ECBC10" name="X86EC0F0A78ECBC10"></a></p>

<h4>2.4 <span class="Heading">Constructors</span></h4>

<p><a id="X7C3141E47EB4F59D" name="X7C3141E47EB4F59D"></a></p>

<h5>2.4-1 FreeCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeCategory</code>( <var class="Arg">q</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Category</code>( <var class="Arg">q</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuotientCategory</code>( <var class="Arg">C</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; /</code>( <var class="Arg">C</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>Construct the finitely presented category generated by the quiver <var class="Arg">q</var>, possibly modulo the relations <var class="Arg">L</var>.</p>

<p><a id="X854DC75A79DA46C4" name="X854DC75A79DA46C4"></a></p>

<h5>2.4-2 ObjectInFpCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectInFpCategory</code>( <var class="Arg">A</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an object in a <strong class="pkg">CAP</strong> category</p>

<p>The constructor of objects in a finitely presented category <var class="Arg">C</var> given a vertex <var class="Arg">V</var> in the underlying quiver.</p>

<p><a id="X8420403685872077" name="X8420403685872077"></a></p>

<h5>2.4-3 MorphismInFpCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismInFpCategory</code>( <var class="Arg">S</var>, <var class="Arg">path</var>, <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismInFpCategory</code>( <var class="Arg">A</var>, <var class="Arg">path</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an object in a <strong class="pkg">CAP</strong> category a morphism in a <strong class="pkg">CAP</strong> category</p>

<p>Delegates to <code class="code">ObjectInFpCategory</code>( <var class="Arg">C</var>, <var class="Arg">V</var> ). The constructor of morphisms in a finitely presented category <var class="Arg">C</var> given the source <var class="Arg">S</var>, the target <var class="Arg">T</var>, and the underlying path <var class="Arg">path</var>. If neither <var class="Arg">S</var> nor <var class="Arg">T</var> are provided they are read off from <var class="Arg">path</var>.</p>

<p><a id="X86468CE97B1801F5" name="X86468CE97B1801F5"></a></p>

<h5><code>2.4-4 \/</code></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \/</code>( <var class="Arg">path</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism in a <strong class="pkg">CAP</strong> category</p>

<p>Delegates to <code class="code">MorphismInFpCategory</code>( <var class="Arg">path</var> ).</p>

<p><a id="X8126317783DFCEFE" name="X8126317783DFCEFE"></a></p>

<h4>2.5 <span class="Heading">Global functions</span></h4>

<p><a id="X7EE6F6C487FF8941" name="X7EE6F6C487FF8941"></a></p>

<h5>2.5-1 SimplicialCategoryTruncatedInDegree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialCategoryTruncatedInDegree</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">CAP</strong> category</p>

<p>The full subcategory of the simplicial category <span class="Math">\Delta</span> on the objects <span class="Math">[0], \ldots, [n]</span>.</p>

<p><a id="X7D03633A7D98026B" name="X7D03633A7D98026B"></a></p>

<h4>2.6 <span class="Heading">GAP categories</span></h4>

<p><a id="X815F0DAE7F450AB2" name="X815F0DAE7F450AB2"></a></p>

<h5>2.6-1 IsFpCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFpCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of finitely presented categories.</p>

<p><a id="X81BD58AB7AFC2E94" name="X81BD58AB7AFC2E94"></a></p>

<h5>2.6-2 IsMonoidAsCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMonoidAsCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of algebras.</p>

<p><a id="X7FFF25607DBCFB2B" name="X7FFF25607DBCFB2B"></a></p>

<h5>2.6-3 IsCellInFpCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCellInFpCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of cells in a finitely presented category.</p>

<p><a id="X7B9CF6887BC71EA3" name="X7B9CF6887BC71EA3"></a></p>

<h5>2.6-4 IsObjectInFpCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsObjectInFpCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of objects in a finitely presented category.</p>

<p><a id="X84DCB40484FA2BC7" name="X84DCB40484FA2BC7"></a></p>

<h5>2.6-5 IsMorphismInFpCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMorphismInFpCategory</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of morphisms in a finitely presented category.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
